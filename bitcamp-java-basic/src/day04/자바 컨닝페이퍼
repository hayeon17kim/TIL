자바 클래스 컨닝페이퍼

클래스란?
클래스란 하나의 프로그램으로써
3세대 언어에서는 프로그램을 여러 개의 작은 프로그램의 
집합으로 보기 때문에
우리의 필요에 따라서 그러한 작은 프로그램을 만들고
그리고 하나의 커다란 프로그램 안에서 그 작은 프로그램들을 호출해서
그 작은 프로그램들이 만드는 메시지들을 컨트롤해서 커다란 프로그램이
통합적으로 사용하게 된다. 

객체란?
클래스형 변수를 객체라고 한다.
예를 들어서 String 객체라고 한다면
String 클래스 데이터타입을 가진 변수를 String 객체라고 한다.

클래스는 field와 method로 이루어져 있다.
field: 해당 객체가 다룰 데이터를 정의해 놓은 것
method: 해당 클래스가 가지고 있는 기능

객체의 필드란 학생을 예로 들어보자면
학생의 이름
학생의 국어점수
학생의 영어점수 등이
학생이 가지고 있을 정보의 틀이 된다.

클래스의 메소드란 학생이라는 객체가 가지고 있을
기능들이 된다.
예시로는
평균 계산
총점 계산
정보 출력 등이 있다.

2세대 언어에서는 이 정보를 담는 틀과 기능을 별개로 놓고 보았기 때문에
우리가 실질적으로 재사용할 수 있는 부분은 기능 부분만이 되었었다.

하지만 3세대 언어에서는 굳이 기능 부분만 재사용하지 말고
해당 기능들을 학생에 특화되게 만들어서 통째로 재사용하자 이런 관점으로 보게 되는 것이다.

즉 학생이란 객체는 기능은 모두 통일되어 있지만
어떤 정보를 담냐에 따라서 어떤 학생인지가 정해지는 것이다.

필드를 선언하는 방법
변수 선언과 똑같다.
예시: String name; int age; int Korean;

메소드를 만드는 방법
메소드는
리턴타입 메소드이름(파라미터) 로 이루어져 있다.

리턴 타입: 해당 메소드가 종료되면서 그 메소드를 호출한 곳으로 보내주는
		 데이터의 자료형
		 리턴 타입은 다른 클래스가 될 수도 있고 기본형 데이터타입이 될 수도 있고
		 뭐든 할 수 있다.
		 단, 해당 리턴 타입을 반드시 메소드가 return 이라는 명령어를 통해서
		 호출된 곳으로 돌려보내야 한다.
		 만약 아무것도 돌려 보내지 않을 거라면 void라고 적어야 하고 void라고 적으면
		 return을 쓰면 안된다.

메소드 이름: 소문자로 시작하는 동사

파라미터: 해당 메소드가 실행되는 데 필요로 하는 외부의 값
		특별히 외부의 값을 필요로 하지 않는다면, 파라미터는 비워둘 수 있다.

생성자: Constructor
	     해당 객체가 생성될 때 만약 값을 미리 셋팅하거나
	     추가적인 작업을 해주어야 한다면 우리가 생성자 메소드를 만들어서
	     해줄 수도 있다.
	     
	     자바에서는 기본적으로 제공해주는 기본 생성자가 있는데
	     해당 기본생성자의 경우에는 
	     참조형 데이터타입을 가진 필드는 null
	     기본형 데이터타입을 가진 필드는 0으로 초기화해준다.
	     
	     우리가 생성자를 직접 만들어줄 수도 있는데
	     이때 주의해야 하는 것은
	     기본 생성자를 더이상 사용할 수 없게 된다는 것이다.
	     즉 우리가 생성자에 파라미터를 정의하게 되면
	     더이상 파라미터 없는 생성자를 호출할 수 없다는 것이다.
	     
	     따라서 우리는 그렇게 파라미터 있는 생성자와 파라미터 없는 생성자가 필요할 때에는
	     모두 정의해 주어야 한다는 것이다.
	     
	     생성자는 클래스이름() 로 정의된다.
	    
	    
new: 참조형 데이터타입을 메모리에 등록시키는 키워드
null: 참조형 데이터타입이 선언은 되어있지만 메모리에 등록이 안 되어서 사용할 수 없는 상태
오버로딩: 같은 이름의 메소드이지만 파라미터가 달라져서 우리가 같은 목적을 가진 메소드들을
		한 개의 이름으로 통일시킬 수 있게 하는 방법
		같은 이름, 같은 파라미터이면 에러가 나지만 같은 이름에 다른 파라미터를 가진 메소드는
		우리가 여러개 선언할 수 있다.
		
		파라미터가 달라진다는 것은 메소드를 정의할 때 해당 파라미터를 적는 칸에 들어 있는 
		파라미터의 데이터타입의 갯수가 달라진다는 것이다.
		예시: System.out.println(String string)과 
			 System.out.println(int a)
			  는 파라미터가 다르다.
			 System.out.println(String str1)과
			 System.out.println(String str2)는
			  파라미터가 같다. -> System.out.println("abc")는 어느 메소드를 호출해야 되나
			 
this: 가끔 보면 파라미터 이름이 필드 이름과 같을 때도 있다.
	    그렇게 같은 경우에는 그러면 내가 호출한 이름이 파라미터인지 필드인지 어떻게 알 수 있을까?
	  this.을 붙인 이름은 무조건 필드를 가리키게 된다.
	     안 붙이면 무조건 파라미터이다.
	     
	     
클래스는 우리가 정의하지 않은 자바에서 기본적으로 제공해주는 몇몇 메소드를
"상속"이라는 개념을 통해서 쓸 수 있다.
상속된 메소드는 우리가 우리의 클래스에 안 적어놔도 자유롭게 쓸 수 있지만
단점은 우리 클래스와 맞지 않을 수 있다는 것이다.

그러면 해당 메소드를 우리 클래스에 맞게 재정의 해주면 된다.
그러한 재정의는 우리를 override라고 부른다.


접근 제한자 (Access Modifier)
접근 제한자란?
필드나 메소드에 접근 범위를 설정하는 키워드

public - protected - package - private 순으로
범위가 좁아진다.

public: 패키지 외부 + 상속받는 클래스 접근 가능
protected: 패키지 내부 + 상속받는 클래스 접근 가능
package: 패키지 내부만 접근 가능(아무것도 적어주지 않으면 자동으로 패키지가 적용됨)
private: 해당 클래스 내부에서만 접근 가능 

전에는 굳이 필드에 접근 제한자를 적거나 하지 않았지만
이제는 모든 필드를 private으로 놓고
외부가 호출하지 않을 메소드들도 모두 private으로 둔다.

하지만 필드를 private으로 넣으면 우리는 더이상
필드에 값을 직접 넣거나 직접 호출하는 것은
불가능해진다. 
그렇다면 어떻게 해야 할까?

그럼 메소드를 통해서 해주면 된다.
이렇게 필드에 외부의 값을 저장하는 메소드를 setter 메소드라고 하고
필드의 값을 외부로 return해주는 메소드를 getter 메소드라고 한다.

setter 메소드는

public void set필드이름(필드데이터타입 필드이름){
	this.필드이름 = 필드이름;
}

이 기본 형태이다.

getter 메소드는
public void get필드이름(필드데이터타입 필드이름){
	this.필드이름 = 필드이름;
}

이 기본 형태이다.

필요에 따라서 겟터 셋터 내부에서 데이터를 검증하거나 형식을 바꾸어서 보내주는 코드를
구현해줄 수도 있다. 

클래스 내부의 필드나 메소드는 항상 객체를 생성해서 그 객체 내부를 .으로 접근해서 사용하는 게 맞지만
static 이라는 키워드를 붙여주면 객체 생성 없이
"Ex01.main(args)" 이런 식으로 호출이 가능해진다.
단 static이 붙는 메소드가 다른 메소드나 혹은 필드를 사용한다면 전부 다 static을 
붙여 주어야 한다.






