



- HAL: 프로그램이 운영체제에서 제공해주는 함수를 호출하고, 이 함수가 하드웨어를 제어하는 function을 호출하는 구조로 되어 있다. 직접 하드웨어 제조사의 함수를 호출하면 특정 하드웨어에 종속될 수 있으니까 hardware abstraction layer (하드웨어 추상화): 프로그래머가 디바이스 독립적인 프로



운영체제에서 돌리려면 파이썬 라이브러리, 파이썬에 이쓴ㄴ 메서드를 호출하면 내부적으로 운영체제에 있는 c/c++를 호출. 윈도우에서는윈도우용 파이썬 라이브러리, 맥에서는 맥용 JVM 

게임 속도를 높이기 위해 device 겸 ~ 다이렉트X: (할 계층을 타지 않고.) 하드웨어 제공자가 DirectX를 준다. 맥에는 DirectX가 없다.





바이트 스트림은 바로 출력한다.

캐릭터 스트림은 내부 버퍼에 담아놓기 때문에 바로 출력하지 않는다/



둘다 내부적으로 버퍼를 조금씩 쓴다.  cs의 경우 출력 데이터를 내부 버퍼에 보관하고 있다가 flush()가 호출되면 비로소 출력을 수행한다. PrintWriter와 PrintStream도 둘다 버퍼를 쓰고 있다. 근데 printstream은 자기 내부적으로 처리하기 때문에 상관하지 말아도 됨 후자는 어딘가에 임시보관해야 ㅎㄴ다. 문자를 출력학 ㅣ위해서 PrintStream도 텍스트 출력하는 걸 위해서 버퍼라이터를 준비하고 있고, printWriter도 문자열 출력 상관 없이.. 내부적으로 쓰고 있다. 근데 깊게 들어가지 마라. 내부 구현 방법은 op[en jdk], ibm 다 다를 수 있음. byte stream은 바로 출력하고 character stream은 바로 출력 x 한다는 것만 기억해라. 

실무에서는 출력을 해야한다고 확신을 한다면 바이트 스트림이든 캐릭터 스트림이든 flush()를 호출해라. 



메모리 효율성이 떨어진다. 대신 고객은 편하다. stateful 방식으로 동작하면 고객은 언제든지 요청하고 응답할 수 있으니까 

요청할 게 있으면 연결하고 바로 연결 끊기 때문에 서버는 보다 많은 클라이언트 요청을 처리할 수 있다. 그러나 클라이언트 입장에서는 

```java
public class Server0110 {
  public static void main(String[] args) {
    try (Scanner keyboard = new Scanner(System.in);
        ServerSocket serverSocket = new ServerSocket(8888)) {
      System.out.println("서버 실행!");
      
      try (Socket socket = serverSocket.accept();
          BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
          PrintWriter out = new PrintWriter(socket.getOutputStream())) {
        System.out.println("클라이언트가 연결되었음!");
        
        while (true) {
          String name = in.readLine();
          if (name.equalsIgnoreCase("quit")) {
            out.println("Goodbye!");
            out.flush();
            break;
          }
          out.printf("%s님 반갑습니다!\n", name);
          out.flush();
        }
      }
      System.out.println("클라이언트와 연결을 끊었음.");
    } catch (Exception e) {
      e.printStackTrace();
    }
    System.out.println("서버 종료!");
    
  }
}

```

데이터를ㄹ 보내봐야 서버는 응답도 안한다. 계속 기다려야ㅐ 한다 대기열 첫번째 애가 연결 끝날 때까지



stateless에서 클라이언트를 구분하는 방법 

내부적으로 세션 아이디를 계속 보낸다. 

웹에서는 stateless 방식으로 통신한다/
