---
title: ":tent: 학원 #57일차: Observer 패턴, 네트워크 프로그램 실습"
categories: bitcamp
tags: [ bitcamp, java ]
---

# 네트워크 API를 활용한 C/S 아키텍처

## 클라이언트/서버 프로젝트 준비

> git/eomcs-java-project/mini-pms-34-a-client/server
>
> git/eomcs-java-project/mini-pms-34-b-client/server

### 데스크톱 애플리케이션

- 다른 애플리케이션과 연동하지 않고 단독적으로 실행한다.
- 보통 PC나 노트북에 설치해서 사용한다.
- MS-Word, Adobe Photoshop, 메모장 등

### Client/Server 애플리케이션

- 클라이언트는 서버에게 서비스나 자원을 요청하는 일을 한다.
- 서버는 클라이언트에게 자원이나 서비스를 제공하는 일을 한다.



### 실습

- 1단계: 서버/클라이언트 프로젝트 폴더 생성
- 2단계: 서버/클라이언트 프로젝트 폴더를 Maven 기본 자바 디렉토리 구조로 초기화
  - `gradle init` 실행
- 3단계: 이클립스 IDE로 임포트
  - `build.gradle`에 `eclipse` gradle 플러그인 추가
  - `gradle eclipse`: 이클립스 설정 파일 생성
  - 이클립스에서 프로젝트 폴더 임포트
- 4단계: 애플리케이션 메인 클래스를 변경
  - 각 `App.java`를 `ServerApp.java`와 `ClientApp.java`로 변경



## 간단한 메시지 송수신

**Server**

- ServerSocket을 준비해 클라이언트를 기다린다.
- accept()를 통해 리턴된 소켓 객체로부터 입출력 스트림을 얻는다.
- 클라이언트가 보낸 데이터를 그대로 반송한다.

```java
public class ServerApp {
  public static void main(String[] args) {
    try (ServerSocket serverSocket = new ServerSocket(8888)) {
      System.out.println("서버 실행 중...");
      
      try (Socket socket = serverSocket.accept();
          BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
          PrintWriter out = new PrintWriter(socket.getOutputStream())) {
        String request = in.readLine();
        
        out.println(request);
        out.flush();
      } 
    } catch (Exception e) {
      e.printStackTrace;
    }
  }
}
```

**Client**

- 서버와 연결한 후 메시지를 주고 받는다.
- `ClientApp`으로 이름을 변경한 후 서버와 연결된 Socket 객체를 통해 입출력 스트림을 준비하여 메시지를 주고받는다.

```java
public class ClientApp {
  public static void main(String[] args) {
    try (Socket socket = new Socket("localhost", 8888);
        PrintWriter out = new PrintWriter(socket.getOutputStream());
         BufferedReader in = BufferedReader(new InputStreamReader(socket.getInputStream())) {
           out.println("Hello!");
           out.flush();
           
           String response = in.readLine();
           System.out.println(response);
           
         } catch (Exception e) {
           e.printStackTrace();
         }
  }
}
```



## 사용자가 입력한 명령 처리

**Client**

- 사용자가 입력한 명령을 서버에 전송한다. 
- 사용자가 quit 명령을 입력할 때까지 반복한다.
- stateful 통신

```java
public class ClientApp {
  public static void main(String[] args) {
    try (Socket socket = new Socket("localhost", 8888);
        PrintWriter out = new PrintWriter(socket.getOutputStream());
        BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {

      while (true) {
        String input = Prompt.inputString("명령> ");
        out.println(input);
        out.flush();

        String response = in.readLine();
        System.out.println(response);

        if (input.equalsIgnoreCase("quit"))
          break;
      }

    } catch (Exception e) {
      e.printStackTrace();
    }
  }
}
```

**Server**

- 클라이언트의 요청을 반복해서 처리한다.
- 클라이언트가 `quit` 명령을 보내면 응답한 후 클라이언트와의 연결을 끊는다.

```java
public class ServerApp {
  public static void main(String[] args) {
    try (ServerSocket serverSocket = new ServerSocket(8888)) {
      System.out.println("서버 실행 중...");

      try (Socket socket = serverSocket.accept();
          BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
          PrintWriter out = new PrintWriter(socket.getOutputStream())) {

        while (true) {
          String request = in.readLine();

          out.println(request);
          out.flush();

          if (request.equalsIgnoreCase("quit"))
            break;
        }
      }

    } catch (Exception e) {
      e.printStackTrace();
    }
  }
}
```



## 응답 프로토콜 변경

**Server**



**Client**

서버가 응답의 끝을 알리는 빈 줄을 보낼 때까지 클라이언트는 계속 읽는다.

```java
public class ClientApp {
  public static void main(String[] args) {
    try (Socket socket = new Socket("localhost", 8888);
        PrintWriter out = new PrintWriter(socket.getOutputStream());
        BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {

      while (true) {
        String input = Prompt.inputString("명령> ");
        out.println(input);
        out.flush();

        String response = in.readLine();
        System.out.println(response);

        if (input.equalsIgnoreCase("quit"))
          break;
      }

    } catch (Exception e) {
      e.printStackTrace();
    }
  }
}
```





### 6단계: 클라이언트 명령이 들어오면 커맨드 객체를 찾아서 실행한다.

- Command  인터페이스 변경
  - 커맨드 객체가 클라이언트에게 응답할 수 있도록 출력 스트림 객체를 넘겨준다.
  - `execute()`를 `execute(PrintWrite)`로 변경한다.
- `XxxCommand` 구현체를 변경
  - `Command` 인터페이스 변경에 따라 `execute()` 메서드의 코드를 수정한다.
- `ServerApp` 변경
  - 커맨드 객체의 execute() 를 호출할 때 클라이언트 출력 스트림을 제공한다.
  - `sendResponse()` 메서드는 제거한다.

**Command**

```java
// 사용자의 명령을 처리하는 객체에 대해 호출할 메서드 규칙을 정의 한다.
public interface Command {
  void execute(PrintWriter out);
}
```

**BoardListCommand**

```java

```





**ServerApp**

```java
public class ServerApp {
  
  // 클라이언트가 stop명령을 보내면 이 값이 true로 변경된다.
  // 인스턴스 메서드가 되면 안된다. handleClient가 static 이기 때문에  static 멤버에만 접근 가능하다.
  static boolean stop = false;

  static Map<String, Object> context;

  List<ApplicationContextListener> listeners = new ArrayList<>();


  private void addApplicationContextListener (ApplicationContextListener listener) {
    listeners.add(listener);
  }

  private void removeApplicationContextListener (ApplicationContextListener listener) {
    listeners.remove(listener);
  }

  private void notifyApplicationContextListenerOnServiceStarted() {
    for (ApplicationContextListener listener : listeners) {
      listener.contextInitialized(context);
    }
  }

  private void notifyApplicationContextListenerOnServiceStopped() {
    for (ApplicationContextListener listener : listeners) {
      listener.contextDestroyed(context);
    }
  }

  public void service(int port) {
    
    notifyApplicationContextListenerOnServiceStarted();
    
    try (ServerSocket ss = new ServerSocket(8888)){
      System.out.println("서버 실행 중...");
      while (true) {
        Socket clientSocket = ss.accept();
        new Thread(() ->handleClient(clientSocket)).start();
        if (stop) {
          break; // 즉시 멈추진 않고, 다음의 클라이언트가 접속할 때 안되겠지.
        }
      }
    } catch (Exception e) {
      e.printStackTrace();
    }
    notifyApplicationContextListenerOnServiceStopped();
  }

  public static void main(String[] args) {
    ServerApp server = new ServerApp();
    
    server.addApplicationContextListener(new AppInitListener());
    server.addApplicationContextListener(new DataHandlerListener());
    server.addApplicationContextListener(new RequestMappingListener());
    
    server.service(8888);
  }

  private static void handleClient(Socket clientSocket) {
    InetAddress address = clientSocket.getInetAddress();
    System.out.printf("클라이언트(%s)가 연결되었습니다.\n", address.getHostAddress());
    try (Socket socket = clientSocket; 
        BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
        PrintWriter out = new PrintWriter(socket.getOutputStream()))  {
      while (true) {
        String request = in.readLine();
        
        Command command = (Command) context.get(request);
        if (command != null) {
          // 출력 스트림을 파라미터로 넘긴다.
          command.execute(out);
        } else {
          out.println("해당 명령을 처리할 수 없습니다!");
        }
        // 응답의 끝을 알리는 빈 문자열을 보낸다.
        out.println();
        out.flush();
        
        if (request.equalsIgnoreCase("quit"))
          break;
        else if (request.equalsIgnoreCase("stop")) {
          stop= true;
          break;
        }
      }
    } catch (Exception e) {
    }
    
    System.out.printf("클라이언트(%s)와의 연결을 끊습니다.\n", address.getHostAddress());
  }
}

```

- `sendResponse()` 메서드를 삭제한다.

> 자기가 만든 코드를 지우기 싫어한다. 아까워서 안 지우려고 한다. 초보 개발자에게 남는 것은 코드가 남는 것이 아니라 코드를 만든 경험이 남는 것이다.



**아이피 주소가 바뀌는 이유**

- 한 달에 한 번씩 아이피 주소가 바뀐다.
- 일정 시간마다 아이피 주소가 바뀔 수 있다: 다이나믹 아이피
- real ip도 접속하는 순간에만 우리 것이지, 꺼버리면 아이피가 다른 사람한테 갈 수 있다. 한편, 서버 아이피는 고정되어 있어야 한다. 그러면 고정 아이피를 받아야 한다. 한달에 일정사용료 내야 한다. 아이피도 real ip이면서 고정 아이피이다. 이제서야 도메인 이름을 부여할 수 있다. 고정 아이피에 대해서 도메인 이름을 부여할 수 있지, 다이나믹 아이피에는 도메인 이름을 부여할 수 없다.



### 7단계: 클라이언트에게 입력값을 요구할 수 있도록 프로토콜을 변경한다.

- 클라이언트 입력 값을 읽을 수 있도록 파라미터에 입력 스트림을 추가한다.
- `execute(PrintWriter)`를 `execute(PrintWriter out, BufferedReader in)`으로 바꾼다.

```java
public interface Command {
  void execute(PrintWriter out, BufferedReader in);
}
```

- 규칙을 바꾸면 규칙에 따라 만든 클래스도 바뀐 규칙을 따르게 만들어야 한다.

```java
  @Override
  public void execute(PrintWriter out, BufferedReader in) {
    out.println("[작업 목록]");
```

- Prompt 클ㄹ래스 변경
  - 파라미터로 받은 출력 스트림으로 프롬프트 제목을 출력하고,

**오버로딩**

- 프로그래밍의 일관성을 위해서 같은 이름을 같게 만든다.
- 클라이언트로 출력할 때는 제목 다음에`!{}!` 문자열을 보내 클라이언트가 사용자로부터 값을 입력 받아 다시 서버에게 보내도록 요청한다.



프롬프트에 새 기능을 추가할 때 키보드로 입력받고 등등

파라미터가 기능은 다르더라도 같은 이름을 부여함으로서 메서드임을 따로따로 암기할 필요 없이 프로그래밍의 일관성을 유지할 수 있게 해준다.

상속받은 메서드가 서브 클래스의 역할에 맞지 않을 때 맞게 다시 재정의

오버로딩: **파라미터가 다르더라도** **같은 일을 하는 메서드에 대해서 같은 이름을 부여함**으로써 호출하는 쪽에서 일관적으로 호출하도록 해서 **프로그래밍의 일관성을 유지**하는 문법

**oop(상속, 다형성, 캡슐화), 디자인패턴, 리팩토링 이 모든 것의 목표는 소스 코드를 보다 간단하게 만드는 것이다.** 소스 코드가 간단하다는 것은 무엇인가? 첫번째, 읽기 쉽다. 2번째 기능 추가/변형/삭제(할 때 기존 코드를 최소로 손대야 한다. 그래서 버그가 줄어들고, 편집 시간은 줄어든다.

최적화는 기계를 사면 된다. 이거하고 그건 상관이 없다. 최적화와 상관 없지만, 이것은 사람이 하는 것이다. 인건비는 많이 나가기 때문에 소스코드를 간단하게 만드는 것이 매우 중요하다.



서버에서 모든 것은 다 서버에서 한다. 이게 C/S로 바꾼 이유다. Application Server에 Thin Client가 요청을 한다. 모든 프로그램을 서버에서 돌리면 사용자 pc 는 성능이 좋을 필요가 없다. 굳이 무거운 피씨가 아니라 Thin pc만 있으면 된다.



커멘드 패턴이든 옵저버 패턴이든 유사하다. 기존 코드를 최소화하면서 기능을 추가한다. 서버 앱은 이런 고급진 기능들이 있다. 

서버에서 어플리케이션을 돌린다고 해서 어플리케이션 서버라고 한다. ㅇ





### 8단계: 디자인 패턴과 C/S 애플리케이션 아키텍처의 유용성을 확인한다.

- 계산기 기능을 수행하는 새 명령ㅇ르 추가해보자.
  - CalculatorCommand 클래스를 추가한다.
- 





접속자 수가 100만명이 있는 날은 별로 안되고 실제로는 1만명만 된다면 서버 하드웨어가 낭비된다..

 은행 시스템은 stateful 방식으로 되어 있다. 그리고 은행서비스는 전용 망을 사용하고 있다.

그런데 네이버처럼 접속하는 클라이언트의 행동이 가변적이라면 stateful방식이 안좋다. 

게임은 stateful이다. 계속 연결되어 있다가 데이터를 보내거나 받을 때 바로바로 해야 한다. 영상도 계속 연결된 채로 유지되어야 한다. 계속 쓰는 것은 아니지만 언제든지 긴급하게 



### 1단계: 서버에 연결할 때 한 번만 요청/응답하도록 변경한다.

서버와 연결하면 quit명령을 보낼 때까지 계속 연결되어 있는 기존의 staticful 통신 방법을 stateless로 변경한다.

단점은 반복적으로 연결해야 하고, 계속 스래드를 생성한다. 그리고 끊으면 스레드가 가비지가 된다. 이 문제는 스레드 풀로 해결한다. 