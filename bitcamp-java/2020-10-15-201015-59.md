---
title: ":tent: 학원 #54일차: Observer 패턴"
categories: bitcamp
tags: [ bitcamp, java ]
---

## 앞으로의 계획



응답을 하면서 자리가 났다. 



가비지가 계속 쌓인다. 가비지 컬렉터가 처리를 하지만 쓰레기가 계속 쌓이는 것은 바람직하지 않다. 일시적으로는 메모리가 계속 차 있는 상태가 되어 있기 때문이다. 현실에도 일정 웨이터를 보유하고 있다가 다 차있을 때 고객이 들어오려고 하면 잠깐만 기다리세요, 라고 말하고 한 웨이터의 자리가 비면 고객을 다시 받는다.

따라서 스레드를 고객이 들어온 만큼 생성하는 것이 아니라, 스레드의 개수만큼 **미리 생성**해놓고, 그 클라이언트가 끝나면 다른 클라이언트 요청을 처리한다.

스테이트리스의 장점

- 보다 많은 클라이언트에 응답할 수 있다.
- 스레드를 계속 유지할 필요가 없다

스테이트리스의 단점

- 스레드가 응답을 완료한 후 가비지가 된다. 요청이 들어올 때마다 가비지가 생긴다.
- 이 단점을 스레드풀을 이용하여 해결할 수 있다.

> com.eomcs.concurrent.ex6

스레드 풀을 만드는 데 사용하는 풀링기법은 Flyweight 디자인 패턴을 응용한 것이다.

## Flyweight 디자인 패턴

이렇게 **객체를 생성한 후 보관해 두었다가 재사용하는 방식**을 **Pooling기법**이라고 한다. 디자인 패턴에서는 **Flyweight 패턴**으로 정리되어 있다. 목적은 쓸데없이 가비지를 생성하지 않는다는 것이다. 한번 객체를 생성한 후 재사용하는 것이 **메모리 낭비를 방지**한다.

```java
public class Brush {}
```

### Pooling 기법 적용 전

```java
public class BrushTest {}
```



### Pooling 기법 적용 후

```java
public class BrushPool {
  Map<String, Brush> brushMap = new HashMap<>();
  public Brush getBrush(String pattern) {
    if (brush = null) {
      System.out.printf("%s 브러시 생성!\n", pattern);
      brush = new Brush(pattern);
      brushMap.put(pattern, brush);
    }
    return brush;
  }
}
```

자기 자신이 스레드에 반납되어야 한다.

다



돌아갈 때 주소를 알아야지 돌아간다. 그래서 this가 필요한 것이다.  작업이 끝났을 때 스레드 풀로 돌아가기 위해서 스레드풀 주소를 파라미터에 담는다. 

- 

MyThread 클래스 안에ㅓㅅ도 MyThreadPool 을 사용하고 있고, MyThreadPool에서도 MyThread를 사용하고 있다. 이게 바로 cross Reference하는 상ㅅ황이다. 이 MyThrad Pool을 컴파일하면 Mythread도 이걸 사용하고 있으니까 또 컴파일한다. 이게 바껴졌으니까 MyThreadPool을 또 컴파일한다. 

요즘 컴파일러는 이런 것을 막고 있다. 그럼에도 불구하고 크로스 레퍼런스 하는 것은 바람직하지 않다.

ThreadPool인터페이스를 구현하도록 했다. 대신 MyThread가 직접적으로 사용하는 것이 아니라 ThreadPool을 사용하는 것이다.

interface를 사용함한다.



MyThreadPool과 MyThread 상호 간에 참조를 피하기 위해 인터페이스를 준비한다.

```java
interface ThreadPool {
  Thread get();
  void add(Thread obj);
}
```



오버라이딩할 때 리턴 타입이 그것의 하위 객체여도 상관없다.  파라미터는 문제가 된다. 그러면 **스레드의 또다른 자식은 못 받을 테니까.** 스레드를 리턴한다 그랬는데 MyThread를 리턴한다면 이것은 규칙에 위반되지 않는 것이다. MyThread도 Thread객체니까. 파라미터는 더 좁아지면 안된다. 더 많은 것을 받을 수 있었는데 쫍아지니까 안되는 것

- `Thread get()`
- `MyThread get()`

```java
@Override
public void add(라면 t) {
  d
}
```

```java
interface ThreadPool {
  Thread get();
  d
}
```

먹을 것보다 더 많은 물질을 파라미터로 하면 안된다. get을 호출하는 입장에서는 리턴값이 뭐든 아무거나 먹을 거면 된다. 

즉, 다시말해 리턴값을 사용하는 것은 호출하는 쪽이다. 그리고 파라미터를 사용하는 쪽은 호출당하는 메서드 안이다. 리턴값을 사용하는 쪽에서는 스레드의 어떤 자식이든 받으면 사용할 수 있다. 파라미터는 

wait()를 호출할 때는 synchronized가 있다. this가 있는데, this 는 내 스레드. 누가 나를 건드릴 때까지는 기다린다. 즉 notRunnable 상태이다. sleep처럼 CPU 를 안 받는 상태이다. notify()가 오면 그때야 바로 작업ㅇ르 시작한다. 

작업이 끝났으면 스레드풀로 돌아간다. 그리고 다시 반복문을 돈다. 그리고 기다리는 상태가 된다. 언제 얘를 건드느냐? 누가 `setCount`를 호출하는 순간 notify, 알림을 준다. 객체를 건드린다. 스레드를 무한으로 계속 멈추지 않고 반복. 무한으로 터치. 무한으로 반복하는 것. run메서드 호출이 끝나면 데드 상태가 되는데, 스레드 풀은 이것을 무한으로 반복함으로써 재활용할 수 있다. 한편, 스레드풀은 무한루프일 수밖에 없다.

데드 상태에 들어가면 버려지는 구조가 아니라 하나 만든 것을 재활용하는 방식으로 한다. Not Runnable 상태로 돌아간다. Threadpool 상태가 된다. notify로 깨워서 동작하게 한다. 깨우기 전에 작업할 값도 넘겨줘야 한다. 

```java

```



## UI 프로토타입

- 고객 요구사항과 개발팀

- 애자일 방법론: 일단 하루동안 게시판 입력 화면을 만들고, 고객도 본다. 그다음 등록하는 기능을 넣는다. 그렇게 고객의 피드백을 그다음 프로젝트에 바로바로 반영하는 것을 말한다.
- 이런 방식으로 서비스를 전개하다보니 개발팀(Development)과 운영팀(Operation)이 갈라질 수 없다. => DevOps. 
- 은행 시스템은 기민하게 개발을 할 필요가 없다. 신중하게 개발을 해야 한다.=> 크리티컬 도메인은 그때그때 기능을 추가하면 안된다. 따라서 이때는 분석-설계-구현-테스트를 길게 가져간다. 함부로 기능을 추가하지 않는다. 이 때는 개발팀과 운영팀이 따로 떨어져있다.
- 그러나 벤처 기업 (우아한 형제, 카카오, 네이버 라인 메신저 등 서비스 업체)는 고객에 대해 기민하게 반응해야 하기 때문에, 운영팀과 개발팀이 분리되면 무거워진다. 이런 서비스는 개발팀과 운영팀이 함쳐져 DevOps가 된다.



## 객제지향 분석설계

### 요구사항 수집

### 요구사항 분석

- Actor(시스템을 사용하는 사람/프로세스)
  - Primary Actor: 시스템을 사용
  - Secondary Actor(Supplementary Actor): 시스템이 사용하는 외부 시스템



Actor를 식별한다. 누가 Actor인지 분석저

