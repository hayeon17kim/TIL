---
title: ":tent: 학원 #54일차: Observer 패턴"
categories: bitcamp
tags: [ bitcamp, java ]
---

## 요구사항 분석

- Use-Case(사용 사례): actor가 시스템을 사용하여 달성하려는 목표
- 이를 알려면 사용자(actor)가 누구인지 알아야 한다.

### Use case 식별 방법

![image](https://user-images.githubusercontent.com/50407047/96390908-b700b700-11f1-11eb-851f-a59ddbe1de13.png)

Use Case는 개발할 기능을 뜻한다. 버튼을 누르는 것도 기능이 맞긴 하지만, Use Case는 사용자의 목적에 집중한다. 즉 버튼을 사용자가 왜 누르는지, 한 단위의 업무 단위에 초점을 맞춘다. 다음은 Use Case 식별 방법이다.

- 1) **(개발할) 시스템을 사용해서 처리하는 "업무"**
  - ex: 전화, 팩스 보내는 것은 업무이지만 시스템을 사용해서  처리하는 업무가 아니기 때문에 use case가 아니다.
- 2) **한 사람**이 **한 번**에 **한 순간**에 수행하는 업무
  - ex: 메일 보내는 일은 한 사람이 한 번에 한 순간에 수행하는 업무로 쪼갤 수 있다.
    - 메일 임시 보관하기
    - 메일 보내기
- 3) **카운트가 가능한 단위로 업무를 쪼갠다**
  - **업무의 시작과 끝이 명확**해야 한다.
  - 게시물 100건 조회, 게시물 40건 수정 등. 즉 게시물 관리는 use case를 너무 크게 뽑은 것이다. 게시물 조회, 변경, 삭제, 추가 각각이 하나의 use case이다. 
  - 게시물 변경 버튼을 누르는 것은 업무가 아니기 때문에 use case가 아니다.

2번과 3번이 Use Case의 적정 크기를 결정한다. Use Case를 너무 두리뭉실하게 뽑으면 기능을 범위를 조정하기 힘들기 때문에 Use Case의 적정 크기를 적절하게 결정하는 것은 중요하다.

### Use Case 적정 크기

- 개발 단위: 분석 -> 설계 -> 구현 -> 테스트

- RUP 개발 프로세스: 2주~6주 동안 개발
- Agile 개발 방법론: 1시간 ~ 1일



### Use Case의 특별한 예

![image](https://user-images.githubusercontent.com/50407047/96391904-52dff200-11f5-11eb-8dbb-73595a80e057.png)

**여러 Use Case의 공통 시나리오**인 경우 **업무가 아닌데도  Use Case로 식별**할 수 있다. 게시글 등록, 게시글 변경, 게시글 삭제는 로그인에 포함된다. 로그인은 업무는 아니지만 다른 U**se Case들의 관리를 쉽게 하기 위해 추출**한다. 결국 이것이 **개발 편의성**을 제공한다.





### Use Case 통합

![image](https://user-images.githubusercontent.com/50407047/96391934-6723ef00-11f5-11eb-9cb9-ad56e33870e8.png)

- 서로 관련된 업무인 경우 **관리의 편의성**을 위해 한 개의 Use Case로 합치기도 한다.
- Use Case는 명사구 형태를 많이 띈다 (XxxHandler, XxxManage, XxxService) 한국어로는 '관리하기' 등 '~하기'라는 말로 한다.

### Use Case Diagram

![image](https://user-images.githubusercontent.com/50407047/96391953-730fb100-11f5-11eb-838c-e2c8e8210a4e.png)

primary actor가 사용자고, secondary actor는 우리 시스템의 의존하는 외부 시스템이다. 화살표 방향을 주의하자!

#### 포함, 확장 관계

![image](https://user-images.githubusercontent.com/50407047/96392812-28436880-11f8-11eb-953b-a948ce7bc68f.png)

> 실무에서는 유연성을 위해 secondary actor(카카오 주소검색) 까진 명시하지 않는다. 예를 들어 주소검색 시스템은 카카오가 아니라 네이버 주소검색도 쓸 수 있다. 소프트웨어 설계는 건축물 설계와 다르다. 건축물 설계는 철근 종류 및 크기와 와 같은 규격을 상세하게 적어야 한다. 그러나 소프트웨어 설계는 완벽해야 하는 것이 아니라 큰 그림을 주어야 한다. 개발자들이 secondary actor 선택 등은 개발자들이 선택할 수 있어야 한다.

> 주소검색은 업무는 아니지만 회원가입할 때도 하고 회원 정보 검색할 때도 한다. 즉 여러 유스 케이스에서 공통적으로 사용하는 주소검색을 유스케이스로 뽑을 수 있다. 

유스케이스와 유스케이스끼리 포함 확장 관계가 있다. 주소검색을 하지 않고 회원가입을 끝낼 방법이 없다면, 즉 필수적이라면 포함 관계(include)에 있다고 말한다. 포함 관계에 있다면 실행 흐름이 단절된다. 반면 주소 검색을 하는 것이 선택적이라면 확장(extend)하는 use case라고 한다. 여기서 주소검색은  회원가입의 extension point가 된다. 

![image](https://user-images.githubusercontent.com/50407047/96392833-3b563880-11f8-11eb-9e1d-f79919bc3abe.png)

보통 실무에서 로그인까지는 적지 않는다. 

여기서 관리자는 회원을 상속받기 때문에 회원이 하는 기능은 다 할 수 있다. 



- RUP 프로세스: 

![image](https://user-images.githubusercontent.com/50407047/96398402-bc1c3100-1206-11eb-950d-2d7613222e91.png)

시스템 아키텍처는 우선순위 결정, 구현 모델 구축, 배포 설명서, 레퍼런스 아키텍처, 가이드라인 설계, 구현 모델 작성, 통신 프로토콜 작성, 인터페이스, 이벤트, 시그널 관련, 프로그램 가이드라인(변수명, 메서드명, 클래스명 등) 제공 등의 일을 한다.

개발자는 **UI 프로토타입**과 **use case 명세서** 두 문서가 있어야 개발을 할 수 있다. 클라이언트가 있는 SI 기업의 경우 요구사항 명세서가 꼭 있어야 한다.

내가 기획한 서비스 **Wandok**의 **Use Case Diagram**을 그려보았다.

![Wandok_ use case (1)](https://user-images.githubusercontent.com/50407047/96411656-c7318a00-1223-11eb-9b70-dc54e34d1c3f.jpg)

# Executors 태스크 프레임워크

> java.util.concurrent

### 1. 스레드풀 만들고 사용하기

1. 스레드풀에 요청할 **작업**을 Runnable 구현체로 작성한다.
2. `execute()`를 호출하면서 구현체를 파라미터로 넘겨준다.
3. 스레드풀은 스레드가 없다면 새로 생성하고, 기존에 놀고 있는 스레드가 있다면 그 스레드를 사용한다.
4. 스레드의 `start()`를 호출함으로써 파라미터로 넘겨준 Runnable 객체의 `run()`를 실행한다.

![image](https://user-images.githubusercontent.com/50407047/96414526-34471e80-1228-11eb-93e4-9354993bee87.png)

```java
public class Exam0110 {
  public static void main(String[] args) {
    // 스레드풀을 생성: 최대 3개의 스레드 생성
    ExecutorService executorService = Executors.newFixedThreadPool(3);

    // 스레드풀에 작업 수행 요청
    // - 작업은 Runnable 구현체로 작성하여 넘겨준다.
    // - 스레드풀은 스레드를 생성하여 작업을 수행시킨다.
    executorService.execute(() -> System.out.printf("%s - Hello!\n",
        Thread.currentThread().getName()));

    System.out.println("main() 종료!");
    // JVM은 main 스레드가 종료하더라도 나머지 스레드가 종료할 때까지 기다린다.
    // 스레드풀에서 생성한 스레드가 요청한 작업을 마치더라도
    // 다음 작업을 수행하기 위해 계속 실행된 채로 대기하고 있기 때문에
    // JVM은 종료하지 않는다.
  }
}

```

```
main() 종료!
pool-1-thread-1 스레드 실행!
```

JVM은 main 스레드가 종료하더라도 나머지 스레드가 종료할 때까지 기다린다. 스레드풀에서 생**성한 스레드가 요청한 작업을 마치더라도** **다음 작업을 수행하기 위해 계속 실행된 채**로 대기하고 있다. 스레드드는 내부적으로 반복문을 계속 돌린다.  반복할 때 notify()로 스레드를 깨우기 전까지는 wait()하게 한다. 따라서 JVM은 종료하지 않는다. 

스레드풀의 장점은 이것이다. 스레드 풀 없이 스레드를 직접 생성하고 일을 시키면 (`start()` -> `run()`)  일이 끝난 후  dead 상태로, 되살릴 수 없게 된다. 일을 시킬 때마다 스레드가 죽고 죽은 스레드는 가비지가 되는 문제를 스레드풀로 해결할 수 있다.

![image](https://user-images.githubusercontent.com/50407047/96414584-46c15800-1228-11eb-884f-e0b639823dff.png)

> 익명 클래스로 인터페이스를 구현할 때 인터페이스도 익명 클래스도 생성자가 없기 ㄸ매누에 object를 상속받게 된다. 즉 object의 생성자를 호출한다.



### 스레드풀 종료하기

스레드풀에 있는 **모든 스레드들이 요청한 작업을 끝내면** 종료하게 한다(스레드가 작업을 끝낼 때까지는 기다린다.) `executorService.shutdown()`은 **모든 스레드가 종료될 때가지 기다리지 않고 바로 리턴한다.** `shutdown()` 호출 이후에는 새 작업 요청은 받지 않는다. 즉 `execute()`를 호출하면 예외가 발생한다.

```java
public class Exam0120 {
  public static void main(String[] args) {
    ExecutorService executorService = Executors.newFixedThreadPool(3);
    executorService.execute(() -> System.out.printf("%s 스레드 실행!", Thread.currentThread().getName()));
    
    executorService.shutdown();
    System.out.println("main() 종료!");
  }
}

```



### 고정크기 스레드풀

고정 크기의 스레드를 만든다. 일장 스레드풀의 크기(3개)만큼 작업 수행을 요청한다. 작업은 큐에 등록된 순서대로 보관된다. 스레드풀은 큐에서 작업을 꺼내 일을 시킨다.



실행은 누구부터 먼저할 지 모른다!!!!!!스레드가 스타트하더라도 그 cpu사용권을 누구한테 먼저 줄 지 모른다. 



고정크기 스레드풀은 그 다음 실행되어야 하는 애들은 작업 큐에 보관되어 있다가 스레드가 할 일이 없어지면 즉시 그 다음 작업을 한다.

```java
public class Exam0210 {
  static class MyRunnable implements Runnable {
    int millisec;
    
    public MyRunnable(int millisec) {
      this.millisec = millisec;
    }
    
    public void run() {
      try {
        System.out.printf("%s 스레드 실행 중...\n", Thread.currentThread().getName());
        Thread.sleep(millisec);
      } catch (Exception e) {
        System.out.printf("%s 스레드 실행 중 오류 발생!\n", Thread.currentThread().getName());
      }
    }
    
    public static void main(String[] args) {
      ExecutorService executorService = Executors.newFixedThreadPool(3);
      
      executorService.execute(new MyRunnable(6000));
      executorService.execute(new MyRunnable(3000));
      executorService.execute(new MyRunnable(9000));
      
      executorService.execute(new MyRunnable(2000));
      executorService.execute(new MyRunnable(4000));
      
      System.out.println("main() 종료!");
    }
  }
}
```





**실행결과**

```console
pool-1-thread-1 스레드 실행 중...
main() 종료!
pool-1-thread-3 스레드 실행 중...
pool-1-thread-2 스레드 실행 중...
pool-1-thread-2 스레드 종료!
pool-1-thread-2 스레드 실행 중...
pool-1-thread-2 스레드 종료!
pool-1-thread-2 스레드 실행 중...
pool-1-thread-1 스레드 종료!
pool-1-thread-3 스레드 종료!
pool-1-thread-2 스레드 종료!
```



### 가변크기 스레드풀

> 보관소에 저장되어 있는 스레드가 없으면 만들고, 있으면 그 스레드를 사용한다.

스레드의 수를 고정하지 않고 필요할 때마다 스레드를 생성하는 스레드풀이다. 작업을 끝낸 스레드는 다시 사용할 수 있도록 pool에 보관한다. 놀고 있는 스레드가 없으면 새 스레드를 생성한다. 개수보다 더 많은 작업을 시키면 작업을 끝내고 처리할 때까지 기다린다. 그러나 가변크기 스레드풀은 계속 스레드가 늘어난다. 

```java
public class Exam0220 {
  static class MyRunnable implements Runnable {
    int millisec;
    
    public MyRunnable implements Runnable {
      this.millisec = millisec;
    }
    
    public void run() {
      try {
        System.out.printf("%s 스레드 실행 중...\n", Thread.currentThread().getName());
        Thread.sleep(millisec);
        System.out.printf("%s 스레드 종료!\n", Thread.currentThread().getName());
      } catch (Exception e) {
        System.out.printf("%s 스레드 실행 중 오류 발생!\n", Thread.currentThread().getName());
      }
    }
  }
  
  public static void main(String[] args) throws Exception {
    ExecutorService executorService = Executors.newCachedThreadPool();
    
    executorService.execute(new MyRunnable(6000));
    executorService.execute(new MyRunnable(3000));
    executorService.execute(new MyRunnable())
  }
}
```

이 방식은 한 번에 백만명이 들어온다면 스레드가 백만개가 생성된다는 단점이 있다. 이 단점을 상쇄하기 위해서는 newCachedThreadPool에 파라미터로 값을 설정해서 할 최대 개수를 조정할 수 있다.

**실행결과**

```console
pool-1-thread-1 스레드 실행 중...
pool-1-thread-4 스레드 실행 중...
pool-1-thread-2 스레드 실행 중...
pool-1-thread-3 스레드 실행 중...
pool-1-thread-4 스레드 종료!
main() 종료!
pool-1-thread-4 스레드 실행 중...
pool-1-thread-2 스레드 종료!
pool-1-thread-1 스레드 종료!
pool-1-thread-4 스레드 종료!
pool-1-thread-3 스레드 종료!
```

### SingleThreadExecutor: 한 개의 스레드를 갖는 스레드풀

순차적으로 처리한다. 싱글 스레드로 작업을 수행해야 하는 경우

- **예매 서버**를 구축하는 경우: 한 스레드가 순서대로 처리해야 한다.

```java
  public static void main(String[] args) throws Exception {

    // 한 개의 스레드만 갖는 스레드풀이다.
    ExecutorService executorService = Executors.newSingleThreadExecutor();

    // 스레드가 한 개이기 때문에 순차적으로 실행한다.
    executorService.execute(new MyRunnable(6000));
    executorService.execute(new MyRunnable(3000));
    executorService.execute(new MyRunnable(9000));
    executorService.execute(new MyRunnable(2000));
    executorService.execute(new MyRunnable(4000));

    System.out.println("main() 종료!");
  }
```

**실행 결과**

```console
main() 종료!
pool-1-thread-1 스레드 실행 중...
pool-1-thread-1 스레드 종료!
pool-1-thread-1 스레드 실행 중...
pool-1-thread-1 스레드 종료!
pool-1-thread-1 스레드 실행 중...
pool-1-thread-1 스레드 종료!
pool-1-thread-1 스레드 실행 중...
pool-1-thread-1 스레드 종료!
pool-1-thread-1 스레드 실행 중...
pool-1-thread-1 스레드 종료!
```

### 작업 실행: execute()

스레드풀에 수행할 작업을 등록한다. 스레드풀은 작업큐에 작업을 호출한 순서대로 보관한다. 그리고 놀고 있는 스레드가 있다면, 작업큐에서 작업을 꺼내 수행시킨다. 놀고 있는 스레드가 없다면, 새로 스레드를 생성한다. 스레드가 최대 개수라면 작업을 끝낼 때까지 기다린다. 수행한 작업의 종료 여부를 확인할 수 없다.

```java
public static void main(String[] args) {
  ExecutorService executorService = Executor.newFixedThreadPool(3);
  executorService.execute(new MyRunnable(6000));
  System.out.pirnltn("main() 종료!");
}
```

### 작업 실행: submit()

```java
public static void main(String[] args) throws Exception {
  ExecutorService executorService = Executors.newFixedThreadPool(3);
  Future<?> future1 = executorService.submit(new MyRunnable(4000));
  Future<?> future2 = executorService.submit(new MyRunnable(2000));
  
  future2.get();
  System.out.pirnltn("두 번째 작업이 끝났음");
  future1.
  
}
```

`Future.get()`을 호출하면 해당 작업이 끝날 때까지 리턴하지 않는다. 해당 작업이 끝날 때까지 기다리다가 그 다음에 다른 작업을 하고 싶다면 이걸 사용한다. 다만 `execute()`가 아니라 `submit()`을 사용한다. `submit()`는 같은 일을 하지만, Future 객체를 리턴한다는 것만 다르다. Future를 쓸 일이 없으면 execute를 쓰고 특정 작업이 끝날 때까지 기다리고 싶을 때, 즉 Future 객체를 사용하고 싶을 때만 submit을 사용한다. `get()` 작업이 끝날 때까지 블락킹이 걸려 있다(penidng 상태) 리턴하지 않고 기다린다. 두번째에서 즉시 null을 리턴한다.



### 스레드풀 종료: shutdown()

더이상 작업 요청을 받지 않고 이전에 요청한 작업들이 완료되면 스레드를 **종료하도록 예약**한다.

```java
  public static void main(String[] args) throws Exception {
    ExecutorService executorService = Executors.newFixedThreadPool(3);
    executorService.execute(new MyRunnable(6000));
    executorService.execute(new MyRunnable(2000));
    executorService.execute(new MyRunnable(4000));
    executorService.execute(new MyRunnable(4000));
    executorService.execute(new MyRunnable(4000));
    executorService.execute(new MyRunnable(4000));
    executorService.shutdown();
    
    executorService.execute(new MyRunnable(4000));
    System.out.println("main() 종료!");
  }
```

**실행 결과**

```console
Exception in thread "main" java.util.concurrent.RejectedExecutionException: Task com.eomcs.concurrent.ex7.Exam0410$MyRunnable@5acf9800 rejected from java.util.concurrent.ThreadPoolExecutor@4617c264[Shutting down, pool size = 3, active threads = 3, queued tasks = 3, completed tasks = 0]
	at java.base/java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2055)
	at java.base/java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:825)
	at java.base/java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1355)
	at com.eomcs.concurrent.ex7.Exam0410.main(Exam0410.java:37)
pool-1-thread-2 스레드 실행 중...
pool-1-thread-1 스레드 실행 중...
pool-1-thread-3 스레드 실행 중...
pool-1-thread-2 스레드 종료!
pool-1-thread-2 스레드 실행 중...
pool-1-thread-3 스레드 종료!
pool-1-thread-3 스레드 실행 중...
pool-1-thread-1 스레드 종료!
pool-1-thread-1 스레드 실행 중...
pool-1-thread-2 스레드 종료!
pool-1-thread-3 스레드 종료!
pool-1-thread-1 스레드 종료!
```



### 스레드풀 종료: shutdownNow()

shutdown은 실행 중인 작업이 모두 끝나고 대기 중인인 작업까지 모두 끝날 때까지 기다린다. 그러나 `shutdownNow()`는 실행 중인 작업도 강제로 종료하고 대기 중인 작업은 리턴한다.

```java
public static void main(String[] args) throws Exception {
  ExecutorService executorService = Executors.newFixedThreadPool(3);
  // 이전에는 스레드에게 주면서 start()를 했다면,
  // 스레드 풀이 알아서 스레드를 생성해서(혹은 있는 스레드를 사용해서) start() 시킬 것이다.
  executorService.execute(new MyRunnable(6000));
  executorService.execute(new MyRunnable(2000));
  executorService.execute(new MyRunnable(4000));
  executorService.execute(new MyRunnable(5000));
  executorService.execute(new MyRunnable(6000));
  executorService.execute(new MyRunnable(7000));

  List<Runnable> tasks = executorService.shutdownNow();
  for (Runnable task : tasks) {
    System.out.println(((MyRunable)task).millisec);
  }
}
```

스레드가 잠자고 있는 데  interrupt가 되었다. 따라서 run()의 try문 안에서 잠자고 있다가 예외가 발생하기 때문에 catch문이 실행된다.

> 스레드 안에 인터럽트 메서드가 있다. 강제로 스레드를 강제로 종료하는 메서드. 

```console
Exception in thread "main" java.util.concurrent.RejectedExecutionException: Task com.eomcs.concurrent.ex7.Exam0420$MyRunnable@5acf9800 rejected from java.util.concurrent.ThreadPoolExecutor@4617c264[Shutting down, pool size = 3, active threads = 3, queued tasks = 0, completed tasks = 0]
	at java.base/java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2055)
	at java.base/java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:825)
	at java.base/java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1355)
	at com.eomcs.concurrent.ex7.Exam0420.main(Exam0420.java:37)
pool-1-thread-3 스레드 실행 중...
pool-1-thread-1 스레드 실행 중...
pool-1-thread-2 스레드 실행 중...
pool-1-thread-1 스레드 실행 중 오류 발생!
pool-1-thread-3 스레드 실행 중 오류 발생!
pool-1-thread-2 스레드 실행 중 오류 발생!
```



### 스레드풀 종료 대기: awaitTermination()

스레드풀의 **모든 스레드가 종료되면 즉시 true를 리턴한다.** 만약 지정된 시간(10초)이 경과될 때까지 종료되지 않았다면 **더이상 기다리지 않고 false를 리턴**한다. 

```java
public class Exam0520 {
  static class MyRunnable implements Runnable {
    int millisec;
    
    public MyRunnable(int millisec) {
      this.millisec = millisec;
    }
    
    @Override
    public void run() {
      try {
        System.out.printf("%s 스레드 실행 중..\n", Thread.currentThread().getName());
        Thread.sleep(millisec);
        System.out.printf("%s 스레드 종료!\n", Thread.currentThread().getName());
      } catch (Exception e) {
        System.out.printf("%s 스레드 실행 중 오류 발생!\n", Thread.currentThread().getName());
      }
    }
  }
  public static void main(String[] args) throws Exception {
    ExecutorService executorService = Executors.newFixedThreadPool(3);
    
    executorService.execute(new MyRunnable(6000));
    executorService.execute(new MyRunnable(2000));
    executorService.execute(new MyRunnable(4000));
    executorService.execute(new MyRunnable(20000));
    
    executorService.shutdown();
    
    if (!executorService.awaitTermination(10, Timeunit.SECONDS)) {
      System.out.println("아직 종료 안된 작업이 있다.");
    }
  }
}
```

스레드가 종료될 때까지 기다리게 하고 싶으면 이걸 쓰면 된다. 

### 두가지 결합

운영체제도 똑같다. 종료햇을 때 아직 작업중인 어쩌구가 있습니다

- 우리가 만든 스레드풀은 허접 스레드풀
- 자바에 제공하는 거니까 기능이 막강하다. 작업큐도 있고. 

```

```

main()도 스레드를 뺏기지 않으면 main()은 계속 간다. 운영체제가 cpu를 분배한는 것이니까.