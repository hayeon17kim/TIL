

## 계산기 C/S

### Stateless

```java

public class CalcServer {
  public static void main(String[] args) throws Exception {
    System.out.println("서버 실행 중...");

    ServerSocket ss = new ServerSocket(8888);

    while(true) {
      Socket socket = ss.accept();
      try {
        processRequest(socket);
      } catch (Exception e) {
        System.out.println("클라이언트 요청 처리 중 오류 발생!");
        System.out.println("다음 클라이언트의 요청을 처리합니다.");
      }
    }
  }


  static void processRequest(Socket socket) throws Exception {
    try (Socket socket2 = socket;
        DataInputStream in = new DataInputStream(socket.getInputStream());
        PrintStream out = new PrintStream(socket.getOutputStream())) {

      int result = 0;
      loop: while (true) {
        String op = in.readUTF();
        int a = in.readInt();

        switch (op) {
          case "+":
            result += a;
            break;
          case "-":
            result -= a;
            break;
          case "*":
            result *= a;
            break;
          case "/":
            result /= a;
            break;
          case "quit":
            break loop;
        }
        out.printf("계산결과 = %d\n", result);
      }
    out.println("Goodbye!");
    } catch (Exception e) {

    }
  }
}
```

result 변수는 `processRequest()`의 로컬 변수이다. 따라서 연결이 끊어지면 로컬 변수는 사라진다. 클라이언트의 상태 정보를 서버가 알고 있기 좋다.

- `getRemoteSocketAddress`: 
  - 왜
  - `remoteAddr.getAddress()`
  - 소켓 클래스의 메서드를 너무 많이 늘리면 유지보수하기 어려우니까.. 그것보다 주소를 다루는 별도의 클래스인 InetSocketAddress를 사용한다.
- 귀찮지만 socket을 통해서 다이렉트로 주소와 포트번호를 뽑아내는 것이 아니라 socket으로부터 InetSocketAddress객체를 받아서 여기로부터 주소와 포트번호를 알아낸다.
- 둘 사이에 대화를 하기 위해서는 반드시 클라이언트 서버 각자 포트번호가 있어야 한다. 



- 스레드가 생성되면 스레드가 사용할 stack메모리도 같이 생긴다. 그리고 run()이 맨 아래에 깔린다. Run()이 processRequest를 호출하면 여기 있는 result변수는 ㅈ,ㅣ역변수.
- 



> com.eomcs.net.ex04.stateful3

```java
public class CalcServer {

  // 클라이언트와 통신하는 부분을 별도의 분리하여
  // 독립적으로 실행하게 한다.
  static class RequestHandler extends Thread {

    Socket socket;

    public RequestHandler(Socket socket) {
      this.socket = socket;
    }

    @Override
    public void run() {
      // JVM과 분리하여 별도로 실행할 코드를 이 메서드에 둔다.
      try {
        processRequest(socket);
      } catch (Exception e) {
        System.out.println("클라이언트 요청 처리 중 오류 발생!");
      } finally {
        System.out.println("클라이언트 연결 종료!");
      }
    }
  }

  public static void main(String[] args) throws Exception {
    System.out.println("서버 실행 중...");

    ServerSocket ss = new ServerSocket(8888);

    while (true) {
      System.out.println("클라이언트의 연결을 기다림!");
      Socket socket = ss.accept();
      InetSocketAddress remoteAddr = (InetSocketAddress) socket.getRemoteSocketAddress();
      System.out.printf("클라이언트(%s:%d)가 연결되었음!\n", //
          remoteAddr.getAddress(), remoteAddr.getPort());

      // 연결된 클라이언트가 연결을 끊기 전까지는
      // 대기하고 있는 다른 클라이언트의 요청을 처리할 수 없다.
      // 이것이 스레드를 사용하기 전의 문제점이다.
      // 해결책?
      // 클라이언트와 대화하는 부분을 스레드로 분리하여 실행하라!
      RequestHandler requestHandler = new RequestHandler(socket);
      requestHandler.start();
      // 스레드를 실행하려면 start() 를 호출하라.
      // start()에 내부에서 run()을 호출할 것이다.
      // start() 호출한 후에 즉시 리턴한다.
      System.out.printf("%s 클라이언트와의 대화를 별도의 스레드에서 담당합니다!\n", //
          remoteAddr.getAddress());
    }
    // ss.close();
  }

  static void processRequest(Socket socket) throws Exception {
    try (Socket socket2 = socket;
        DataInputStream in = new DataInputStream(socket.getInputStream());
        PrintStream out = new PrintStream(socket.getOutputStream());) {

      // 작업 결과를 유지할 변수
      int result = 0;

      loop: while (true) {
        String op = in.readUTF();
        int a = in.readInt();

        switch (op) {
          case "+":
            result += a;
            break;
          case "-":
            result -= a;
            break;
          case "*":
            result *= a;
            break;
          case "/":
            result /= a;
            break;
          case "quit":
            break loop;
        }

        out.printf("계산 결과: %d\n", result);
      }
      out.println("quit");
    }
  }
}
```

어느 스레드가 이 메서드를 호출했는지 그게 중요한 것이다. processRequest()의 로컬 변수는 해당 스레드의 STACK메모리에 만들어진다. 따라서 T1 스레드의 RESULT변수 따로  T2스레드의 result변수 따로 

각각 스레드의 스택 메모리는 각 스레드가 관리한다.

<mark>스택 메모리는 Thread가 관리한다!!!!!!!!!!!!</mark>

### stateless

> com.eomcs.net.ex04.stateless

클라이언트와 연결되는 시간이 매우 짧다. 요청을 읽고 결과를 출력하고 바로 연결을 끊어버린다. 끊어버리는 순간 다른 클라이언트와 연결한다.

```java
public class CalcServer {

  // 각 클라이언트의 작업 결과를 보관할 맵 객체
  // => Map<clientID, result>
  static Map<Long, Integer> resultMap = new HashMap<>();

  public static void main(String[] args) throws Exception {
    System.out.println("서버 실행 중...");

    ServerSocket ss = new ServerSocket(8888);

    while (true) {
      Socket socket = ss.accept();
      System.out.println("클라이언트 요청 처리!");
      try {
        processRequest(socket);
      } catch (Exception e) {
        System.out.println("클라이언트 요청 처리 중 오류 발생!");
        System.out.println("다음 클라이언트의 요청을 처리합니다.");
      }
    }
    // ss.close();
  }

  static void processRequest(Socket socket) throws Exception {
    try (Socket socket2 = socket;
        DataInputStream in = new DataInputStream(socket.getInputStream());
        DataOutputStream out = new DataOutputStream(socket.getOutputStream());) {

      // 클라이언트를 구분하기 위한 아이디
      // => 0: 아직 클라이언트 아이디가 없다는 의미
      // => x: 서버가 클라이언트에게 아이디를 부여했다는 의미
      long clientId = in.readLong();

      // 연산자와 값을 입력 받는다.
      String op = in.readUTF();
      int value = in.readInt();

      // 클라이언트는 위한 기존 값 꺼내기
      Integer obj = resultMap.get(clientId);
      int result = 0;

      if (obj != null) {
        System.out.printf("%d 기존 고객 요청 처리!\n", clientId);
        result = obj; // auto-unboxing
      } else {
        // 해당 클라이언트가 방문한적이 없다면, 새 클라이언트 아이디를 발급한다.
        clientId = System.currentTimeMillis();
        System.out.printf("%d 신규 고객 요청 처리!\n", clientId);
      }

      switch (op) {
        case "+":
          result += value;
          break;
        case "-":
          result -= value;
          break;
        case "*":
          result *= value;
          break;
        case "/":
          result /= value;
          break;
      }
      
      // 계산 결과를 다시 resultMap에 보관한다.
      resultMap.put(clientId, result);
      
      // 클라이언트로 응답할 때 항상 클라이언트 아이디와 결과를 출력한다.
      // => 클라이언트 아이디 출력
      out.writeLong(clientId);

      // => 계산 결과 출력
      out.writeInt(result);

      out.flush();
    }
  }
}

```

**CalcClient**

```java
public class CalcClient {
  public static void main(String[] args) throws Exception {
    Scanner keyScan = new Scanner(System.in);

    // 서버에서 이 클라이언트를 구분할 때 사용하는 번호이다.
    // => 0 번으로 서버에 요청하면, 서버가 신규 번호를 발급해 줄 것이다.
    long clientId = 0;

    while (true) {
      System.out.print("연산자? ");
      String op = keyScan.nextLine();

      System.out.print("값? ");
      int value = Integer.parseInt(keyScan.nextLine());

      try (Socket socket = new Socket("localhost", 8888);
          DataOutputStream out = new DataOutputStream(socket.getOutputStream());
          DataInputStream in = new DataInputStream(socket.getInputStream())) {

        // => 서버에 클라이언트 아이디를 보낸다.
        out.writeLong(clientId);

        // => 서버에 연산자와 값을 보낸다.
        out.writeUTF(op);
        out.writeInt(value);
        out.flush();

        // => 서버에서 보낸 클라이언트 아이디를 읽는다.
        clientId = in.readLong();

        // => 서버에서 보낸 결과를 읽는다.
        int result = in.readInt();
        System.out.printf("계산 결과: %d\n", result);

      } catch (Exception e) {
        System.out.println("서버와 통신 중 오류 발생!");
      }

      System.out.print("계속하시겠습니까?(Y/n)");
      if (keyScan.nextLine().equalsIgnoreCase("n")) {
        break;
      }
    }

    keyScan.close();
  }
}
```

- 쿠키: 서버가 웹 브라우저에게 보낸 데이터
- 요청헤더의 쿠키: 클라이언트가 서버에게 보낸 것
  - 네이버 서버가 브라우저에게 클라이언트 아이디를 보내주고 그때부터 웹 브라우저는 요청할 때마다 서버에서 보내준 아이디를 서버에 보내준다.
  - PM_CK_loc=25f992d6ab0d2c5bf659abca33267b5fa60529a71e18083bb8a9a3559a71e3b1; nid_inf=945036364;
  - 새로운 창을 띄워도 계속 로그인한 상태로 있다.
  - 네이버는 내가 누군지 모른다. 네이버 서버로부터 내가 누구인지



- 클라이언트가 네이버 서버에 붙으면 요청 하고, 이때 요청에 clientId(쿠키의 세션 아이디)가 없다면 네이버는 클라이언트에게 아이디를 발급해준다. 이걸 세션 아이디라고 한다. 클라이언트(브라우저)는 요청할 때마다 매번 그 아이디를 제출한다.

- 서버는 쿠키를 주는데, 이 쿠키 중에서 특히 서버가 발급해주는 clientId를

- 타임아웃은 서버와 클라이언트 둘다 체크한다. 유효 시간이 지나면 마지막으로 응답한 이후에 10분동안 클라이언트가 요청을 안하면 자동 로그아웃을 처리한다. 쿠키 데이터에도 타임아웃이 설정된다. 
- stateless통신에서 서버가 클라이언트가 구분해주는 방법은 서버가 아이디를 발급해주고 클라이언트는 서버가 발급해준 아이디를 계속해서 리턴해주는 방법을 사용한다. HTTP프로토콜은 stateless방식이기 때문에 지금 한 식이다



# sql

- 색인표(index): 기준 항목에 대해 정렬 데이터를 만든다.
- 단점: 하드디스크를 차지한다.
- 장점: **검색 속도가 빠르다.**
- 데이터를 추가, 변경, 삭제할 때마다 색인표를 갱신해야 하기 때문에 추가, 변경, 삭제 시 실행속도가 빠르다.
- 특정 컬럼에 대해서 데이터를 찾을 때 미리 색인표라는 테이블을 만들어 놓고 알파벳 순으로 바로 찾을 수 있다.
- 단점: 색인표를 만들면 그 데이터만 따로 추려서 알파벳순으로 정렬해서 관리해야 하기 때문에 하드디스크를 차지한다.
- 징점: 그러나 하드디스크의 용량을 차지하더라도 검색 속도가 훨씬 빠르다.



##### index
- 검색 조건으로 사용되는 컬럼은 정렬되어야만 데이터를 빨리 찾을 수 있다.
- 특정 컬럼의 값을 A-Z 또는 Z-A로 정렬시키는 문법이 인덱스이다.
- DBMS는 해당 컬럼의 값으로 정렬한 데이터 정보를 별도로 생성한다.
- 보통 책 맨 뒤에 붙어있는 색인표와 같다.  
- 인덱스로 지정된 컬럼의 값이 추가/변경/삭제 될 때 인덱스 정보도 갱신한다.
- 따라서 입력/변경/삭제가 자주 발생하는 테이블에 대해 인덱스 컬럼을 지정하면,
  입력/변경/삭제 시 인덱스 정보를 갱신해야 하기 때문에 입력/변경/삭제 속도가 느려지는 문제가 있다.
- 대신 조회 속도는 빠르다.

```sql
create table test1(
  no int primary key,
  name varchar(20),
  age int,
  kor int,
  eng int,
  math int,
  constraint test1_uk unique (name, age),
  fulltext index test1_name_idx (name)
);  
  // 풀 텍스트로 사용할 때 이름 기준으로 사용할 인덱스를 만든다.


insert into test1(no,name,age,kor,eng,math) values(1,'aaa',20,80,80,80);
insert into test1(no,name,age,kor,eng,math) values(2,'bbb',21,90,80,80);
insert into test1(no,name,age,kor,eng,math) values(3,'ccc',20,80,80,80);
insert into test1(no,name,age,kor,eng,math) values(4,'ddd',22,90,80,80);
insert into test1(no,name,age,kor,eng,math) values(5,'eee',20,80,80,80); 
```
- name 컬럼은 인덱스 컬럼으로 지정되었기 때문에 
  DBMS는 데이터가 추가되거나 삭제되거나 name 컬럼 값이 변경될 때마다
  색인표를 갱신한다.
- 단점, 이런 이유로 이름으로 검색할 때 찾기 속도는 빠르지만,
  입력,변경,삭제 속도는 느리게 된다.
  
#### 인덱스 컬럼의 활용
검색할 때 사용한다.
```sql
select * from test1 where name = 'bbb';
```

### 테이블 변경 
기존에 있는 테이블을 변경할 수 있다.

- 테이블 생성
```sql
create table test1 (
  name varchar(3),
  kor int,
  eng int,
  math int,
  sum int,
  aver int
);

```

- 테이블에 컬럼 추가
  - alter: update와 같은 뜻. 기존 테이블을 변경할 때 사용
  - 항목이 앞에 있든 뒤에 있든 아무 상관이 없다. 필드를 앞으로 옮길 방법은 없고, 그러기 위해서는 지우고 다시 해야 한다.
```sqlite
alter table test1
  add column no int;

alter table test1
  add column age int;  
  
alter table test1
  add column no2 int,
  add column age2 int;   
```

- PK 컬럼 지정, UNIQUE 컬럼 지정, INDEX 컬럼 지정
  - 이름은 생략할 수 있다. 그럴 경우 DBMS가 알아서 이름을 부여한다.
```sql
alter table test1
  add constraint test1_pk primary key (no),
  add constraint test1_uk unique (name, age),
  add fulltext index test1_name_idx (name);
```

- 컬럼에 옵션 추가
```sql
alter table test1
  modify column name varchar(20) not null,
  modify column age int not null,
  modify column kor int not null,
  modify column eng int not null,
  modify column math int not null,
  modify column sum int not null,
  modify column aver float not null;
```

- 입력 테스트
  - insert할 때는 나열하는 컬럼 이름의 순서는 상관 없다.
```sql
insert into test1(no,name,age,kor,eng,math,sum,aver)
  values(1,'aaa',20,100,100,100,300,100);
  
insert into test1(no,name,age,kor,eng,math,sum,aver)
  values(2,'bbb',21,100,100,100,300,100);

/* 다음은 name과 age의 값이 중복되기 때문에 입력 거절된다.*/  
insert into test1(no,name,age,kor,eng,math,sum,aver)
  values(3,'bbb',21,100,100,100,300,100);  
/* ERROR 1062 (23000): Duplicate entry 'bbb-21' for key 'test1_uk'*/
```



### 컬럼 값 자동 증가

- 숫자 타입의 PK 컬럼인 경우 값을 1씩 자동 증가시킬 수 있다.
- 즉 데이터를 입력할 때 해당 컬럼의 값을 넣지 않아도 자동으로 증가된다.
- 단 삭제를 통해 중간에 비어있는 번호는 다시 채우지 않는다.
  즉 증가된 번호는 계속 앞으로 증가할 뿐이다.

- 테이블 생성 
```sql
create table test1(
  no int not null,
  name varchar(20) not null
);
```

- 특정 컬럼의 값을 자동으로 증가하게 선언한다.
- 단 반드시 key(primary key 나 unique)여야 한다.
  - auto_increment는 mysql에서만 가능하다.  오라클은 시퀀스라는 글로벌 변수가 이{ㅆ다.
```sql
alter table test1
  modify column no int not null auto_increment; /* 아직 no가 pk가 아니기 때문에 오류*/
/*ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key
*/

  
alter table test1
  add constraint primary key (no); /* 일단 no를 pk로 지정한다.*/

alter table test1
  add constraint unique (no); /* no를 unique로 지정해도 한다.*/
  
alter table test1
  modify column no int not null auto_increment; /* 그런 후 auto_increment를 지정한다.*/
```

- 입력 테스트
  - auto-increment이기 때문에 생략하면 가장 큰 번호 다음 번호가 자동으로 부여된다.
- 값 삭제
  - `delete from test1;` 이렇게 하면 테이블이 한번에 다 삭제된다.
```sql
/* auto-increment 컬럼의 값을 직접 지정할 수 있다.*/
insert into test1(no, name) values(1, 'xxx');

/* auto-increment 컬럼의 값을 생략하면 마지막 값을 증가시켜서 입력한다.*/
insert into test1(name) values('aaa');

insert into test1(no, name) values(100, 'yyy');

insert into test1(name) values('bbb'); /* no는 101이 입력된다.*/


insert into test1(name) values('ccc'); /* no=102 */
insert into test1(name) values('ddd'); /* no=103 */

/* 값을 삭제하더라도 auto-increment는 계속 앞으로 증가한다.*/
delete from test1 where no=103;

insert into test1(name) values('eee'); /* no=104 */

insert into test1(name) values('123456789012345678901234');

/* 다른 DBMS의 경우 입력 오류가 발생하더라도 번호는 자동 증가하기 때문에 
 * 다음 값을 입력할 때는 증가된 값이 들어간다.
 * 그러나 MySQL(MariaDB)는 증가되지 않는다.
 */
insert into test1(name) values('fff'); /* no=? */

```

- 다른 DBMS의 경우 입력 오류가 발생하더라도 번호는 자동 증가하기 때문에 다음 값을 입력할 때는 증가된 값이 들어간다. 그러나 MySQL(MariaDB)는 증가되지 않는다.

```sql
/*no =104*/
insert into test1(name) values('123456789012345678901234');
insert into test1(name) values('fff'); /* no=105 (106이 아니다!)*/
```



## 뷰(view)

- 조회 결과를 테이블처럼 사용하는 문법
- select 문장이 복잡할 때 뷰로 정의해 놓고 사용하면 편리하다.

```sql
create table test1 (
  no int primary key auto_increment,
  name varchar(20) not null,
  class varchar(10) not null,
  working char(1) not null,
  tel varchar(20)
);

insert into test1(name,class,working) values('aaa','java100','Y');
insert into test1(name,class,working) values('bbb','java100','N');
insert into test1(name,class,working) values('ccc','java100','Y');
insert into test1(name,class,working) values('ddd','java100','N');
insert into test1(name,class,working) values('eee','java100','Y');
insert into test1(name,class,working) values('kkk','java101','N');
insert into test1(name,class,working) values('lll','java101','Y');
insert into test1(name,class,working) values('mmm','java101','N');
insert into test1(name,class,working) values('nnn','java101','Y');
insert into test1(name,class,working) values('ooo','java101','N'); 
```

- 직장인만 조회
  - `select no, name, class`: **projection**: 특정 컬럼만 추출
  - `where working='Y'`: 단, working이 'Y'인 경우
```sql
select no, name, class from test1 where working = 'Y';
```

- **직장인만 조회한 결과를 가상 테이블로 만들기**
```sql
/* view 는 가상 테이블이다 */
create view worker
  as select no, name, class from test1 where working = 'Y';
```

```sql
select * from woker; /* select할 때 편하다. */
/*위의 코드는 다음과 같다.*/
select no, name, class from test1 where working ='Y';
```

실제로는 select의 조건이 많아서, 2~30라인을 작성할 때도 있다. 따라서 미리 가상 테이블을 만들어 놓고 쓴다.

- view가 참조하는 테이블에 데이터를 입력한 후 view를 조회하면?
  => 새로 추가된 컬럼이 함께 조회된다.
- 뷰를 조회할 때 마다 매번 select 문장을 실행한다.
  => 미리 결과를 만들어 놓는 것이 아니다.
- 일종의 **조회 함수 역할**을 한다.
- **복잡한 조회를 가상의 테이블로 표현할 수 있어 SQL문이 간결**해진다.
```sql
insert into test1(name,class,working) values('ppp','java101','Y');
select * from worker;
```

### 뷰 삭제
```
drop view worker;
```