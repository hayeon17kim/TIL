# JDBC

## JDBC API와 MariaDB JDBC Driver

- JDBC API: java.sql패키지에 있는 인터페이스

- MariaJDBC 드라이버: 인터페이스를 구현하고 이 클래스를 보조하기 위해서 만들어진 클래스들의 묶음 (org.mariadb.jdbc.)

![image](https://user-images.githubusercontent.com/50407047/97515799-29814c00-19d5-11eb-8b74-9aed0c7657a0.png)

- **Driver**<-Driver
  - 드라이버 정보, 커넥션 준비 메서드 규칙 정의
- **Connection** <- MariaConnection
  - DBMS와 연결
  - Statement, PreparedStatement 객체 생성
- **Statement** <- <MariaDbStatement
  - DBMS에 SQL을 전달(DBMS가 알 수 있도록 가공)
  - ResultSet 생성
- **PreparedStatement** <- ServerSidePreparedStatement
  - DBMS에 SQL을 전달
  - ResultSet 생성
- **ResultSet** <- SelectResultSet
  - DBMS에서 select를 실행한 결과를 한 개씩 가져온다.

독특한 구조: new 연산자로 생성할 수 없다. 공장 객체를 통해야 한다. Driver같은 경우는 체인점 본사, Connection인테리어 업자, Statement, PreparedStatement는 지점, Select ResultSet은 지점에서 만드는 김밥이라고 할 수 있다. 김밥을 만들기 위해서는 일단 체인점 본사에서 인테리어 업자를 만나고 지점을 만들어야 한다! 바로 `new 김밥()` 할 수 없다.



## DriverManager와 Driver

![image](https://user-images.githubusercontent.com/50407047/97515824-356d0e00-19d5-11eb-98fe-8eee79c5d226.png)

> 직관적으로 알아볼 수 있도록 import하지 않고 늘여 쓰기도 한다.

드라이버를 직접 생성해서 사용하는 것이 아니다.

- DriverManager에게 JDBC URL을 알려주면서 Connection 객체를 달라고 요청한다(Connection 요청). 
- DriverManager는 Driver를 찾아서 `connect()`를 호출한다. MariaDbConnection은 java.sql.Connection이라는 JDBC API 인터페이스 구현체이다. URL에 맞는 저 드라이버에 맞는 connect를 호출한다.
  - 못 찾았으면 에러
- Driver구현체는Connection구현체를 생성한다. (DBMS에 연결하는 객체) 생성해서 끝까지 계속 리턴한다.

## JDBC 드라이버 준비

- DBMS에 연결하기
  - MariaDB에 연결을 대행하는 클래스를 사용한다.
  - 이 클래스는 JDBC API규칙에 따라 작성되었고, JDBC Driver 파일(.jar)파일에 들어 있다.
  - 이 클래스를 사용하려면 먼저 이 JDBC Driver파일을 다운로드 받아 프로젝트의 ClassPath에 등록해야 한다.
- 절차
  - 1) mvnrepository.com 또는 search.maven.org에서 mariadb jdbc driver를 검색한다.
  - 2) 라이브러리 정보를 build.gradle 파일에 설정한다.
  - 3) gradle을 이용하여 eclipse 설정 파일을 갱신한다. `gradle eclipse`
    - 다운로드 받지 않은 라이브러리가 있다면 자동으로 서버에서 받을 것이다.
    - 라이브러리 정보가 변경되었다면 해당 라이브러리를 서버에서 받을 것이다.
  - 4) 이클립스 프로젝트를 refresh 한다.
    - 프로젝트에 mariadb jdbc driver 라이브러리가 추가되었는지 확인한다.

- JDBC 드라이버 로딩

  - java.sql.Driver 규칙에 따라 정의된 클래스를 로딩한다.

  - Driver 구현체는 **JDBC에 대한 정보를 제공**하고, **DBMS에 연결작업을 수행**한다.

  - > JDBC: Java Database Connectivity: 자바에서 DB 프로그래밍을 하기 위해 사용하는 API

  - Driver 구현체는 DriverManager가 관리한다.

  - 따라서 접속할 DBMS의 Driver구현체를 생성하여 DriverManager에게 등록해야 한다.

- DriverManager

  - `java.sql.Driver` 구현 객체를 관리하는 일을 한다. 
  - **DBMS 연결 요청**이 들어오면 **해당 DBMS의 Driver 구현체를 찾아 작업**을 한다.



## JDBC 드라이버 로딩 방법

### JDBC Driver 로딩 방법 1: 직접 Driver 구현 객체를 생성하고 직접 등록하기

java.sql.Driver 구현체를 생성하여 JDBC 드라이버 관리자에 등록한다. 

```java
// 1) Driver 구현체의 인스턴스를 생성한다.
java.sql.Driver mariadbDriver = new org.mariadb.jdbc.Driver();

// 2) Driver 인스턴스를 드라이버 관리자에 등록한다.
DriverManager.registerDriver(mariadbDriver);
System.out.println("JDBC 드라이버 로딩 및 등록 완료!");

// DriverManager에 등록된 Driver 인스턴스를 확인한다.
// => DriverManager.getDriver(jdbcUrl);
// => jdbcUrl
// jdbc:[DBMS]://서버주소:포트번호/데이터베이스명
java.sql.Driver driver = DriverManager.getDriver("jdbc:mariadb:");
System.out.println(driver); 

// JDBC 드라이버 로딩 및 등록 완료!
// org.mariadb.jdbc.Driver@5674cd4d
```



### JDBC Driver 로딩 방법2: Driver 구현 객체 생성과 자동 등록

Driver 객체를 생성하면 자동으로 DriverManager에 등록된다. Driver 구현체가 로딩될 때 static 블록에서 인스턴스를 만들어 등록하기 때문이다.

```java
// 1) Driver 구현체의 인스턴스를 생성
// => Driver 구현체가 로딩될 때 인스턴스가 생성되기 때문에
// 굳이 다음과 같이 인스턴스를 생성할 필요가 없다.
new org.mariadb.jdbc.Driver();

// 2) DriverManager에 등록하지 않는다.

// DriverManager에 자동으로 등록되었는지 확인한다.
java.sql.Driver driver = DriverManager.getDriver("jdbc:mariadb:");
System.out.println(driver);
// 해당 드라이버가 등록되지 않았다면 에외가 발생할 것이다.
```

### JDBC Driver 로딩 방법3: Driver 구현 클래스 로딩과 자동 등록

`java.sql.Driver` 인터페이스를 구현한 클래스를 로딩하면 해당 클래스에서 자신을 자동으로 DriverManager에 등록할 것이다. 

다음은 MariaDB의 Driver 구현체의 코드 중 일부이다.  클래스가 로딩되면 static 블록은 무조건 실행된다. 이 static 블록에는 스스로 자신의 인스턴스를 만들어 DriverManager에 등록하는 코드가 들어 있다. 즉 Driver 클래스가 로딩되면 이러한 작업들이 실행된다.

```java
public final class Driver implements java.sql.Driver {

  static {
    try {
      // static 블록에서 스스로 자기자신을 만들어서 등록시킨다.
      DriverManager.registerDriver(new Driver(), new DeRegister());
    } catch (SQLException e) {
      throw new RuntimeException("Could not register driver", e);
    }
  }
  //..
```

이 방식의 장점은 소스 코드에 클래스를 지정하는 대신 클래스 이름을 지정하기 때문에 실행할 때 다른 클래스로 쉽게 바꿀 수 있다. 따라서 특정한 Driver 구현체에 종속되지 않게 만들 수 있다.

`Class.forName("fully-qualified class name(패키지명을 포함한 클래스명)")`

- 문자열 파라미터로 주어진 클래스를 찾아 메모리(Method Area)에 로딩한다.
- 이 과정에서  static 블록이 실행될 것이고, 결국 Driver인스턴스가 생성되어 DriverManager에게 등록될 것이다.
- 한 번 로딩된 클래스는 중복해서 로딩되지 않는다. 따라서  `static` 블록도 중복해서 실행되지 않는다. 따라서 같은 Driver 인스턴스가 여러 개 생성되어 DriverManager에 여러 개 등록되는 것이 아니다.

```java
Class.forName("org.mariadb.jdbc.Driver");
// DriverManager에 자동 등록된 것을 확인해보자!
java.sql.Driver driver = DriverManager.getDriver("jdbc:mariadb:");
System.out.println(driver);
```

### JDBC Driver 로딩 방법4: Driver 구현체 자동 로딩

DriverManager를 사용할 때, DriverManager는 다음 절차에 따라 Driver 구현체를 찾아서 자동으로 로딩한다.

- 1) `jdbc.drivers`  **시스템 프로퍼티에 지정된 구현체를 찾아** **로딩**한다.

  - `jdbc.drivers=foo.bah.Driver:wombat.sql.Driver:bad.taste.ourDriver`

  - 이때 각 Driver 구현체는 'system class  loader'를 통해 로딩된다.

  - 시스템 프로퍼티는 JVM에 설정된 "key=value"이다. 

  - 시스템 프로퍼티 꺼내는 방법

    - `System.out.printf("java.home=%s\n", System.getProperty("java.home"));`

  - 시스템 프로퍼티 설정 방법

    - 1) JVM을 실행할 때 JVM 옵션을 지정하는 방법

      - `java -Djdbc.drivers=클래스명:클래스명:클래스명 Exam0140`

    - 프로그램 코드에서 설정하는 방법

      ​	`System.setProperty("jdbc.drivers", "com.eomcs.jdbc.ex1.MyDriver");`

- 2) **`java.sql.Driver` 클래스의 서비스 제공자를 찾아** **로딩**한다.

  - `jar` 파일 안에 `META-INF/services/java.sql.Driver` 파일을 찾는다.
  - 이때 JVM은 'service-provider loading' 절차에 따라 이 파일에 등록된 클래스를 로딩한다.
  - `jar`  파일에 해당 정보가 있다면, 1~3 방법처럼 개발자가 따로 `java.sql.Driver` 구현체를 명시적으로 등록하지 않아도 된다.
  - 예를 들어, mariadb JDBC 드라이버 jar 파일은 이 정보가 들어 있다. 다라서 `java.sql.Driver`를 구현한 클래스를 로딩하거나 생성할 필요가 없다.

```java
public class Exam0141 {
  public static void main(String[] args) {
    try {
      java.sql.Driver driver = DriverManager.getDriver("jdbc:maradb:");
      System.out.println(driver);
      System.out.println("테스트!");
    } catch (Exception e) {
      e.printStackTrace();
    }
  }
}
```







DB를 여러개 쓸 상황도 있나? 있다! 오라클에서 데이터베이스를 읽어서 ms데이터를 읽어서 합쳐서 오라클에 집어넣고 등등. 드라이버를 다 등록해서 써야 한다. 한 db에서 다른 db로 옮기는 등  

```java
public class Exam0110 {
  public static void main(String[] args) {
    try {
      java.sql.Driver mariadbDriver = new org.mariadb.jdbc.Driver();
      java.sql.Driver oracleDriver = new oracle.jdbc.driver.OracleDriver();
      java.sql.Driver mssqlDriver = new com.microsoft.sqlserver.jdbc.SQLServerDriver();
      DriverManager.registerDriver(mariadbDriver);
      DriverManager.registerDriver(oracleDriver);
      DriverManager.registerDriver(mssqlDriver);
      java.sql.Driver driver = DriverManager.getDriver("jdbc:mariadb://");
      System.out.println(driver); //org.mariadb.jdbc.Driver@5674cd4d
      java.sql.Driver driver2 = DriverManager.getDriver("jdbc:oracle:thin://");
      System.out.println(driver2); //oracle.jdbc.OracleDriver@e9e54c2
      java.sql.Driver driver3 = DriverManager.getDriver("jdbc:sqlserver://");
      System.out.println(driver3); //SQLServerDriver:1
      
      
    } catch (Exception e) {
      e.printStackTrace();
    }
  }
}
```


### 

```java
public class Exam0120 {

  public static void main(String[] args) throws Exception {

    // JDBC 드라이버 로딩 방법2: Driver 구현 객체 생성과 자동 등록
    // => Driver 객체를 생성하면 자동으로 DriverManager에 등록된다.
    // => 어떻게?
    // Driver 구현체가 로딩될 때 static 블록에서 인스턴스를 만들어 등록하기 때문이다.

    try {
      // 1) Driver 구현체의 인스턴스 생성
      // => Driver 구현체가 로딩될 때 인스턴스가 생성되기 때문에
      // 굳이 다음과 같이 인스턴스를 생성할 필요가 없다.
      new org.mariadb.jdbc.Driver();

      // 2) DriverManager에 등록 안함!

      // DriverManager에 자동으로 등록됐는지 확인해보자!
      java.sql.Driver driver = DriverManager.getDriver("jdbc:mariadb:");
      System.out.println(driver);
      // 해당 드라이버가 등록되지 않았으면 예외가 발생할 것이다.

    } catch (SQLException e) {
      e.printStackTrace();
    }
  }
}

```



## 드라이버 클래스 로딩

```java
public final class Driver implements java.sql.Driver {

  static {
    try {
      // static 블록에서 스스로 자기자신을 만들어서 등록시킨다.
      DriverManager.registerDriver(new Driver(), new DeRegister());
    } catch (SQLException e) {
      throw new RuntimeException("Could not register driver", e);
    }
  }
  //..
```





new 연산자로 이름을 박아버리면 교체하기 어렵다. 그럼 `Class.forName()`으로 등록한다고 해도 이름을 박는 거 아닌가? 아니다! 교체할 땐 파일 이름만 바꾸면 된다!



- jdbc.drivers 시스템 프로퍼티에 지정된 구현체를 찾아 로딩한다.
  - jdbc.drivers=foo.bah.Driver:wombat.sql.Driver:bad.taste.ourDriver
  - 이때 각 Driver 구현체는 'system class loader'를 통해 로딩된다.
  - 시스템 프로퍼티? JVM에 설정된 "key=value" 이다.

JVM System Properties: JVM 시스템이 사용하는 변수, 값 목록(properties)



### DriverManager가 Driver 구현체를 자동 로딩

```java
public class Exam0140 {
  public static void main(String[] args) {
    // 드라이버 설정
    System.out.printf("java.home=%s\n", System.getProperty("java.home"));
  }
}
```



### DriverManager의 Driver wkehd emdfhr

- jdbc.drivers 시스템 프로퍼티에 등록된 클래스를 생성해서 등록한다.
- jar 파일에서 META-INF/servies/java.sql.Driver 파일을 찾는다. 이 파일에 적혀 있는 클래스의 인스턴스를 생성해서 등록 
  - 옛날 jar파일 같은 경우 이 java.sql.Driver파일이 없을 수도 있다. 없으면 자동이 안 되고, 인스턴스를 생성하거나  Class.forName을 해줘야 한다.
  - 있다면 Referenced Libraries에 있는 jar파일들을 하나하나 뒤져서 java.sql.Driver를 찾고, 이 파일에 적혀 잇는 클래스의 인스턴스를 생성해서 등록한다.
- 이 파일에 적혀 있는 클래스를 생성 -> 등록

- 만약 자기가 알아서 한다면 jar 파일에 특정한 파일이 있고 이 파일을 갖고 자동으로 작업한다는 것을 기억하자.
- 결론! 최신 jar 경우 아무것도 안해도 알아서 인스턴스를 생성해서 등록한다!



## JDBC 프로그래밍

### DBMS에 연결하기

```java
//MariaDbConnection con = (MariaDbConnection) DriverManager.getConnection(
Connection con = DriverManager.getConnection(
  "jdbc:mariadb://localhost:3306/studydb", //jdbcURL
  "study", // username
  "1111"); // password
System.out.println(con.getClass().getName()); //org.mariadb.jdbc.MariaDbConnection
```

- 개발자는 드라이버 이름도 알 필요가 없다. 특정 객체에 한정짓지 말고 인터페이스로 레퍼런스 변수를 선언하자. 그냥 이 변수가 알아서 처리할 것이다.
- 포트번호는 dbms마다 다르다! MARIADB는 3306이다. 직접 서버를 만들 때도 이 포트번호는 안 쓰는 것이 좋다.

- 포트번호가 잘못되었을 때: 포트 번호 3306/studydb이(가) 잘못되었습니다.

- db이름이 다를 때:  Access denied for user 'study'@'localhost' to database 'studydb2'



- 자원을 쓰고 close()를 호출하지 않으면 스레드를 계속 갖고 있는다. 

```java
try (Connection con = DriverManager.getConnection(
  "jdbc:mariadb://localhost:3306/studydb", //jdbcURL
  "study",
  "1111");){
  
  System.out.println(con.getClass().getName());
} catch (Exception e) {
  e.printStackTrace();
}
```

연결할 때 다음과 같이 주소를 하나의 문자열로 해서 인자로 넘길 수 있다.

```java
try (Connection con = DriverManager.getConnection("jdbc:mariadb://localhost:3306/studydb?user=study&password=1112")) {
  System.out.println(con.getClass().getName());
} catch (Exception e) {
  e.printStackTrace();
}
```



## DBMS에 SQL문 보내기

- `executeUpdate()`: INSERT/UPDATE/DELETE 등 DML 관련 SQL문 전송
  - 리턴값: 변경(insert/update/delete)된 데이터의 개수
- `executeQuery()`: SELETE 등 DQL 관련 SQL문 전송
  - 리턴값: 서버에서 데이터를 가져오는 일을 할 객체

### insert 

```java
try (Connection con = DriverManager.getConnection("jdbc:mariadb://localhost:3306/studydb?user=study&password=1112");
    java.sql.Statement stmt = con.craeteStatement();) {
  System.out.println(stmt.getClass().getName());
  int count = stmt.executeUpdate(
  "insert into x_board(title, contents) values('제목10', '내용10')");
} catch (Exception e) {
  e.printStackTrace();
}
```

### select

![image](https://user-images.githubusercontent.com/50407047/97528509-4461b980-19f1-11eb-8234-19151f2a6486.png)

- `executeQuery()`
  - DBMS 서버에 select 문을 보낸다.
  - 리턴 값: `java.sql.ResultSet` 구현 객체
- `ResultSet`
  - <mark>결과가 아니라, **서버에서 결과를 가져오는 일**을 할 객체</mark>이다. 
  - 즉 서버의 select 실행 결과를 가져올 때 사용하는 도구이다.
  - ResultSet 객체를 사용하여 서버에서 select의 결과 **한 레코드(row)**를 가져온다.
- `getXxx(컬럼 번호)`
  - select 문에 나열한 컬럼의 순서를 지정한다. 단 번호는 0부터가 아니라 1부터 지정한다.
  - select문에  `wildcard(*)`를 사용했다면, 테이블을 정의할 때 선언한 컬럼의 순서이다.
  - 컬럼의 타입과 상관 없이 `getString()`으로 값을 꺼낼 수 있다.
  - DBMS에 설정된 컬럼의 타입에 따라 값을 변환해서 받고 싶다면, 다음과 같이 해당 타입의 값을 리턴하는 `getXxx()`를 호출한다.
    - int, number: `getInt()`
    - char, varchar, text: `getString()`
    - date, datetime: `getDate()`
    - float: `getFloat()`

```java
public static void main(String[] args) throws Exception {
  try (java.sql.Connection con = DriverManager.getConnection("jdbc:mysql://localhost:3306/studydb?user=study&password=1111");
       java.sql.Statement stmt = con.createStatement();
       java.sql.ResultSet rs = stmt.executeQuery("select * from x_board order by board_id desc");) {
    boolean isReceived = rs.next();
    
    if (isReceived) {
      System.out.printf("%s, %s, %s, %s, %s\n",
                       rs.getString(1), // board_id
                       rs.getString(2), // title
                       rs.getString(3), // contents
                       rs.getString(4), // created_date
                       rs.getString(5)); // view_count
      //9, 제목10, 내용, 2020-10-29 14:27:28.0, 0
    }
    
    if (isReceived) {
        System.out.printf("%d, %s, %s, %s, %d\n",
                          rs.getInt(1), 
                          rs.getString(2), 
                          rs.getString(3), 
                          rs.getDate(4), 
                          rs.getInt(5));
      // 9, 제목10, 내용, 2020-10-29, 0
    }
    
    if (isReceived) {
        System.out.printf("%d, %s, %s, %s, %d\n",
                          rs.getInt("board_id"), 
                          rs.getString("title"), 
                          rs.getString("contents"), 
                          rs.getDate("created_date"), 
                          rs.getInt("view_count"));
      }
      // 9, 제목10, 내용, 2020-10-29, 0
  }
}
```

**반복문**을 사용하면 **서버에서 여러 개의 데이터를 가져올 수 있다.**

```java
while (rs.next()) {
  System.out.printf("%d, %s, %s, %s, %d\n",
                    rs.getInt("board_id"), 
                    rs.getString("title"), 
                    rs.getString("contents"), 
                    rs.getDate("created_date"), 
                    rs.getInt("view_count"));
}
```

실행 결과는 다음과 같다.

```java
9, 제목10, 내용, 2020-10-29, 0
8, 제목10, 내용, 2020-10-29, 0
7, 제목10, 내용, 2020-10-29, 0
6, 제목6, 내용, 2020-10-29, 0
5, 제목5, 내용, 2020-10-29, 0
4, 제목4, 내용, 2020-10-29, 0
3, 제목3, 내용, 2020-10-29, 0
2, 제목2, 내용, 2020-10-29, 0
1, 제목1, 내용, 2020-10-29, 0
```

### update

아이디가 3보다 큰 애들의 조회수를 20만큼 증가시킨다.

```java
int count = stmt.executeUpdate("update x_board set view_count = view_count + 20"
                               + " where board_id > 3");
System.out.printf("%s개 변경 성공!", count);
// 6개 변경 성공!
```

테이블을 확인해보면 아이디가 3보다 큰 게시물의 조회수가 전부 20만큼 커졌다.

```java
+----------+----------+----------+---------------------+------------+
| board_id | title    | contents | created_date        | view_count |
+----------+----------+----------+---------------------+------------+
|        1 | 제목1    | 내용     | 2020-10-29 12:51:10 |          0 |
|        2 | 제목2    | 내용     | 2020-10-29 12:51:10 |          0 |
|        3 | 제목3    | 내용     | 2020-10-29 12:51:10 |          0 |
|        4 | 제목4    | 내용     | 2020-10-29 12:51:10 |         20 |
|        5 | 제목5    | 내용     | 2020-10-29 12:51:10 |         20 |
|        6 | 제목6    | 내용     | 2020-10-29 12:51:10 |         20 |
|        7 | 제목10   | 내용     | 2020-10-29 13:00:48 |         20 |
|        8 | 제목10   | 내용     | 2020-10-29 13:04:08 |         20 |
|        9 | 제목10   | 내용     | 2020-10-29 14:27:28 |         20 |
+----------+----------+----------+---------------------+------------+
```

### delete

```java
int count = stmt.executeUpdate("delete from x_board where board_id = 9");
System.out.printf("%s 개 삭제 성공!", count); // 1개 삭제 성공!
// 다시 한 번 실행하면 삭제할 데이터가 없기 때문에 0을 리턴한다 (0개 삭제 성공!)
```

만약 삭제할 것이 없다면 삭제하지 않고 0을 리턴한다! 이때 

`constraint foreign key(board_id) references x_board(board_id)`

`x_board` **무결성 제약조건에 결함**이 발생하기 때문에 삭제할 수 없다. `SQLIntegrityConstraintViolationException`

```java

```



Cannot delete or update a parent row: a foreign key constraint fails (`studydb`.`x_board_file`, CONSTRAINT `fk_board_file` FOREIGN KEY (`board_id`) REFERENCES `x_board` (`board_id`))



개발자를 모든 파일 입출력 crud에서 해방시킨다. d



## 게시판 관리

```java
public class Exam0110 {
  public static void main(String[] args) throws Exception {
    String title = null;
    String contents = null;
    
    try (Scanner keyScan = new Scanner(System.in)) {

      // 사용자로부터 제목, 내용을 입력 받는다.
      System.out.print("제목? ");
      title = keyScan.nextLine();

      System.out.print("내용? ");
      contents = keyScan.nextLine();

      System.out.print("입력하시겠습니까?(Y/n) ");
      String input = keyScan.nextLine();

      if (!input.equalsIgnoreCase("y") && input.length() != 0) {
        System.out.println("등록을 취소 하였습니다.");
        return;
      }
    }
    
    try (Connection con = DriverManager.getConnection(
    "jdbc:mysql://localhost:3306/studydb?user=studydb?user=study&password=1111");
        )
  }
}
```



## Statement와 SQL 삽입 공격

