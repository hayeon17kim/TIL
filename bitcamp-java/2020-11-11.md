## MyBatis 문법

> com.eomcs.mybatis.ex01

### Data Persistence Framework

**데이터의 영속성(지속성; 등록, 조회, 변경, 삭제)를 대신 처리해주는 프레임워크**를 말한다. 퍼시스턴스 프레임워크를 사용하면 **JDBC의 복잡함이나 번거로움 없이 간단한 작업만으로 데이터 베이스와 연동되는 시스템을 빠르게 개발**할 수 있으며 **안정적인 구동도 보장**한다. Data Persistence Framework에는 SQL문장으로 **직접 데이터베이스 데이터를 다루는 SQL Mapper**와, **자바 객체를 통해 간접적으로 데이터베이스 데이터를 다루는 OR Mapper**(Object-Relational mapper; 객체 관계 맵퍼)가 있다.

> 컴퓨터 공학에서 지속성(Persistance)는 **프로세스가 생성**했지만 **별개로 유지되는 상태의 특징** 중 한 가지로, **별도의 기억 장치에 데이터를 보존**하는 것을 목적으로 한다. 

SQL Mapper는 **직접 SQL문을 작성**한다. 따라서 각각의 DBMS에 최적화된 SQL을 작성할 수 있다. 그러나 DBMS마다 미미하게 다른 SQL을 작성해야 하는 번거로움이 있다. Mybatis가 대표적으로 다른 SQL Mapper는 거의 사용되지 않는다. 주로 SI 업체에서 사용한다.

OR Mapper는 **전용 언어 및 문법(Domain-Specific Language; DSL)**을 사용하여 작성하고, **실행할 때 DBMS에 맞춰서 SLQ을 생성하여 실행**한다. DBMS마다 SLQ문을 작성할 필요가 없어 편리하지만 DBMS에 최적화된 SQL을 실행할 수 없다는 단점이 있다. 즉 DBMS에 최적화된 SQL을 실행할 수 없다. Hibernate, TopLink가 대표적으로, 주로 서비스 업체에서 사용한다.



### MyBatis 도입

#### 1. 의존 라이브러리 추가 

- `build.gradle` 파일에 의존 라이브러리 추가 후  터미널에서 `gradle eclipse` 명령을 실행한다.

#### 2. mybatis 설정 파일 준비

> com.eomcs.mybatis.ex1.mybatis-config.xml

`<properties>`의 `resource` 속성값으로 적은 경로에 있는 jdbc.properties 파일의 내용을 읽어온다. **읽어온 정보는 `${프로퍼티명}` 문법을 이용하여 그 값을 사용할 수 있다.**클래스 파일이 아니기 때문에 `.`를 사용하는 것이 아니라 `/`를 사용하여 일반 파일 경로를 적어준다.

```xml
<properties resource="com/eomcs/mybatis/ex01/jdbc.properties"></properties>
```

`<environments>` 태그에서는 DBMS에 연결할 때 사용할 정보를 설정한다. 열어 개의 연결 정보를 설정해두고 그 중에 사용할 정보를 지정할 수 있다. `defaul="development"`의 의미는, 여러 연결 정보 중에서 `development`라는 연결 정보를 사용하여 실행하겠다는 의미이다.

```xml
<environments default="development">
```

각각의 연결 정보는 다음과 같이 `<environment>`  태그에 설정한다.

```xml
<environment id="development">
```

트랜젝션 관리 방식을 지정한다. 커넥션 객체에 대해서 대신 `commit`, `rollback` 한다는 의미이다.

```xml
<transactionManager type="JDBC">
```

`<dataSource>`에서는 **DB 커넥션 풀**에 관련된 정보와 **DB 연결 정보**를 설정한다. 이제 개발자가 DB 커넥션 풀을 다룰 필요가 없다. mybatis 프레임워크에서 관리한다.

> 로컬에서는 DB 커넥션 풀이 필요 없다. 이것을 서버로 옮기면 DB 커넥션 풀이 필요할 것이다.

> DB Connection Pool? DB와 미리 connection(연결)을 해놓은 객체들을 pool(웅덩이)에 저장해두었다가, 클라이언트 요청이 오면 커넥션을 빌려주고, 볼 일이 끝나면 다시 커넥션을 반납받아 pool에 저장하는 방식을 말한다.

```xml
<dataSource type="POOLED">
  <!-- ${위의 .properties 파일에 저장된 프로퍼티명} -->
  <property name="driver" value="${jdbc.driver}"/>
  <property name="url" value="${jdbc.url}"/>
  <property name="username" value="${jdbc.username}"/>
  <property name="password" value="${jdbc.password}"/>
</dataSource>
```

`<mappers>` 와 `<mapper>`에는 SQL문을 모아둔 파일(SQL Mapper 파일)을 지정한다. SQL Mapper 파일에 작성해둔 SQL 문을 mybatis가 사용할 것이다. 맵퍼 파일의 경로를 지정할 때 classpath 경로를 사용해야 한다. 단 패키지명을 구분할 때 `.` 대신에 `/`를 사용해야 한다. 클래스 파일이 아니라 일반 파일이기 때문이다. 

```xml
  <mappers>
    <mapper resource="com/eomcs/mybatis/ex01/BoardMapper.xml"/>
  </mappers>
```
#### 3. DB 연결 정보를 담은 프로퍼티 파일 준비

> jdbc.properties

```properties
# key=value
jdbc.driver=org.mariadb.jdbc.Driver
jdbc.url=jdbc:mariadb://localhost:3306/studydb
jdbc.username=study
jdbc.password=1111
```

#### 4. SQL 문장을 작성할 파일

> BoardMapper.xml

SQL 문장을 찾을 때 사용할 그룹명을 설정한다. 보통 그룹명은 **SLQ Mapper 파일이나 그 파일이 있는 경로**를 그룹명으로 지정한다. 또는 **SQL을 사용할 인터페이스나 클래스 경로**를 그룹명으로 지정한다. 이것은 관습적이기 때문에 실제로는 어떤 이름으로 지정해도 상관 없지만, 가능한 규칙을 준수하여 유지보수의 일관성을 유지하는 것이 좋다.

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="BoardMapper">
  
  <select id="selectBoard" resultType="com.eomcs.mybatis.ex01.Board">
    select 
      board_id,
      title,
      contents,
      created_date,
      view_count
    from x_board
  </select>
  
  <select id="selectBoard2" resultType="com.eomcs.mybatis.ex01.Board">
    select 
      board_id as no,
      title,
      contents as content,
      created_date registeredDate,
      view_count viewCount
    from x_board
  </select>
</mapper>
```



#### 5. Mybatis 객체 준비

##### 5.1. mybatis 설정 파일을 읽을 InputStream 도구 준비

**5.1.3. 직접 파일 시스템 경로 지정**

단 소스 파일 경로를 지정하는 것이 아니라 **컴파일된 후 XML 파일이 놓이는 경로**를 지정해야 한다. **자바 패키지에 작성**한 **일반 파일은 그대로 빌드 디렉토리에 복사**된다.

```java
InputStream mybatisConfigInputStream = new FileInputStream(
        "./bin/main/com/eomcs/mybatis/ex01/mybatis-config.xml");
```

그러나 mybatis 설정 파일의 경로를 직접 지정하면 **애플리케이션 배포 경로가 바뀔 때마다 소스를 변경하고 다시 컴파일해야 하는 문제**가 있다.

**5.1.2. Resources 클래스의 메서드 이용**

이를 간편하게 하기 위해 Mybatis는 Resources라는 도우미 객체를 제공한다. 이 클래스의 메서드를 이용하면 자바 클래스가 있는 패키지 폴더에서 mybatis 설정 파일을 찾을 수 있다. 

```java
InputStream mybatisConfigInputStream = Resources.getResourceAsStream(
  "com/eomcs/mybatis/ex01/mybatis-config.xml");
```

파라미터에 mybatis 설정 파일의 경로를 지정할 때, 자바 패키지 경로를 그대로 이용한다. 단 파일 경로이기 때문에 폴더와 폴더 사이를 가리킬 때 `.` 대신에 `/`를 사용해야 한다. JVM은 현재 실행하는 애플리케이션의 자바 클래스 경로를 알고 있다. 

> 자바 패키지 경로에서 찾기 때문에 mybatis 설정 파일은 반드시 자바 패키지 경로에 있어야 한다.

##### 5.2. SqlSessionFactory를 만들어 줄 빌더 객체 준비

```java
SqlSessionFactoryBuilder factoryBuilder = new SqlSessionFactoryBuilder();
```

##### 5.3. SqlSession 객체를 만들어줄 팩토리 객체 준비

mybatis 는 Builder를 이용하여 SqlSessionFactory 객체를 만든다. 이때 공장 객체를 만들 때 사용할 설정 파일을 지정한다. 설정 파일의 경로를 직접 지정하지 말고, 해당 파일을 읽을 때 사용할 `InputStream`을 넘겨준다.

```java
SqlSessionFactory factory = factoryBuilder.build(mybatisConfigInputStream);
```

##### 5.4. SQL을 실행시키는 객체 준비

```java
SqlSession sqlSession = factory.openSession();
```

`SqlSessionFactory` 객체로부터 `SqlSession` 객체를 얻는다. `openSession()`은 수동 커밋으로 SQL을 다루는 객체를 리턴한다. 자동 커밋으로 SQL을 다루려면 `openSession(boolean autoCommit)` 메서드를 호출해야 한다.

Builder는 한 번만 사용하기 때문에 다음과 같이 코드를 정리할 수 있다.

```java
SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(
  Resources.getResourceAsStream(
    "com/eomcs/mybatis/ex01/mybatis-config.xml"));
```

### SQL 문 실행

SqlSession 객체를 이용하여 SQL 맵퍼 파일에 작성한 SQL문을 실행한다.

- `select` 문장
  - `sqlSession.selectList()`: 목록 리턴
  - `sqlSession.selectOne()`: 한 개의 결과 리턴
- `insert` 문장
  - `sqlSession.insert()`
- `update` 문장
  - `sqlSession.update()`
- `delete` 문장
  - `sqlSession.delete()`

insert, update, delete인 경우 `insert()`, `update()`, `delete()` 메서드 중 아무거나 호출해도 괜찮다. 그러나 일관된 유지보수를 위해 메서드를 구분해서 사용하는 것이 권장된다.

메서드를 사용하기 위해서는 **SQL식별자와 파라미터값**을 넘겨주어야 한다. SQL 식별자는 `그룹명+'.'+SQL문장아이디`를 뜻한다. 여기서 그룹명은 `<mapper namesace="그룹명">..<mapper>`에서 확인할 수 있다. 파라미터 값으로는 **원시타입 및 모든 자바 객체가 가능**하다. **여러 개의 값을 전달할 때는 `Map`에 담아 넘기**도록 하자.

### 컬럼 이름과 프로퍼티의 이름

**`selectList()`의 동작 원리**

```java
List<Board> list = 
  sqlSession.selectList("BoardMapper.selectBoard");

for (Board board : list) {
  System.out.printf("%d, %s, %s, %s, %d\n", 
                    board.getNo(), 
                    board.getTitle(), 
                    board.getContent(),
                    board.getRegisteredDate(),
                    board.getViewCount());
}
```

```xml
<select id="selectBoard" resultType="com.eomcs.mybatis.ex01.Board">
select 
  board_id,
  title,
  contents,
  created_date,
  view_count
from x_board
</select>
```

`resultType`에 지정한 클래스의 인스턴스를 생성한다. **컬럼 이름과 일치하는 프로퍼티를 찾아 값을 입력**한다.  `board.id`는 `setBoard_id(컬럼값)`을, `title`은 `setTitle(컬럼값)`을, `contents`는 `setContents(컬럼값)`을, `created_date`은 `setCreated_date(컬럼값)`을, `view_count`는 `setView_count(컬럼값)`을 호출한다. 컬럼 이름과 일치하는 프로퍼티(setter)가 없다면 그 컬럼의 값은 객체에 담을 수 없다. 이 예제에서 컬럼 이름과 일치하는 프로퍼티는 `title`밖에 없다.



#### 컬럼 이름과 자바 객체의 프로퍼티 이름 일치시키기

컬**럼의 값을 자바 객체에 담으려면** **컬럼과 같은 이름의 프로퍼티가 있어야 한다.** 

```java
List<Board> list = sqlSession.selectList("BoardMapper.selectBoard2");

for (Board board : list) {
  System.out.printf("%d, %s, %s, %s, %d\n", board.getNo(), board.getTitle(), board.getContent(), board.getRegisteredDate(), board.getViewCount());
}
```

없다면 프로퍼티 명을 다음과 같이 컬럼의 별명으로 지정한다.

```xml
<select id="selectBoard" resultType="com.eomcs.mybatis.ex01.Board">
 select
   board_id as no,
   title,
   contents as content,
   created_date as registeredDate,
   view_count as viewCount
 from x_board
</select>
```

별명을 붙일 때는 `as`를 붙여도 되고 붙이지 않아도 된다.



#### 클래스 별명 지정하기

`<typeAliase>` 태그를 사용하면 **mybatis 설정 파일**에서 **`fully-qualified class name`을 사용하는 대신에 짧은 이름으로 대체**할 수 있다. 이때 패키지를 포함한 클래스 이름은 항상 `.` 으로 표기해야 한다. `/` 는 파일 경로를 가리킬 때 사용한다.  `<properties>`와 `<settings>` 뒤에 `<typeAliases>`를 적는다.  만약 이 **순서**를 지키지 않는다면  에러가 뜰 것이다.

```xml
<typeAliases>
  <typeAlias type="com.eomcs.mybaits.ex1.Board" alias="abc"></typeAlias>
</typeAliases>
```

이 별명은 다음과 같이 **SQL 맵퍼 파일에서 클래스를 지정**할 때 사용한다. 별명은 대소문자를 구분하지 않는다.

```xml
<select id="selectBoard2" resultType="abc">
 select
	board_id as no,
 	title,
	contents as content,
  created_date registeredDate,
  view_count viewCount
 from x_board
</select>
```

패키지에 소속된 전체 클래스에 대해서도 별명을 부여할 수 있다.

```xml
<typeAliases>
  <package name="com.eomcs.mybastis.ex01"/>
</typeAliases>
```

> SQL문은 태그 안에 작성한다. `<select>` 태그에는 select 문장을, `<insert>` 태그에는 insert 문장을, `<update>` 태그에는 update 문장을, `<delete>` 태그에는 delete 문장을 작성한다. 그런데 insert/update/delete 인 경우 `<insert>/<update>/<delete>` 구분없이 태그를 사용해도 된다. 그 이유는 SQL문을 찾을 때 id 속성 값으로 찾기 때문이다. 그럼에도 불구하고 유지보수의 일관성을 위해 SQL 문의 따라 적절한 태그를 사용하라!

### select  컬럼과 프로퍼티

- `id`: SQL문을 찾을 때 사용할 식별자이다.
- `resultType`: `select` 결과를 저장할 클래스 이름이나 별명이다. 클래스 이름일 경우 반드시 fullly-qualified class name(패키지명을 포함한 클래스명)을 사용해야 한다.

**값을 자바 객체에 넣는 규칙**

- 컬럼명과 일치하는 setter를 호출한다.

- 컬럼명 => `set컬럼명()`

  ```java
  //예:
  Board board = new Board();
  board.setBno(rs.getNo("bno"));
  ```

- 만약 컬럼 이름에 해당하는 셋터를 못 찾으면 호출하지 않는다.

```xml
<select id="selectBoard" resultType="Board">
  select 
  board_id, <!-- Board.setBoard_id() 호출 -->
  title,    <!-- Board.setTitle() 호출 -->
  contents, <!-- Board.setContents() 호출 -->
  created_date, <!-- Board.setCreated_date() 호출 -->
  view_count    <!-- Board.setView_count() 호출 -->
  from x_board
</select>
```

위의 SQL문을 mybatis는 내부에서 다음과 같은 코드로 실행할 것이다.

```java
while (rs.next()) {
  Board board = new Board();
  board.setBoard_id(rs.getNo("board_id")); // 이런 셋터가 없다.
  board.setTitle(rs.getString("title")); // 이 셋터는 있다.
  board.setContents(rs.getString("contents")); // 이런 셋터가 없다.
  board.setCreated_date(rs.getDate("created_date")); // 이런 셋터가 없다.
  board.setView_count(rs.getDate("view_count")); // 이런 셋터가 없다.
  list.add(board);
} 
return list;
```

그러나 Board 클래스에는 컬럼 이름과 일치하는 셋터가 딱 한 개만 있다. title 컬럼이다. 그 외 컬럼 값은 셋터가 없기 때문에 저장할 수 없다. 즉 mybatis에서 결과 값을 Board 객체에 담지 못한다. 따라서 다음 코드는 실행 오류가 발생한다. 

```java
List<Board> list = sqlSession.selectList("BoardMapper.selectBoard");

for (Board board : list) {
  System.out.printf("%d, %s, %s, %s\n", //
                    board.getNo(), //
                    board.getTitle(), //
                    board.getContent(), //
                    board.getRegisteredDate());
}
```

이를 해결하기 위해서는 **셋터의 이름(프로퍼티 이름)과 같은 이름으로 컬럼의 별명을 설정**해야 한다. 즉, 컬럼 이름을 프로퍼티 이름과 일치시킴으로써 setter를 정확하게 호출하도록 만든다.

```xml
<select id="selectBoard" resultType="Board">
  select 
  board_id as no,     <!-- Board.setNo() 호출 -->
  title,              <!-- Board.setTitle() 호출 -->
  contents content,   <!-- Board.setContent() 호출 -->
  created_date as registeredDate, <!-- Board.setRegisteredDate() 호출 -->
  view_count viewCount            <!-- Board.setViewCount() 호출 -->
  from x_board
</select>
```

그러나 이렇게 `select`를 할 때마다 컬럼명에 일일이 별명을 붙이는 것은 귀찮은 일이다. 이를 손쉽게 해주는 `<resultMap>` 태그가 있다. 이 태그가 하는 일은 **컬럼명과 자바 객체의 프로퍼티 명을 미리 연결**하는 것이다.  `<resultMap>`의 `type` 속성에는 자바 객체의 클래스명 혹은 별명을 넣고, `id`에는 연결 정보를 가리키는 식별자를 지정한다. `<result>` 태그의 `column` 속성에는 컬럼명을, `property` 속성에는 자바 객체의 프로퍼티명을 지정한다. 단, primary key 컬럼인 경우 `<result>` 태그 대신 `<id>` 태그를 사용한다. id 로 지정된 컬럼값이 같을 때는 같은 값으로 취급한다. 이때, **컬럼명과 프로퍼티명이 같을 때는 `<result>`로 지정하지 않아도 된다.**

```xml
<resultMap type="Board" id="BoardMap">
  <id column="board_id" property="no"/>
  <!--  컬럼명과 프로퍼티명이 같을 때는 result 로 지정하지 않아도 된다. -->
  <!-- <result column="title" property="title"/> -->
  <result column="contents" property="content"/>
  <result column="created_date" property="registeredDate"/>
  <result column="view_count" property="viewCount"/>
</resultMap>
```

위에서 정의한 연결 정보를 사용하고 싶다면, `resultMap="컬럼과 프로퍼티의 연결을 정의한 resultMap 아이디"`를 설정하자. 

```xml
  <select id="selectBoard" resultMap="BoardMap">
    select 
      board_id, <!-- BoardMap의 연결정보를 참조하기 때문에 별명을 주지 않아도 된다. -->
      title, 
      contents, 
      created_date,
      view_count 
    from x_board
  </select>
```

---

**만약 `setter()`에 접근 제어자를 걸었을 때는 어떻게 될까?** 이게 궁금해서 기존의 bitcamp-java-project의 Board 클래스에 있는 `setTitle()` 메서드를 `private`으로 접근제어자를 걸어 두고, 실행문 안에 `"setTitle()"`이라는 문자열을 출력하는 코드를 두어, `setTitle()`이 호출되는지 확인하고자 하였다.

```java
private void setTitle(String title) {
    System.out.println("setTitle()");
    this.title = title;
  }
```

실행 결과는 다음과 같았다.

```console
번호, 제목, 작성자, 등록일, 조회수
setTitle()
setTitle()
setTitle()
setTitle()
setTitle()
setTitle()
8, this is from hayeon, hayeon, 2020-11-11, 3
7, dkdkd, hayeon, 2020-11-06, 0
6, title, hayeon, 2020-11-06, 0
5, haha, hayeon, 2020-11-05, 0
2, 222, hayeon, 2020-11-03, 0
1, hihi, hayeon, 2020-11-03, 2
```

즉 `private`으로 `setter`를 설정해도 mybatis는 `setTitle()` 메서드를 호출할 수 있었다. 이게 어떻게 가능할까? 강사님께서는 아마 mybatis는 내부적으로 Reflection API를 사용할 것이라고 하셨다. Reflection API에는 메서드 객체를 얻을 수 있는 `getDeclaredMethod()` 메서드가 있다. (`getMethod()`는 `public` 메서드만을 가져오는 반면, `getDeclaredMethod()`는 접근제어자가 어떤 것이든 모두  가져온다.) 이를 `Method` 객체로 가져와 `invoke()` 메서드를 호출하면 해당 메서드를 호출할 수 있다.

다만, 접근제어자가 `public`이 아닌 경우`setAccessible(true)`로 설정을 함으로써 접근할 수 있도록 강제로 설정하는 작업을 해줘야지 정상적으로 `invoke()`할 수 있다. 

`Reflection API`를 사용하면 접근제어자가 걸리든 말든 접근할 수 있다니.. 게다가 특정 메서드를 직접 호출하는 것이 아니라 `Method` 객체에 담아 `invoke()`로 호출할 수 있다는 것도 상당히 충격이었다. 강사님께서는 일부 개발자들은 Reflection API의 이러한 특징 때문에 Reflection API가 객체지향을 무너뜨린다고들 하며 꺼려한다고 말씀하셨다. (그럴 만도 하다)

아무튼 종합해보면 우리는 mybatis가 다음 코드처럼 돌아갈 거라고 짐작할 수 있다.

```java
Board b = new Board();
Method m = Board.class.getDeclaredMethod("setTitle", String.class);
m.setAccessible(true);
m.invoke(b, "오호라!");
```

---

xml의 태그를 찾아서 읽어서 처리하는 애가 xml parser이다. 이 파서는 `<` 기호를 만나면 태그가 시작하는 줄 알고 xml 문법 오류인 줄 안다. 따라서 parser에게 



```xml
    <![CDATA[
    select 
      board_id,
      title, 
      contents, 
      created_date,
      view_count 
    from x_board
    where board_id < #{ohora}
    ]]>
  </select>
```

이렇게 할 수도 있다.

```xml
  <select id="selectBoard1" 
          resultMap="BoardMap" 
          parameterType="int">
    select 
      board_id,
      title, 
      contents, 
      created_date,
      view_count 
    from x_board
    where board_id &lt; #{ohora}
  </select>
```

`%lt`라는 xml 상수값을 사용한다. (less than) 이렇게 하면 알아보기 어려우니 그냥 `<![CDATA[` 와 `]]>`로 감싼다. 이 안에 있는 문자열로 취급하라는 말.



페이징 처리를 위한 것

```java
// Mybatis - SQL에 파라미터 지정하기: Map에 값을 담아 넘기기

public class Exam0212 {

  public static void main(String[] args) throws Exception {
    InputStream inputStream = Resources.getResourceAsStream(//
        "com/eomcs/mybatis/ex02/mybatis-config04.xml");
    SqlSessionFactory factory = //
        new SqlSessionFactoryBuilder().build(inputStream);

    SqlSession sqlSession = factory.openSession();

    // SQL을 실행할 때 파라미터 값을 전달하려면
    // 두 번째 파라미터로 전달해야 한다.
    // 여러 개의 값을 전달해야 한다면,
    // Map 객체에 담아 전달하라!
    // 또는 도메인 객체(ex: Board, Lesson 등)에 담아 전달하라!

    // 예) 페이징 처리를 위한 시작 인덱스와 개수를 파라미터로 넘겨라.
    HashMap<String, Object> params = new HashMap<>();
    params.put("startIndex", 6);
    params.put("size", 3);

    List<Board> list = sqlSession.selectList(//
        "BoardMapper.selectBoard3", params);

    for (Board board : list) {
      System.out.printf("%d, %s, %s, %s\n", //
          board.getNo(), //
          board.getTitle(), //
          board.getContent(), //
          board.getRegisteredDate());
    }

    sqlSession.close();
  }
}
```



오라클 페이징

https://m.blog.naver.com/wideeyed/221796538283

mssql 페이징

https://ggmouse.tistory.com/198

mysql 페이징

https://needjarvis.tistory.com/259

페이징 리밋



개수가 3개면, 8이 4번째 페이지의 시작 인덱스. 3번째까지의 개수(3 곱하기 3 )가 4번째 페이지의 시작 인덱스. 페이지의 시작 인덱스는 이전까지의 페이지 개수 x 보이는 게시글 개수 즉 이전까지의 게시물 개수이다. 

```java
0 1 2 3 4 5 6 7 8 9 10
```



시작 위치와 , 나올 개수

``` xml
  <select id="selectBoard3" 
          resultMap="BoardMap" 
          parameterType="map">
    select 
      board_id,
      title, 
      contents, 
      created_date,
      view_count 
    from x_board
    limit #{startIndex}, #{size}
  </select>
```

그러나 원하는 것은 값을 넣는게 아니라 sql문의 일부를 바꾸고 싶은 것이다. 그러면 order by `${}`에 아니라 값이 아니라 그대로 넣어진다. 그러나 이것을 쓰면 검수 통과를 하지 못한다. 이것 때문에 sql 삽입 공격이 가능해지기 때문이다. 프로그램에서 입력한 값을 집어넣는 것은 몰라도 사용자가 입력한 값을 그대로 집어넣는다면 삽입공격에 취약해진다.

그러나 이것을 사용할 곳이 있는데, 정렬할 때 사용자가 선택한 것에 따라서 프로그램에서 컬럼명을 설정해서 정렬 순서를 다르게 지정할 수 있다. 



```sql
    select 
      board_id,
      title, 
      contents, 
      created_date,
      view_count 
    from x_board
    order by #{colname} asc
```
`#{}`는 값을 삽입할 때 사용하고, `${}`는 SQL문을 삽입할 때 사용한다. 위 문장에 파라미터 값을 넣으면 다음과 같다. `order by 'title'` 	 

```sql
MariaDB [studydb]> select * from x_board order by 'okok' desc;
+----------+--------------+--------------+---------------------+------------+
| board_id | title        | contents     | created_date        | view_count |
+----------+--------------+--------------+---------------------+------------+
|        1 | 제목1        | 내용         | 2020-11-11 10:53:19 |          0 |
|        2 | 제목2        | 내용         | 2020-11-11 10:53:19 |          0 |
|        3 | 제목3        | 내용         | 2020-11-11 10:53:19 |          0 |
|        4 | 제목4        | 내용         | 2020-11-11 10:53:19 |          0 |
|        5 | 제목5        | 내용         | 2020-11-11 10:53:19 |          0 |
|        6 | 제목6        | 내용         | 2020-11-11 10:53:19 |          0 |
|        7 | 제목이래요!4 | 내용이래요!4 | 2020-11-11 13:49:06 |          0 |
+----------+--------------+--------------+---------------------+------------+
```

mariaDB는 order by 뒤에 문자열이 오면 order by 자체를 무시한다. 즉 이건 mybatis 문제가 아니라 order by 자체를 무시하게 된다. mybatis에서는 `#{}` 로 지정된 값이 들어간다.



> BoardMapper05

```xml
  <!-- selectList(sqlid, string) --> 
  <select id="selectBoard1" 
          resultMap="BoardMap" 
          parameterType="string">
    select 
      board_id,
      title, 
      contents, 
      created_date,
      view_count 
    from x_board
    order by #{colname} asc
    <!-- #{}는 값을 삽입할 때 사용하고, 
         ${}는 SQL문을 삽입할 때 사용한다. -->
  </select>
```





> BoardMapper08

update SQL을 실행할 때 update 태그 대신에 insert/delete 태그를 사용해도 된다. mybatis는 SQL을 찾을 id 값으로 찾기 때문이다. 그러나 유지보수를 위해 가능한 일관된 이름을 사용하는 것이 좋다. 즉 insert SQL문은 insert 태그에 넣고, update SQL문은 update 태그에 넣자.


#### Delete SQL 실행하기

> Exam0260

delete SQL 실행할 때는 **먼저 자식 테이블의 데이터를 지우고**, 부모 테이블의 데이터를 지워야 한다. foreign 키가 걸려 있기 때문이다. 

```java
SqlSession sqlSession = factory.openSession();

// 먼저 자식 테이블의 데이터를 지운다.
int count = sqlSession.delete("BoardMapper.deleteBoardFile", 3);
System.out.println(count);

// 그런 후 부모 테이블의 데이터를 지운다.
count = sqlSession.delete("BoardMapper.deleteBoard", 3);
System.out.println(count);

sqlSession.commit();
// commit 명령을 내리지 않으면 insert/update/delete을 테이블에 반영하지 않는다.
// close() 할 때 취소된다.

sqlSession.close();
```



> BoardMapper09



## dynamic SQL 다루기

### 조건문 사용 전

번호가 들어오면

```xml
  <select id="select1" resultMap="BoardMap" parameterType="int">
    select 
      board_id,
      title, 
      contents, 
      created_date,
      view_count 
    from x_board
    where board_id = #{value}
  </select>
```

번호가 들어오지 않으면

```xml
  <select id="select2" resultMap="BoardMap">
    select 
      board_id,
      title, 
      contents, 
      created_date,
      view_count 
    from x_board
  </select>
```



사용자로부터 게시글의 번호를 입력 받아 조회하고, 만약 오류가 발생하면 전체 게시글을 출력하는 프로그램이다. 

```java
// 실행 예:
// => 사용자로부터 게시글의 번호를 입력 받아 조회한다.
// => 만약 오류가 발생하면 전체 게시글을 출력한다.

Scanner keyScan = new Scanner(System.in);
System.out.print("게시글 번호? ");
String str = keyScan.nextLine();
keyScan.close();

List<Board> list = null;

try {
  // dynamic SQL 문법을 사용하기 전:
  // => 게시글 번호가 주어지면 특정 게시글만 조회하는
  // select1 SQL을 실행한다.
  list = sqlSession.selectList("BoardMapper.select1", Integer.parseInt(str));

} catch (Exception e) {
  // => 게시글 번호가 없으면 전체 게시글을 조회하는
  // select2 SQL을 실행한다.
  list = sqlSession.selectList("BoardMapper.select2");
}

for (Board board : list) {
  System.out.printf("%d, %s, %s, %d\n", //
                    board.getNo(), //
                    board.getTitle(), //
                    board.getRegisteredDate(), //
                    board.getViewCount());
}

sqlSession.close();
```

`${}`를 사용할 수도 있지만, 이는 삽입 공격에 취약하게 한다. 대신 mybatis는 조건문 역할을 하는 테이블을 제공한다.



### 조건문 사용 후

> Parameter 타입이 만약 사용자 지정 타입 (ex: Board)이라면 `#{}`안에 정확히 주어야 한다. 반면 래퍼 클래스 등이라면 아무거나 줘도 된다! 

#### dynamic sql

- 조건에 따라 sql을 달리 생성하는 것

- mybatis는 이를 위해 조건에 따라 SQL을 변경하거나, 동일한 SQL을 반복적으로 생성할 수 있는 문법을 제공한다.

if 조건문
  => 조건에 따라 생성할 SQL문을 제어할 수 있다.
  => 문법) `<if test="조건">SQL문</if>`

```xml
  <select id="select3" resultMap="BoardMap" parameterType="int">
    select 
      board_id,
      title, 
      contents, 
      created_date,
      view_count 
    from x_board
    <if test="no != null">
      where board_id = #{no}
    </if>
  </select>
```

no 값이 넘어온다면 이 문장을 실행하고, 넘어오지 않는다면 문장을 실행하지 않는다. 



### 조건문 사용

```java
// dynamic sql 다루기 - 조건문 사용 II
package com.eomcs.mybatis.ex03;

import java.io.InputStream;
import java.util.HashMap;
import java.util.List;
import java.util.Scanner;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

public class Exam0130 {

  public static void main(String[] args) throws Exception {
    InputStream inputStream = Resources.getResourceAsStream(//
        "com/eomcs/mybatis/ex03/mybatis-config.xml");
    SqlSessionFactory factory = //
        new SqlSessionFactoryBuilder().build(inputStream);

    SqlSession sqlSession = factory.openSession();

    // 실행 예:
    // => 사용자로부터 검색 키워드를 입력 받아 조회한다.
    // => 제목, 내용, 번호로 검색하기

    Scanner keyScan = new Scanner(System.in);

    System.out.print("항목(1:번호, 2:제목, 3: 내용, 그 외: 전체)? ");
    String item = keyScan.nextLine();

    System.out.print("검색어? ");
    String keyword = keyScan.nextLine();

    keyScan.close();

    // SQL 매퍼에 여러 개의 파라미터 값을 넘길 때 주로 Map을 사용한다.
    HashMap<String, Object> params = new HashMap<>();
    params.put("item", item);
    params.put("keyword", keyword);

    List<Board> list = sqlSession.selectList("BoardMapper.select4", //
        params);

    for (Board board : list) {
      System.out.printf("%d, %s, %s, %s, %d\n", //
          board.getNo(), //
          board.getTitle(), //
          board.getContent(), //
          board.getRegisteredDate(), //
          board.getViewCount());
    }

    sqlSession.close();
  }

}
```



```xml
  <select id="select4" resultMap="BoardMap" parameterType="map">
    select 
      board_id,
      title, 
      contents, 
      created_date,
      view_count 
    from x_board
    <if test="item == 1">
      where board_id = #{keyword}
    </if>
    <if test="item == 2">
      where title like concat('%', #{keyword}, '%')
    </if>
    <if test="item == 3">
      where contents like concat('%', #{keyword}, '%')
    </if>
  </select>
```

문자열 처리를 xml 파일에서 할 수 있다.



`if` 태그에서 조건을 줄 때 `test`의 속성값은 mybatis 문법을 사용한다. 그래서 `item==1`이어도 괜찮은 것이다.



### `<where>`

> ex03.Exam0110

```xml
  <select id="select5" resultMap="BoardMap" parameterType="map">
    select 
      board_id,
      title, 
      contents, 
      created_date,
      view_count 
    from x_board
    where
    <if test="no != null">
      board_id = #{no}
    </if>
    <if test="title != null">
      or title like concat('%', #{title}, '%')
    </if>
    <if test="content != null">
      or contents like concat('%', #{content}, '%')
    </if>
  </select>
```



여러 조건을 `or` 로 연결해야 할 필요가 있다. 그러나 이 기능의 가장 치명적인 문제는 번호는  위와 같은 Mapper를 사용하는 자바 코드를 실행시키면 다음과 같이 에러가 뜬다. `or` 때문이다. 번호가 null이라면 `where or title`과 같이 sql문법에 맞지 않는 번호와 제목을 입력했을 때는 결과가 잘 나온다. 그러나 번호를 제외하고 제목만 입력했을 때는 에러가 뜬다. 

```console
번호? 
제목? aaa
내용? 
Exception in thread "main" org.apache.ibatis.exceptions.PersistenceException: 
### Error querying database.  Cause: java.sql.SQLSyntaxErrorException: (conn=348) You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near 'or title like concat('%', 'aaa', '%')' at line 11
### The error may exist in com/eomcs/mybatis/ex03/BoardMapper.xml
```

![image](https://user-images.githubusercontent.com/50407047/98783101-57867780-243c-11eb-8de2-3697727a323c.png)

그러나 위와 같이 여러 조건 중에서 빠지더라도 결과가 잘 나와야 한다.



따라서 실무에서는 무조건 항목이 존재하도록 만들기도 한다. `where 1=1`를 하고 다음 항목부터는 `or`로 연결하는 것이다. 그러면 문제가 해결이 된다. 

```xml
where 1=0
<if test="no != null">
  or board_id = #{no}
</if>
<if test="title != null">
  or title like concat('%', #{title}, '%')
</if>
<if test="content != null">
  or contents like concat('%', #{content}, '%')
</if>
```

실행결과

```java
번호? 
제목? 제목
내용? 
1, 제목1, 내용, 2020-11-11, 0
2, 제목2, 내용, 2020-11-11, 0
6, 제목6, 내용, 2020-11-11, 0
7, 제목이래요!4, 내용이래요!4, 2020-11-11, 0
8, 제목이래요!4, 내용이래요!4, 2020-11-11, 0
9, 제목이래요!2, 내용이래요!2, 2020-11-11, 0
```



#### 사용 전: 조건이 빠졌을 대 문제 발생하는 경우



#### 조건이 빠졌을 때 문제 발생 해결책

그러나 이것도 문제가 있다. 조건이 없으면 아예 선택이 안된다.

#### where 사용 후

```xml
  <select id="select7" resultMap="BoardMap" parameterType="map">
    select 
      board_id,
      title, 
      contents, 
      created_date,
      view_count 
    from x_board
    <where> <!-- or/and 앞에 아무것도 없을 때 or/and 를 자동으로 제거한다. -->
	    <if test="no != null">
	      board_id = #{no}
	    </if>
	    <if test="title != null">
	      or title like concat('%', #{title}, '%')
	    </if>
	    <if test="content != null">
	      or contents like concat('%', #{content}, '%')
	    </if>
    </where>
  </select>  
  
```

- `or/and` 앞에 조건이 없을 대 `or/and`를 자동으로 제거한다.
- `where` 조건이 없을 때는 `where`를 생성하지 않는다.





```xml
  <select id="select8" resultMap="BoardMap" parameterType="map">
    select 
      board_id,
      title, 
      contents, 
      created_date,
      view_count 
    from x_board
    <trim prefix="where" prefixOverrides="OR | AND"> 
      <!-- or/and 앞에 아무것도 없을 때 or/and 를 자동으로 제거한다. -->
      <if test="no != null">
        board_id = #{no}
      </if>
      <if test="title != null">
        or title like concat('%', #{title}, '%')
      </if>
      <if test="content != null">
        or contents like concat('%', #{content}, '%')
      </if>
    </trim>
  </select>  
```

근데 `trim`을 사용할 바에는 `<where>`를 사용하는 것이 낫다. 대신 `prefix`는 아무거나 올 수 있다. `prefix`는 문장 앞에 `where`를 둔다. 그리고 `OR|AND`가 나오면 제거하겠다는 말이다. 따라서 `<where>`보다는 정교하게 사용할 수 있다.

## Mybatis 기타 기능 활용하기

### 실습

#### 1단계: fully-qualified class name에 대해 별명을 부여하기

`src/main/com/resources/com/eomcs/pms/conf/mybatis-config.xml`

클래스 이름에 대해 별명을 지정한다.

```xml
	<typeAliases>
		<typeAlias type="com.eomcs.pms.domain.Board" alias="board"></typeAlias>
		<typeAlias type="com.eomcs.pms.domain.Member" alias="member"></typeAlias>
		<typeAlias type="com.eomcs.pms.domain.Project" alias="project"></typeAlias>
		<typeAlias type="com.eomcs.pms.domain.Task" alias="task"></typeAlias>
	</typeAliases>
```

`src/main/resources/com/eomcs/pms/mapper/XxxMapper.xml` 도  찾아바꾸기 기능을 이용해 fully-qualified class name을 별명으로 대체한다.

일부 자바 클래스에 대해서 내장 별칭이 있다.  

| 별칭       | 매핑된 타입 |
| :--------- | :---------- |
| _byte      | byte        |
| _long      | long        |
| _short     | short       |
| _int       | int         |
| _integer   | int         |
| _double    | double      |
| _float     | float       |
| _boolean   | boolean     |
| string     | String      |
| byte       | Byte        |
| long       | Long        |
| short      | Short       |
| int        | Integer     |
| integer    | Integer     |
| double     | Double      |
| float      | Float       |
| boolean    | Boolean     |
| date       | Date        |
| decimal    | BigDecimal  |
| bigdecimal | BigDecimal  |
| object     | Object      |
| map        | Map         |
| hashmap    | HashMap     |
| list       | List        |
| arraylist  | ArrayList   |
| collection | Collection  |
| iterator   | Iterator    |

출처: https://mybatis.org/mybatis-3/ko/configuration.html#typeAliases



#### 2단계: 특정 패키지에 소속된 전체 클래스에 대해 별명 부여하기

```xml
<typeAliases>

  <package name="com.eomcs.pms.domain"/>
  
  <!-- 기존 각 클래스마다 별명 붙였던 방법
  <typeAlias type="com.eomcs.pms.domain.Board" alias="board"></typeAlias>
  <typeAlias type="com.eomcs.pms.domain.Member" alias="member"></typeAlias>
  <typeAlias type="com.eomcs.pms.domain.Project" alias="project"></typeAlias>
  <typeAlias type="com.eomcs.pms.domain.Task" alias="task"></typeAlias>
   -->

</typeAliases>
```



```java
Class clazz = Board.class;
Method m = clazz.getMethod()
```



### board/search 커맨드



**BoardListCommand**

```java
List<Board> list = boardDao.findAll(null);
```

**BoardSearchCommand**

```java
List<Board> list = boardDao.findAll("%" + keyword + "%");
```

**BoardDao**

```java
List<Board> findAll(String keyword) throws Exception;
```

**BoardDaoImpl**

```java
  @Override
  public List<Board> findAll(String keyword) throws Exception {
    try (SqlSession sqlSession = sqlSessionFactory.openSession()) {
      return sqlSession.selectList("BoardDao.findAll", keyword);
    }
  }
```

**BoardMapper.findAll**

```xml
  <select id="findAll" resultMap="BoardMap" parameterType="string">
    select 
      b.no, 
      b.title, 
      b.cdt, 
      b.vw_cnt, 
      m.no writer_no, 
      m.name
    from 
      pms_board b 
      inner join pms_member m on b.writer=m.no
    <if test="keyword != null">
   	  where 
   	  	b.title like #{keyword}
   	  	or b.content like #{keyword}
   	  	or m.name like #{keyword}
    </if>
    order by 
      b.no desc
  </select>
```

### /project/search

`findByKeyword(Map<String, Object> values)`



- ProjectMapper의  findBy



마이바티스 `if` 태그를 사용하여 동적 SQL을 작성한다.

```console
명령> /project/search
항목 (1:프로젝트명, 2:관리자명, 3:팀원, 그외: 전체)? 1
검색어? java
번호 ~~

```



**ProjectMapper**

```xml
<select id="findByKeyword" parameterType="map" resultMap="ProjectMap">
  select
		p.no,
		p.title,
		p.sdt,
		p.edt,
		m.no owner_no,
		m.name owner_name,
		mp.member_no,
		m2.name member_name
	from
		pms_project p
		inner join pms_member m on p.owner=m.no
		left outer join pms_member_project mp on p.no=mp.project_no
		left outer join pms_member m2 on mp.member_no=m2.no 
	<if test="item == 1">
  	  where 
  	  	p.title like concat('%', #{keyword}, '%')
   </if>
   <if test="item == 2">
  	  where 
  	  	m.name like concat('%', #{keyword}, '%')
   </if>
   <if test="item == 3">
  	  where 
  	  	m2.name concat('%', #{keyword}, '%')
   </if>
	order by p.no desc
</select>
```

#### 5단계: 프로젝트 상세 검색 기능을 추가한다.

Mybatis의 `where` 태그를 사용하여 동적 sql을 작성한다.

```console
명령> /project/detailSearch
항목 (1: )
```

>  국가기관(eGov) 프로젝트에서 사용하는 라이브러리
>
> - presentation layer: 화면을 보여줄 때 (Ajax Support, Validation(입력 유효값 검사)
> - business layer: Spring Framework
> - Persistant layer
>   - Data Access: iBatis, MyBatis, Hibernate
> - Foundation layer
>   - 엑셀 파일을 읽어서 엑셀 파일의 시트를 찾아내고, 시트의 열과 행에 있는 값을 추출해서 데이터베이스에 보낸다.
>     - POI, JXLS
>   - File Upload/Download: Commas FileUpload
>   - Mail: Common Email
>   - Scheduling: Quartz: 특정 시간에 해당되는 객체의 함수 호출해주는 라이브러리

> 스타트업 취업 관련 이야기: 1차 펀딩 받았을 때는 외부 전문가에게 스톡옵션을 주는 거지 신입 때는 스톡옵션을 주지 않는다. 전문가 팀이 들어와도 자존심 상하거나 밀려난다고 생각하지 않고, 거기에서 배우겠다는 마음으로 버티는 것이 중요하다. 실제로 그런 전문가 바로 옆에서 일을 배울 수 있는 것은 스타트업을 다니는 사람만이 얻을 수 있는 혜택이다. 팀 안에서는 모두 공유되기 때문이다.  초기부터 중도 포기하지 않고 1차 펀딩까지의 데모를 만들었다는 자체가 나에게 포트폴리오가 된다.

