# DB 모델링
- 모델링? 시스템을 분석하고 구조화시켜 글과 그림으로 표현한 것.
- 렌더링? 명령어를 해석하여 화면에 출력하는 것.
  예) HTML 렌더링 => HTML 태그를 해석하여 그에 해당하는 UI를 출력하는 것.
- DB 모델링? 데이터를 분석하고 구조화시켜 데이터 속성과 관계를 글과 그림으로 표현한 것.
- 목표? 데이터가 중복되지 않도록 테이블을 구조화하는 것.
- 중복 데이터를 제거 ==> 데이터의 안정성, 신뢰성을 높인다. ==> 무결성을 유지한다.





![image](https://user-images.githubusercontent.com/50407047/99189733-f47f4280-27a5-11eb-9fd9-2ffd8a0ee9ee.png)

## 주요 용어
- table(relation; entity; file)
- intension(schema; header) => 데이터 구조 설계도
- extension(instance; data) => 데이터
- row(tuple; record) => 데이터(여러 컬럼으로 이루어진) 한 개. 예) 학생
- column(attribute; field) => 데이터의 한 항목. 예) 이름, 학번, 전화번호

## 키(key)
- 데이터를 구분할 때 사용할 식별자.
- "수퍼 키(super key)"라 부르기도 한다. 
- 식별자? 
  - 데이터를 구분할 때 사용하는 값.
  - 한 개 이상의 컬럼으로 구성된다.
  - 식별자를 key라고 부른다.
  - 예) 학생(학번, 이름, 전화, 이메일, 학과, 우편번호, 주소, 주민등록번호) 
    - 학번 (O)
    - 주민등록번호 (O)
    - 이메일 (O)
    - 전화 (X)
    - (이름,전화) (O)
    - (이메일,이름) (O)
    - (이름,학과,학번) (O)
    - (이름,학과,전화) (O)
    
### 후보키(candidate key) 선정
- super key 들 중에서 선별된 최소키를 가리킨다.
- 최소키? 최소한의 컬럼 값 만으로 식별이 가능한 key.
- 수퍼 키 예)  
  - 학번 (O)
  - 주민등록번호 (O)
  - 이메일 (O)
  - (이름,전화) (O) => 이름과 전화 값을 묶은 것 보다 적은 개 수의 후보 키가 있다면 가능한 제외하라!
  - (이메일,이름) (X) => 이메일 만으로 식별 가능
  - (이름,학과,학번) (X) => 학번 만으로 식별 가능
  - (이름,학과,전화) (x) => 이름과 학과, 전화 보다 더 적은 컬럼의 후보 키가 있기 때문에 가능한 제외한다.

### 기본 키/주 키(primary key; PK) 선정
- 후보키 중에서 데이터 식별자로 사용하기 위해 선정된 키.
  - 예) 학번
- 나머지 후보키는 대안키(alternate key)라 부른다.
  - 예) 주민등록번호, 이메일, (이름,전화)
- 왜? 비록 PK는 아니지만 PK와 마찬가지로 데이터 식별자로 대체하여 사용할 수 있기 때문이다.  
### 대리 키(surrogate key)/인공 키(artificial key)
- 주 키의 컬럼의 개수가 많거나 주 키로 사용할 적절한 컬럼이 없는 경우, 일련번호와 같은 임의의 컬럼을 추가하여 PK로 만든다.
  - 예1) 게시물 첨부파일(파일명, 등록일)
    - 파일명이 중복될 수 있다.
    - 파일명과 등록일을 묶어서 PK로 사용하기에는 적절하지 않다.
    - 이런 경우 "첨부파일번호" 컬럼을 임의로 추가하여 PK로 설정한다.
    - 결론) 게시물 첨부파일(파일번호, 파일명, 등록일)
  - 예2) 수강신청(수강생이름, 수강생전화, 수강생이메일, 과목명, 결제여부, 결제유형)
    - 주 키로 사용할만한 적절한 컬럼이 없다.
    - **여러 개의 컬럼을 묶어서 주 키로 사용하자니 너무 복잡**하다.
    - 이런 경우에도 "수강신청번호"와 같은 임의의 컬럼을 추가하여 PK로 선정하는 것이 좋다.
- **주 키로 선정된 컬럼의 값은 변경될 수 없기 때문에,**
  일련번호와 같은 임의의 컬럼을 pk로 사용한다.
  - pk가 아닌 컬럼은 언제든 값을 변경할 수 있다.
  - 예1) 수강생(이름, 나이, 핸드폰, 이메일, 우편번호, 주소, 은행명, 계좌번호, 최종학력, 전공)
    - 핸드폰이나 이메일은 PK로 사용할 수 있다.
    - 그러나 핸드폰이나 이메일은 가끔 변경될 수 있다.
    - 문제는 PK로 지정된 컬럼은 한 번 사용되면 변경할 수 없다는 것이다.
    - 핸드폰과 이메일처럼 나중에 변경될 수 있는 컬럼인 경우 PK로 지정하지 않는 것이 좋다.
    - 그럼 PK 컬럼은 무엇을 사용하는가?
    - 이런 경우 "수강생번호"와 같은 임의의 컬럼을 만들어 PK로 사용한다.
  - 예2) 페이스북에 로그인할 때 이메일이나 전화번호를 사용하지만,
    실제 주키로 사용하는 것은 사용자 일련번호이다.  

### 대체 키(alternate key)
- **후보 키(candidate key) 중에서 PK로 선정된 키를 제외한 나머지 후보 키**를 가리킨다.
- 대체 키 예) 
  - 학번 (X) => 만약 학번이 PK로 선정되었다면 대체 키가 아니다.
  - 주민등록번호 (O)  => **PK 대신 사용할 수 있는 키**를 대체 키라 부른다.
  - 이메일 (O) => PK 대신 사용할 수 있는 키를 대체 키라 부른다.
- 대체 키는 테이블을 정의할 때 Unique 컬럼으로 지정된다.
  - 즉 **PK는 아니지만 값이 중복되면 안되는 컬럼**이기 때문에 **중복되지 않도록 유니크 컬럼으로 지정**한다.

### 외래 키(foreign key)
- **다른 릴레이션(테이블)의 PK 값을 저장하는 컬럼.**
- **FK가 있는 테이블을 자식 테이블(릴레이션)**이라 부르고,
  **FK가 가리키는 PK컬럼이 있는 테이블을 부모 테이블(릴레이션)**이라 부른다.
- 보통 부모-자식 관계를 맺는 테이블이 있을 때, 자식 테이블 쪽에 부모 테이블의 데이터를 가리키기 위해 외부키 컬럼을 둔다.
## [논리모델]
- 특정 DBMS를 고려하지 않고 수행하는 개념적인 모델링

### 엔티티 식별 및 속성 식별

![image](https://user-images.githubusercontent.com/50407047/99190165-6e183000-27a8-11eb-9fdc-7be9abb0bc84.png)

- **특정 값들의 집합**? **시스템에서 다루는 데이터를 식별**한다.
- 다른 말로 "테이블"이라고 한다.
- 테이블을 **구성하는 값** => **속성(attribute)** = 컬럼(column)
- 예:
  - 학생(이름,전화,이메일,주소,...)
  - 강의(강의명,설명,시작일,종료일,강의료,...)
  
### 주 키 선정(Primary Key; PK)  

![image](https://user-images.githubusercontent.com/50407047/99190152-4fb23480-27a8-11eb-926b-27249cbe54ca.png)

- **데이터를 구분할 때 사용할 식별자를 지정**한다.
- 만약 PK로 지정할 **적절한 컬럼이 없거나**, 있더라도 **여러 개의 컬럼을 묶어서 사용해야 하는 경우** **surrogate key(대리 키=인공 키) 사용**을 고려하라!

###  포함 관계 및 배타적 관계 추가

- **여러 테이블에 공통으로 포함**되는 컬럼이 있는 경우, **별도의 테이블로 정의**한다. 기본 데이터를 저장하고 있는 테이블 쪽을 부모 테이블로 한다. 다음 중 하나의 관계로 설정한다.
- 포함 관계: 여러 테이블에서 동시에 포함할 수 있는 관계
- 배타적 관계: 여러 테이블 중에서 오직 한 개의 테이블만 포함할 수 있는 관계

![image](https://user-images.githubusercontent.com/50407047/99190199-9011b280-27a8-11eb-8683-e38f2b9ae992.png)

### 제1정규화 

![image](https://user-images.githubusercontent.com/50407047/99190236-c6e7c880-27a8-11eb-8280-854d8248b3ec.png)

![image](https://user-images.githubusercontent.com/50407047/99190358-7cb31700-27a9-11eb-9269-942919591c89.png)

- 정규화? **데이터 중복을 찾아내어 별도의 테이블로 데이터를 분리**시키는 것.
- **중복 데이터 또는 중복 컬럼**을 **별도의 테이블로 분리**하여 **부모-자식 관계를 맺는다.**
- 데이터를 참조 하는 테이블이 자식테이블이고, 데이터를 갖고 있는 테이블이 부모 테이블이다.
- **자식 테이블에서는 부모 테이블의 데이터를 가리키기 위해 그 데이터의 pk값을 보관**해야 한다.
- 이렇게 **부모 테이블의 데이터에 대해 PK값을 저장하는 컬럼**을 **외부키(FK**)라 부른다.
- 중복 컬럼? 사진1, 사진2, 사진3
- 중복 데이터? 수강생 데이터, 강의 데이터, 강사 데이터, ...

### 제2정규화
- PK가 여러 컬럼으로 이루어진 경우에 수행
- 모든 일반 컬럼은 반드시 PK 컬럼에 종속되어야 한다.
  그렇지 않은 일반 컬럼이 있다면 별도의 테이블로 분리하여 부모-자식 관계를 맺는다.

### 제3정규화

![image](https://user-images.githubusercontent.com/50407047/99190426-d7e50980-27a9-11eb-8579-7d5cc35e8e4c.png)

- 어떤 컬럼이 PK가 아닌 다른 일반 컬럼에 종속되는 경우가 있다면,
  별도 테이블로 분리하여 부모-자식 관계를 맺는다.

> 우편번호가 하나로 같은데 기본주소가 다른 경우가 있다. 그래서 우편번호는 PK로 할 수 없다. 따라서 주소번호가 따로 있어야 한다.

> 실무에서는 주소 테이블은 만들지 않는다. 도로명 주소가 바뀌었다고 원래 주소가 자동으로 바뀌지는 않는다. 실무에서는 연결 못 시키고 각 사용자마다 우편번호 기본주소를 무조건 적는다. 어떤 사용자는 옛날 우편주소 기본주소. 어떤 사용자는 지금 우편번호 기본주소. 이것은 제3 정규화를 설명하기에 좋은 예라서 별도로 분리시켜서.. 주소는 오늘도 새로운 우편번호가 생길 수 있고, 기본주소가 매주 바뀐다. 주소체계가 바뀔 수 있다.



### 다 대 다 관계의 해소

- 테이블과 테이블 사이에 다 대 다 관계를 형성한다면,
  일 대 다의 관계로 변경해야 한다.
- 왜? DBMS는 물리적으로 **다 대 다 관계의 데이터**를 저장할 수 없다.
- 해결책?
  두 테이블의 관계를 저장할 테이블을 만든다. 
  "관계 테이블" 이라 부른다.
  관계 테이블은 각 테이블과 일 대 다의 관계를 맺는다.  

> 수강신청, 교육과정강사 => 과

사용자 기본 정보를 학생이 포함한다. 강사나 매니저가 학생일 수도 있다. 이것을 기본정보공유라고 한다.

점선 -> 실선: foreign key는 테이블과 테이블 사이의 관계를 형성한다. 여기서 fk는 학생 데이터를 구분하는 key이다. 이것을 identifying 관계(식별관계), non-identifying 관계 (비식별관계) 관계를 나타내는 fk를 pk(식별자)로 사용한다. FK가 PK역할도 같이 하면 그게 식별관계이다. 



### 관계의 차수 지정

![image](https://user-images.githubusercontent.com/50407047/99190501-33af9280-27aa-11eb-8c8e-203d848a1fb6.png)

- 데이터 끼리 상호 관계의 개수를 지정한다.
- 예)
1    : *  (0이상)    => FK 컬럼이 not null 이다.
1    : 1..* (1이상)  => FK 컬럼이 not null 이다.
0,1 : *  (0이상)    => FK 컬럼이 null 허용이다.
0,1 : 1..* (1이상)  => FK 컬럼이 null 허용이다.  

사용자 데이터를 입력할 때 필수적인지 아닌지의 문제이다. 나중에 회원 수정할 때 받을 것인지. 주소번호가 null이면 주소 테이블과 어떠한 관계도 맺지 않는다.  null허용? 필수 항목이 아니다. 

개념적으로 따지면 1 이상이 맞다. 데이터 입력적인 측면으로 따지면 아직 입력을 안했을 때를 고려해 0이상이다. 그러나 개념적으로 따지자./

**데이터를 입력하는 관점**: 과정을 입력할 때는 매니저가 없을 수도 있고, 배정할 때는  0또는1

**개념적인 관점**: 한 과정에는 매니저가 꼭 있어야 한다. 매니저 없이는 교육과정을 진행할 수 없다. 1

따라서 그냥 1로 해라. 

### 09. 유니크(Unique) 컬럼 지정

![image](https://user-images.githubusercontent.com/50407047/99190619-d5cf7a80-27aa-11eb-92c9-7c01c4c46450.png)

- PK는 아니지만 PK처럼 중복되어서는 안되는 컬럼이다. 
- 대체 키(alternate key) 컬럼이 유니크 컬럼이 된다.
- 즉 PK로 선정되지 않은 나머지 후보 키는 유니크 컬럼으로 지정하여 데이터가 중복되지 않도록 한다.

굳이 학교명, 주소 등까지 유니크 컬럼으로 지정하지 않는다.

Key(UK, PK)는 무조건 인덱스(색인표)를 만든다. FK는 안 만든다. 오름차순으로 정렬하는 색인표를 따로 만든다.  

은행같은 거는 유니크 컬럼으로 지정하지 말자. 너무 과도하게 하지 않는 것이 좋다. 어떤 회사는 다 걸기도 한다.

### null 허용 여부 지정

![image](https://user-images.githubusercontent.com/50407047/99190658-1e873380-27ab-11eb-8e68-630e2ec68985.png)

- 필수 입력 컬럼인지 선택 입력 컬럼인지 지정한다.

> 직급과 같은 것을 마스터 데이터라고 한다. 특별한 일이 없으면 바꿀 일이 없기 때문이다. 

### 인덱스 컬럼 지정

![image](https://user-images.githubusercontent.com/50407047/99190679-57bfa380-27ab-11eb-80d0-385c579c23e2.png)

- 데이터를 찾을 때 검색 조건으로 사용할 컬럼을 지정한다.
- 조회 컬럼으로 지정하면 그 컬럼의 값으로 색인표가 자동으로 생성되어 데이터를 찾는 속도가 빨라진다.
- 장점: **select 속도**가 빨라진다.
  단점: **insert,update,delete 할 때 마다 색인표를 갱신**해야하므로 **속도가 느리다.** 

체크를 안하고 인덱스를 추가하면 그냥 보통 검색하는 것을 위해 색인표를 만든다는 의미이다. 

부서는 인덱스를 지정하면 안된다. 보통 부서와 지점을 조인해서 데이터를 가져오기 때문이다. 보통 지점에 따른 부서를 검색하기 때문에 아무 의미가 없다. 인덱스는 값을 추가할 때마다 인덱스를 갱신하기 때문에 속도가 떨어질 수 있다. 

인덱스는 검색 속도를 높이기 위해서 미리 알파벳 순서로 정려한다. 별도 색인 데이터 변경, 입력, 삭제할 때마다 색인표 

학생 이름이 유니크면 똑같은 이름의 학생이 등록이 되지 않는다. 

## [물리모델]
- 특정 DBMS에 맞춘 물리적인 모델링

### DBMS에 맞춰서 테이블명과 컬럼명을 설정한다.

![model_21](https://user-images.githubusercontent.com/50407047/99190748-be44c180-27ab-11eb-837a-a2d1f68ede0f.png)

- DBMS에서 테이블명과 컬럼명을 작성할 때 보통 다음의 규칙에 따라 작성한다.
  예) first name(FST_NM), regist date(REG_DT), teacher assignment(TCH_ASN)
- 단어는 알파벳 3자 또는 4자로 축약해서 표현한다.
- 단어와 단어 사이는 밑 줄( _ )로 표현한다.

### 도메인(domain) 정의 및 적용

![model_22](https://user-images.githubusercontent.com/50407047/99190801-f3e9aa80-27ab-11eb-8fe4-c4c791fc8267.png)

- 비슷한 종류의 컬럼들을 묶어 새 타입으로 정의한다.
- 이점: 타입을 변경할 때 한 번에 여러 컬럼을 변경할 수 있어서 유지보수에 좋다.

> 마이SQL에는 날짜만 있고 시간은 없다.
>
> 우편번호는 숫자로 할 수 없다. 0으로 시작하는 것도 있기 때문이다. 따라서 varchar(6)으로 지정하였다. 

### 번호가 자동 증가하는 컬럼을 지정

![model_23](https://user-images.githubusercontent.com/50407047/99190829-31e6ce80-27ac-11eb-8c32-3ade28170d28.png)

- 테이블의 PK 중에서 자동으로 증가해야 하는 컬럼을 지정한다.

### 기본 값 및 제약 조건 설정
- 일부 컬럼에 대해 기본 값을 설정한다.
- 일부 컬럼의 값의 범위를 지정한다.

### 포워드 엔지니어링(forward engineering)
- 모델 ----> 코드
- 참고: 리버스 엔지니어링(reverse engineering)
  코드 ----> 모델

### 정규화
- 데이터가 중복되지 않도록 구조화시키는 것.
- 참고: 역정규화 (실행 속도를 높이기 위해 데이터 중복을 허용하는 것)
  
## 관계: 부모 테이블과 자식 테이블
### 부모 테이블
- 자식 테이블이 참조하는 데이터를 갖고 있는 테이블

### 자식 테이블
- 부모 테이블의 데이터를 참조하기 위해 그 데이터의 PK 값을 갖고 있는 테이블
- 이렇게 부모 테이블의 PK를 저장하는 컬럼을 FK(Foreign Key)라 부른다.

### 외부키(Foreign Key; FK)
- 자식 테이블에서 부모 테이블의 특정 데이터를 가리키는 컬럼이다.
- 반드시 부모 테이블의 PK 컬럼 값을 저장해야 한다.
  다른 일반 컬럼의 값은 사용할 수 없다.

## 식별 관계와 비식별 관계
### 비식별 관계(non-identifying)
- 자식 테이블의 외부키(FK)가 그 테이블에서 일반 컬럼으로 사용될 때
- 즉 관계를 표현하는 외부키가 그 테이블에서 식별자로 사용되지 않는 것을 말한다.
- FK != PK

### 식별 관계(identifying)
- 자식 테이블의 외부키(FK)가 그 테이블에서 PK 컬럼으로 사용될 때  
- 즉 관계를 표현하는 외부키가 그 테이블에서 식별자로 사용되는 것을 말한다.  
- FK == PK
- FK와 PK가 같다는 것이 아니라 FK가 PK**역할**을 한다는 말이다.



한 부모가 여러 자식을 가질 수는 있어도 한 자식이 여러 부모를 가질 수는 없다. 사진에  (교실사진번호, 사용자번호, 교실번호) 이렇게 있으면 안된다. 사용자에는 사진이 하나밖에 없으니까 따로 빼낼 필요가 없다.

디비 모델링 하기 전에 객체와 객체가 어떤 역할을 하는지 먼저 생각을 해보는 것이 좋다. db를 먼저 생각하고 코드를 짜게 되면 나중에 그에 맞게 코딩을 하게 되는데, 그러면 나중에 뒤집어 엎을 때 비용이 많이 든다. 따라서 객체에서 어떤 일을 하는 것인지 정의하는 것이 필요하다.



