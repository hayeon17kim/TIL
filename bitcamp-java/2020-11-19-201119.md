

## Application Server Architecture

현재구조: 전통적인 Client/Server Architecture

![image](https://user-images.githubusercontent.com/50407047/99622171-f29ad500-2a6c-11eb-85ed-e8bea5131aba.png)

이전에는 각자 데이터를 따로따로 관리했다. 그나마 지금 데이터만큼은 각각의 프로그램들이 공유한다는 장점이 있다.

그러나 다이렉트로 DBMS에 접근하기 때문에, 아이디와 암호를 해커가 다이렉트로 DBMS에 접근해서 망가뜨릴 수 있다. 이는 전통적인 Client/Server 아키텍처에서 변할 수 없는 문제다.

Application Server Architecture

- 외부에서 직접 DBMS 접근 불가 => 보안 강화
- 기능이 없그레이드된다고 하더라도 재설치 불필요

여기서 사용자 명령을 처리하는 것은 `Command`인데, `ServerApp`이 이 객체를 생성해서 보관, 소멸까지 담당(매니징)한다. 프로그래밍 세계에서는 이를 **컨테이너**라고 한다.



#### 1단계: 프로젝트에 라이브러리 추가하기

#### 2단계: Mybatis 설정 파일 및 SQL 매퍼 파일을 가져온다.

#### 3단계: DAO 인터페이스와 구현체를 가져온다.

- `mini-pms`

​                                                                                                                                     

#### 7단계: 리스너를 통해 DAO 객체를 준비한다

- `DataHandlerListener` 변경
  - `Mybatis` 관련 객체를 준비한다.
  - `DAO` 객체를 준비한다.

#### 8단계: 게시글 커맨드 객체를 변경한다.

데이터를 다룰 때 서비스 객체를 사용한다. 

- `com.eomcs.listener.RequestMappingListenr` 변경

  - 테스트 하는 동안 사용할 로그인 사용자 정보 

    

```java
// Command 규칙에 따라 클래스를 정의한다.
public class BoardAddCommand implements Command {

  BoardService boardService;

  public BoardAddCommand(BoardService boardService) {
    this.boardService = boardService;
  }

  @Override
  public void execute(Map<String, Object> context) {
    // 예외가 발생했을 때 출력하기 위해 in out은 try catch 바깥으로 꺼낸다.
    PrintWriter out = (PrintWriter) context.get("out");
    BufferedReader in = (BufferedReader) context.get("in");
    try {
      out.println("[게시물 등록]");

      Board board = new Board();
      board.setTitle(Prompt.inputString("제목? ", out, in));
      board.setContent(Prompt.inputString("내용? ", out, in));
      Member loginUser = (Member) context.get("loginUser");
      board.setWriter(loginUser);
      boardService.add(board);

      out.println("게시글을 등록하였습니다.");

    } catch(Exception e) {
      out.printf("작업 처리 중 오류 발생! - %s\n", e.getMessage());
    }
  }
```

**ServerApp** 
입출력 스트림을 context 맵에 보관한다.

```java
Command command = (Command) context.get(request);
if (command != null) {
  // 커맨드 객체가 사용할 입 출력 스트림을 context 맵에 보관한다.
  context.put("out", out);
  context.put("in", in);
  command.execute(context);
} else {
  out.println("해당 명령을 처리할 수 없습니다!");
}

```

