

- UX: 사용자 경험. 사용자 편의성이 있는가
  - 링크에 hover했을 때 커서가 손모양으로 바뀌지 않으면 안된다. 
- UI: 기능을 하는 화면이 있는가

- 결과화면을 먼저 보고 소스코드를 보자.

시작 연봉이 낮으면 1년 안에 이직해서 올려야 한다. 갭을 줘야 한다. 1년에 한 번씩 옮긴다. 

서비스 회사

- 인공지능 등 새로운 기술: 연구직: 석사
- 네이버 카페 등 유지보수: 석학사 안따짐

프로그램실력과 알고리즘 실력은 다르다. 시험을 위한 공부를 해야 한다. 

![image](https://user-images.githubusercontent.com/50407047/100170081-37f55180-2f08-11eb-8e4e-b430ada61c01.png)

- HTML 선언: `<!DOCTYPE html>`
- 태그는 계층구조로 되어 있다. 시작태그와 끝태그라고 하고, 태그 사이의 것은 HTML 콘텐츠라고 한다.
- `<head>` 태그와 `<body>` 사이에 컨텐츠를 넣는다고 해도, 브라우저는 관대하게 봐준다. 그러나 브라우저가 관대하다고 해서 그것이 옳다고 생각하면 안된다. html에 head와 body만 존재해야 한다. `<body>` 안에는 몸체 컨텐츠가 있다. `<head>`: 실제 출력되는 내용에 대한 부가정보
- `<html>` 요소는 HTML문서 루트(최상단요소)를 나타내며, 루트 요소라고도 부른다. 모든 다른 요소는 `<html>`요소의 후손이어야 한다.
- html은 이와 같이 노드들의 연결로 표현한다. 이는 가지치기와 비슷하다고 해서 **트리**라고 부른다.
- `DOCUMENT Object Model`:**DOM** 트리: 이걸 하나의 객체처럼 표현하는데 이걸 DOM 트리라고 부른다. 
- tag = element

> [DOM](https://developer.mozilla.org/ko/docs/Web/API/Document_Object_Model/%EC%86%8C%EA%B0%9C)이란? 문서 객체 모델(The Document Object Model)은 HTML, XML 문서의 프로그래밍 interface 이다. DOM은 문서의 구조화된 표현(structured representation)을 제공하여 프로그래밍 언어가 DOM 구조에 접근할 수 잇는 방법을 제공하여 그들이 문서 구조, 스타일, 내용 등을 변경할 수 잇게 돕는다. DOM은 구조화된 nodes와 property와 method들이 갖고 있는 objects로 문서를 표현한다. 이들은 웹 페이지를 스크립트 또는 프로그래밍 언어들에서 사용될 수 있게 연결시켜주는 역할을 담당한다. 웹 페이지는 일종의 문서(document)이다. 이 문서는 웹 브라우저를 통해 그 내용이 해석되어 웹 브라우저

구글 검색 엔진이 이 문서를 읽어들여서 문서의 내용이 무엇인지 판단을 내린다. 만약 제목을 `<h1>` 등 헤더 태그가 아니라 `<p>` 태그를 사용한다면, 구글 검색 엔진에서 제목인지 아닌지 판단할 길이 없다. 즉 데이터의 의미와 역할을 표현하는 태그를 사용하자. 사용자가 볼 때는 똑같지만 검색을 할 때는 다르다. 따라서 검색에 잘 걸리기 위해서는 의미 있는 태그를 사용한다.이게 바로 시멘틱 웹이다. 데이터를 표현할 때 아무 태그 쓰지 말고 그 데이터의 의미를 잘 표현할 수 있는 태그를 사용한다. 

**시멘틱 html**

- 검색 엔진은 의미론적 마크업을 페이지의 검색 랭킹에 영향을 줄 수 있는 중요한 키워드로 간주한다. 
- 시각 장애가 있는 사용자가 화면 판독기로 페이지를 탐색할 때 의미론적 마크업을 푯말로 사용할 수 있다.
- 의미 없고 클래스 이름이 붙여져있거나 그렇지 않은 끊임없는 `div`들을 탐색하는 것보다, 의미 있는 코드 블록을 찾는 것이 훨씬 쉽다.
- 개발자에게 태그 안에 채워질 데이터 유형을 제안한다.
- 의미있는 이름짓기(Semantic naming)은 적절한 사용자 정의 요소 / 구성 요소의 이름짓기(naming)를 반영한다.



- HTML에서 줄바꿈 기호를 사용하는 것은 아무런 의미가 없다. 
- 원래 HTML은 논문을 읽는 용도로 만들어졌다.

- `<p>`: paragraph(문단): 같은 주제의 내용

![image](https://user-images.githubusercontent.com/50407047/100173380-bdc7cb80-2f0d-11eb-9f54-d2b4e2cfafc6.png)

```html
<h1>Lorem ipsum</h1>
<h2>dolor sit amet</h2>
<hr />
<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p>
<br />
<p>In porttitor lorem at justo feugiat aliquet.</p>
<br />
<p>Nunc id massa at magna semper hendrerit.</p>
<br />
<p>Vivamus rhoncus eros vel ante suscipit non facilisis risus rutrum.</p>
```

여기서 `<hr/>`, `<br/>`을  `<hr>`, `<br>`로 바꿔도 정상적으로 보인다.

- 기존 HTML4.3: 시멘틱하게 작성하지 않아 검색에 잘 걸리지 않는 문서가 많다.

- XHTML의 탄생: html문서에 xml 문법을 적용하여 강력하게 문법 제한을 하자는 요구가 나왔다. 그래서 기존 HTML4에 xml문법을 더한 것이 XHTML이다.
- 그러나 이것이 개발자들에게는 받아들여지지만, 디자이너나 일반인에게는 엄격한 작성이 받아들여지지 않는다. 이전에는 문법이 헐렁해도 출력이 잘 되었는데 안되기 시작하니까 아예 XHTML을 사용하지 않아 망했다.
- HTML5은 XHTML처럼 써도 되고, 이전 HTML4.3처럼 사용해도 관대하게 다 허용하였고, 인기가 많아졌다. 추가적으로 의미 있는 HTML태그들을 추가했다.

- `<br>`: 강제 줄바꿈. 기본은 화면 옆으로 계속 늘어나다가 화면 끝이 닿으면 아래로 내려지는 구조이다. 줄바꿈이 없다.



```html
<a href="http://hanbit.co.kr">Hanbit</a><br />
<a href="https://github.com/">Github</a><br />
```

- 이 사이트가 어디에 정박(닿: anchor)하고 있는지 그 정박지의 주소를 가리킨다.

- `href` 속성: html reference(hypertext reference)
- 이걸 클릭하면 이 사이트로 요청을 보낸다.
- 보통 주소창에 주소를 쳐야 요청을 보내고 응답을 받는다. 그러면 주소를 치는 대신 **자동으로 주소창에 해당 URL을 넣어서 대신해서 요청하는 것이 링크**이다. a 엘리먼트이다. **우리를 대신해서 HTTP 요청**을 한다. 게시글 목록에서 제목을 누르면 `/detail` 페이지로 가도록 만들 때 사용한다.
- 태그로 지정된 URL로 요청을 하는 일을 한다.

**엘리먼트의 종류**

- 블록 엘리먼트: 콘텐츠가 꽉 차든 안차든 한 줄을 독점한다. `<p>`
- 인라인 엘리먼트: `<a>` 

### `<a>` 태그로 문서 내 특정 위치로 이동할 수 있다.

같은 위치 내 바로 이동할 수 있다. 우선 해당 위치마다 `id`를 부여한다. 아이디는 숫자로 시작하지 않고 영문으로 시작하고 중간에 단어와 단어 사이를 구분할 때 `_`가 들어갈 수는 있다.

> 마크다운 문법에서는 헤더에 `id`를 자동으로 부여한다. 따라서 해당 헤더 위치로 링크를 걸 수 있는 것이다. 
>
> HTML, CSS로 무엇을 할 수 있는지 파악할 수 있어야 한다.

### 인라인 텍스트

![image](https://user-images.githubusercontent.com/50407047/100174707-46e00200-2f10-11eb-9591-2586f3b041d1.png)

```html
	<h1>
		Lorem ipsum <b>dolor sit</b> amet
	</h1>
	<h1>
		Lorem ipsum <i>dolor sit </i>amet
	</h1>
	<h1>
		Lorem ipsum <small>dolor sit</small> amet
	</h1>
	<h1>
		Lorem ipsum <sub>dolor</sub>﻿ sit amet
	</h1>
	<h1>
		Lorem ipsum <sup>dolor sit</sup> amet
	</h1>
	<h1>
		Lorem ipsum <ins>dolor sit</ins> amet
	</h1>
	<h1>
		Lorem ipsum <del>dolor sit</del> amet
	</h1>
	<hr />
    Lorem ipsum <b>dolor sit</b> amet<br/>
    Lorem ipsum <i>dolor sit </i>amet<br/>
    Lorem ipsum <small>dolor sit</small> amet<br/>
    Lorem ipsum <sub>dolor</sub> sit amet<br/>
    Lorem ipsum <sup>dolor sit</sup> amet<br/>
    Lorem ipsum <ins>dolor sit</ins> amet<br/>
    Lorem ipsum <del>dolor sit</del> amet<br/>
```

![image](https://user-images.githubusercontent.com/50407047/100174814-87d81680-2f10-11eb-9220-6825ddf9bfce.png)

```html
<ruby>
  <span>大韓民國</span>
  <rt>대한민국</rt>
</ruby>
```

HTML5에서는 개발자가 임의적으로 태그를  만들어도 허락한다. 단 웹 브라우저에서 출력할 때는 기본 디폴트값이 적용된다.

![image](https://user-images.githubusercontent.com/50407047/100174981-e2717280-2f10-11eb-9345-7f463cc2eaca.png)

```html
<food>Custom food Tag</food>
<rice>Custom rice Tag</rice>
```

아무런 의미가 없는 것이 아니다! 여기에 스타일은 개발자가 임의로 지정하면 된다.

![image](https://user-images.githubusercontent.com/50407047/100175131-2bc1c200-2f11-11eb-831e-114ffa0ce0f0.png)

```html
<style>
  food {
    display: block;
    font-weight: bold;
    font-style: italic;
    color: crimson;
    font-size: 2em;
  }
</style>
<body>
    <food>Custom food Tag</food>
    <rice>Custom rice Tag</rice>
</body>
```



콘텐츠를 구성할 때 HTML을 사용한다면, CSS(Cascading Style Sheet)는

> Cascading: 폭포수처럼 떨어진다. 설정이 그 다음 자식 태그, 그 다음 자식 태그에도 적용된다. 그리고 그 스타일이 하나의 시트처럼 관리할 수 있다. 

![image](https://user-images.githubusercontent.com/50407047/100175508-dd60f300-2f11-11eb-9a88-890c7c4c1a49.png)

![image](https://user-images.githubusercontent.com/50407047/100175640-23b65200-2f12-11eb-924e-b05e54a5073f.png)

```html
<ul>
  <li>HTML5
    <ol>
      <li>Multimedia Tag</li>
      <li>Connectivity</li>
      <li>Device Access</li>
    </ol>
  </li>
  <li>CSS3
    <ul>
      <li>Animation</li>
      <li>3D Transform</li>
    </ul>
  </li>
</ul>
```

- `ol`: ordered list
- `ul`: unordered listimage
- `li`: list item



데이터의 대분류와 소분류

- `dl`: 

HTML 태그 안에 스타일을 넣지 말아야 한다. 

![image](https://user-images.githubusercontent.com/50407047/100178204-c96bc000-2f16-11eb-8a3e-6ec0a843397f.png)

```html
<table border="1">
  <caption>Caption</caption>
  <colgroup>
    <col span="2" style="background: red" />
    <col style="background: blue" />
  </colgroup>
  <thead style="background: green">
    <tr>
      <th>Table Header</th>
      <th>Table Header</th>
      <th>Table Header</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Table Data</td>
      <td>Table Data</td>
      <td>Table Data</td>
    </tr>
    <tr>
      <td>Table Data</td>
      <td>Table Data</td>
      <td>Table Data</td>
    </tr>
    <tr>
      <td>Table Data</td>
      <td>Table Data</td>
      <td>Table Data</td>
    </tr>
  </tbody>
  <tfoot style="background: yellow">
    <tr>
      <td>Table Data</td>
      <td>Table Data</td>
      <td>Table Data</td>
    </tr>
  </tfoot>
</table>
```

개발자도구: 완전하게 재구성한 HTML이다. 원래 소스는 `마우스우클릭>오리지널소스코드`

- tbody 태그를 넣지 않아도 재구성할 때 `tbody`를 자동으로 넣는다. 
- 원래 소스를 HTML규격에 맞춰 재구성한다.
- 그러다 보면 없던 태그가 자동으로 들어가게 되어 이싿.

- 자바 스크립트로 태그를 찾을 때 먼저 태그를 찾으면 안된다. table 밑에 tbody밑에 애들을 찾기 때문에 재구성한 것이 중요하다.

![image](https://user-images.githubusercontent.com/50407047/100178276-e86a5200-2f16-11eb-9cfb-86c09e807703.png)

```html
<table border="1">
  <tr>
    <!-- 열을 3칸 병합 -->
    <th colspan="3">Table Data</th>
    <!-- 행을 3칸 병합 -->
    <th rowspan="3">Table Data</th>
  </tr>
  <tr>
    <td>Table Data</td>
    <!-- 행을 2칸 병합 -->
    <td rowspan="2">Table Data</td>
    <td>Table Data</td>
  </tr>
  <tr>
    <td>Table Data</td>
    <!-- 이미 점유된 td는 넘어간다!!! -->
    <td>Table Data</td>
  </tr>
</table>
```

이 `td`는 행을 병합한다. 이때 `rowspan`을 사용한다. **이미 점유된 td는 넘어간다.** 만약 행과 열로 병합을 하고 싶다면 ` colspan`과 `rowspan` 속성 값을 동시에 설정하면 된다.

> 스판: 늘어나는 성질의 옷

즉 표는 1 행씩 만들면 된다.

- 페이지 소스 보기에서 보여지는 코드는 서버로부터 전달받은 코드이다.
- 개발자 도구의 Elements에서 확인 가능한 코드는 서버에서 전달받은 코드에서 JavaScript등을 실행하여 변환된 코드이다. DOM을 이용해 html에서 원하는 attribute에 접근하여 속성을 변화시킨다.

## Img

![image](https://user-images.githubusercontent.com/50407047/100186402-44d66d00-2f29-11eb-9303-fae693b04d19.png)

**루트 사진**

```html
<!-- 잘못된 사진 경로를 준다 -->
<img src="../photo.jpeg" alt="연예인" width="300" />
<img src="Nothing" alt="그림이 존재하지 않습니다." width="300" />
```

그림이 출력이 되지 않으면 그림 대신 옆에 alt 속성값이 나온다. (대안 텍스트)

![image](https://user-images.githubusercontent.com/50407047/100182957-22405600-2f21-11eb-98fb-77abdf865a11.png)

그리고 시각 장애인을 위해 화면 판독기가 이 텍스트를 읽는다.

**다른 서버의 사진**

```html
<img src="http://placehold.it/300x200" />
<img src="http://placehold.it/200x150" />
<img src="http://placehold.it/100x100" />
```

이미지 파일을 한 번에 받는 것이 아니라 html을 받은 다음에 뿌리는 도중에 이미지 태그를 만나면 별도 스레드를 띄워서 걔를 통해서 별도 요청하고 다운로드 받아주면 그 스레드가 해당 화면에 뿌려주는것을 한다.

요청이 한 번만 발생하는 것이 아니라 여러번 발생한다. 

## audio

값과 관계 없이 속성의 존재 여부만 체크하는 속성

![image](https://user-images.githubusercontent.com/50407047/100183712-faea8880-2f22-11eb-9980-d6c499d69e76.png)

```html
<audio src="Kalimba.mp3" controls="controls"></audio>
```

```html
<audio src="Kalimba.mp3"></audio>
```

위 코드는 화면에 아무것도 출력되지 않는다.

```html
<audio src="Kalimba.mp3" controls></audio>
```

위 코드는 화면에  `controls="controls"` 를 한 것과 같이 화면에 음악재생기가 출력된다. html에서 속성이 존재하는 것만으로 의미가 있는 경우가 있다. audio의 controls 속성이 해당된다. 값이 어떤지는 상관이 없다. 

```html
<audio src="Kalimba.mp3" controls="false"></audio>
```

이렇게 해도 controls 속성을 controls로 했을 때와 같다.

보통 속성명과 속성값이 같으면 **값과 관계 없이** **속성의 존재 여부만 체크**한다.

**autoplay** 속성

```html
<audio src="Kalimba.mp3" controls="controls" autoplay="autoplay"></audio>
```

보통 브라우저에서 이 속성을 막아 놓았다. 자동으로 음악이 재생하면 곤란할 수 있기 때문이다.

```html
<audio src="Kalimba.mp3" controls autoplay></audio>
```

속성이 존재하는 것만으로 의미가 있기 때문에 이렇게 적어도 된다.

**source 태그**

```html
<audio controls="controls">
  <source src="Kalimba.mp3" type="audio/mp3" />
  <source src="Kalimba.ogg" type="audio/ogg" />
</audio>
```

똑같은 음성 파일을 두개를 둔다. 브라우저, 운영체제, 디바이스에 따라서 플레이할 수 있는 것을 고려하여 여러 개의 소스를 넣을 수 있다. 가 첫번째를 플레이할 것이고, 플레이할 수 없다면 다음 것을 플레이할 것이다.

**동영상**
![image](https://user-images.githubusercontent.com/50407047/100184609-3c7c3300-2f25-11eb-9052-fd7dd6209aee.png)

```html
<video poster="http://placehold.it/640x360" width="640" height="360" controls="controls">
  <source src="Wildlife.mp4" type="video/mp4" />
  <source src="Wildlife.webm" type="video/webm" />
</video>
```

### 외부 라이브러리

- CSS 라이브러리
  - `<link>`는 끝태그 안 적는 것이 규칙
- 자바스크립트 라이브러리
  - `<script>`는 끝태그 적는 것이 규칙
  - 자바스크립트 함수, 객체, 변수들이 들어 있음

```html
<head>
  <title>Video.js Basic</title>
  <link href="http://vjs.zencdn.net/4.9/video-js.css" rel="stylesheet">
  <script src="http://vjs.zencdn.net/4.9/video.js"></script>
</head>
<body>
  <video controls="controls" width="640" height="360"
         class="video-js vjs-default-skin" data-setup="{}">
    <source src="Wildlife.mp4" type="video/mp4" />
    <source src="Wildlife.webm" type="video/webm" />
  </video>
</body>
```

CSS는 가져다 쓰는 것이다. 

```html
<video width="640" height="360" controls="controls">
  <source src="Wildlife.mp4" type="video/mp4" />
  <source src="Wildlife.webm" type="video/webm" />
  <track kind="subtitles" src="track.srt" srclang="ko" label="Korean" />
  <track kind="subtitles" src="track.srt" srclang="en" label="English" />
  <track kind="subtitles" src="track.srt" srclang="jp" label="Japanese" />
  <track kind="subtitles" src="track.srt" srclang="ch" label="Chinese" />
</video>
```

## `form`

```
<input type="text" name="search" />
<input type="submit" />
```

여기서 이 이름으로 서버에게 값을 보낸다.

`http://localhost:8080/bitcamp-web-project/source/ch2/2-35.html?search=`

만약 이 속성을 추가하지 않는다면 submit 버튼을 눌렀을 때 주소창이 `http://localhost:8080/bitcamp-web-project/source/ch2/2-35.html?` 이렇게만 변한다.

속성을 추가한다면



### 웹 브라우저가 웹 서버에 값을 보내는 방법

![image](https://user-images.githubusercontent.com/50407047/100187233-09d53900-2f2b-11eb-8da8-2ea5ae69223b.png)

HTTP 프로토콜은 중간에 주거니 받거니가 안되고 딱 한번 요청하고 딱 한번 응답한다. 

![A basic HTTP request](https://mdn.mozillademos.org/files/13687/HTTP_Request.png)

![img](https://mdn.mozillademos.org/files/13691/HTTP_Response.png)

입력 폼은 한번의 데이터 전달에 적합하다.

### get

```html
<form method="get">
  <input type="text" name="search" />
  <input type="submit" />
</form>
```

안적어도 원래 요청을 get이다.

`http://localhost:8080/bitcamp-web-project/source/ch2/2-36-1.html?search=xxx`

### post

```html
<form method="post">
  <input type="text" name="search" />
  <input type="submit" />
</form>
```

포스트 방식은 yyy를 적고 제출햇는데도 주소창에 보이지 않는다.

`http://localhost:8080/bitcamp-web-project/source/ch2/2-36-2.html`



요청 구조

- 리퀘스트 라인

콘텐트 타입과 콘텐트 length도 없다. url에 붙어서 가기 때문이다. 

```http
GET / HTTP/1.1
Host: developer.mozilla.org
Accept-Language: fr
```

```http
HTTP/1.1 200 OK
Date: Sat, 09 Oct 2010 14:28:02 GMT
Server: Apache
Last-Modified: Tue, 01 Dec 2009 20:18:22 GMT
ETag: "51142bc1-7449-479b075b2891b"
Accept-Ranges: bytes
Content-Length: 29769
Content-Type: text/html

<!DOCTYPE html... (here comes the 29769 bytes of the requested web page)
```



서버가 응답을 하는 것은 똑같다. 

웹 브라우저는 이 메시지 바디를 바탕으로 화면에 렌더링한다.





응답 구조

- Status Line
- Headers
- CRLF
- Message Body

브라우저는 이 메시지 바디만 렌더링한다. 웹 브라우저가

서버는 빈 줄을 만날 때까지 읽는다. 서버는 날것 그대로

```http
HTTP/1.1 200
Accepti
```



한 번 요청하고 응답하면 끝이다. 

- GET은 모든 파라미터를 URL로 보내는 것 (눈에 보임)
- POST는 전달하려는 정보가 HTTP body에 포함되어 전달되는 것 (눈에 보이지 않음)

GET방식으로 데이터를 서버에 보낼 지, POST 방식으로 보낼 지 어떻게 결정할까?



![image](https://user-images.githubusercontent.com/50407047/100189663-14de9800-2f30-11eb-8387-6ed6a3ec46ba.png)

```html
<form>
  <input type="text" name="name" /><br />
  <input type="password" name="password" /><br />
  <input type="file" name="file" /><br />
  <input type="submit" />
</form>
```

get 요청에서는 파일 이름만 봰ㄹ 수 있고 파일 자체는 보낼 수 없다.

```http
Request URL: http://localhost:8080/bitcamp-web-project/source/ch2/2-37.html?name=%ED%85%8C%EC%8A%A4%ED%8A%B8&password=1010&file=bio-photo.jpg
```



```html
<form>
  <input type="text" /><br />
  <input type="button" /><br />
  <input type="checkbox" /><br />
  <input type="file" /><br />
  <input type="hidden" /><br />
  <input type="image" /><br />
  <input type="password" /><br />
  <input type="radio" /><br />
  <input type="reset" /><br />
  <input type="submit" />
</form>
```

서버에 보낼 때 name=값, password=값, 이렇게 보내진다.

> 피들러: 웹 디버깅 프록시 (자바로 만들어졌다.)

```html
<form>
  <label>이름</label>
  <input type="text" />
</form>
```



`textArea`

```html
<textarea>
  Hello Textarea
  Hello Textarea
</textarea>
```

이렇게 공백이 있으면 안된다.

다음과 같이 하도록 하자.

![image](https://user-images.githubusercontent.com/50407047/100191850-36418300-2f34-11eb-8c2f-16537db8f0b6.png)

```HTML
<textarea>Hello Textarea
Hello Textarea</textarea>
```



form안에 넣어야 서버에 보낼 수 있다. 이름이 없으면 보낼 수 없다. 타입을 안 적어도 `submit`이고, `submit`이라고 적어도 `submit`이다. `<button>` 타입에는 세 가지가 있다.

```html
<form>
  <select multiple="multiple" name="food">
    <option value="kim">김밥</option>
    <option>떡볶이</option>
    <option selected>순대</option>
    <option selected>오뎅</option>
  </select>
  <button>제출</button>
</form>
```

`?food=순대&food=오뎅`

같은 이름으로 서버에 여러 개의 값이 오면 어떻게 받을 지 결정해야 한다.

```html
<select>
  <optgroup label="HTML5">
    <option>Multimedia Tag</option>
    <option>Connectivity</option>
    <option>Device Access</option>
  </optgroup>
  <optgroup label="CSS3">
    <option>Animation</option>
    <option>3D Transform</option>
  </optgroup>
</select>
```

![image](https://user-images.githubusercontent.com/50407047/100192735-d21fbe80-2f35-11eb-9e0a-f98e0e322d47.png)

```html
<form>
  <fieldset>
    <legend>입력 양식</legend>
    <table>
      <tr>
        <td><label for="name">이름</label></td>
        <td><input id="name" type="text" /></td>
      </tr>
      <tr>
        <td><label for="mail">이메일</label></td>
        <td><input id="mail" type="email" /></td>
      </tr>
    </table>
    <input type="submit" />
  </fieldset>
</form>
```

### `<div>`

- UI를 그룹으로 묶을 때 사용한다.
- 블럭 요소: 한 줄 전체를 점유한다.
- division

### `<span>`

- UI를 묶는 것이 아니라 text를 구분하는 용도로 사용한다.

