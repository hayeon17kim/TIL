## JSP

JSP가 바로 실행되는 것이 아니라 JSP가 실행되기 전에 Servlet인터페이스를 구현한 자바 소스를 JSP 엔진이 만들어서 이것을 컴파일해서 그 서블릿 클래스를 실행하는 것이다. 

JSP 엔진이 자바 소스를 만들 때 단순히 서블릿 인터페이스를 구현한느 게 아니라 규칙이 있는데, HttpJspPage를 구현하게 되어 있다. 그리고 이 인터페이스는 JspPage인터페이슬르 구현하고, 이는 Servlet 인터펭시를 ㄱ루현한다. 따라서 init ~ 등 5개 메서드뿐만 아니라 jspInit() jspDestroy(), jspService() 도 가지고 있다. 그리고 service() 메서드는 jspService()를 호출한다. 결국 ServletContainer가 init을 호출하면 jspInit()이 호출되고, destroy()를 호출하면 jspDestroy()를 호출하고, service()를 호출하면 jspService()도 호출하도록 하는 것이다. 

실제로느 JSP 작성한 콛느느 전부 jspService()에 놓인다. 그런데 이 jspService()가 어떻게, 왜 실행될까? service() 메서드 안에서 jspService()를 호출하기 때문이다.

### JSP 구동 원리

- 웹 브라우저 -> 서블릿 컨테이너
  - JSP 실행 요청
- 서블릿 컨테이너가 실행

 JSP 파일은 Python이나 PHP처럼 그 스크립트가 인터프리팅되는 것이 아니다. JSP엔진의 역할은 JSP 파일을 분석하여 서블릿 클래스를 생성하는 거싱다. 즉 JSP 파일이 직접 실행되지 않는다. 

JSP는 자바 서블릿 클래스를 만드는 재료로 사용된다. 그래서 ㄱ서블릿 클래스를 만드는 틀이라 해서 템플릿(template)dl이라 부른다. JSP를 템플릿 기술이라고 부르기도 한다. JSP를 작성할 때 사용하는 특정 태그들이 어떤 자바 코드를 생성하는지 이해하는 것이 중요하다.

JSP 실행을 요청할 땐 JSP 파일이 있는 위치를 지정하면 된다.



### 템플릿 데이터

JSP 파일에 그냥 작성하는 텍스트는 자바 출력 코드를 생성한다.

```java
out.write("템플릿 데이터");
out.write("템플릿 데이터");
```



### 스크립트릿(scriptlet)과 JSP 주석

```jsp
<!-- 
  이것은 HTML 주석이다.
  JSP 엔진 입장에서는
  단지 출력문으로 바꿀 템플릿 데이터일 뿐이다. 
 -->
<%-- 
JSP 주석 
- 이 태그는 JSP 주석이다. JSP 엔진이 무시한다.
- 이 태그 안에 작성한 것은 자바 클래스를 생성할 때 제거된다.

스크립트릿
- JSP 파일 안에 실행할 자바 코드를 넣은 태그
- 예)
  <%  자바 코드 %>
- 스크립트릿 안에 작성한 코드는 자바 클래스를 생성할 때 
  _jspService() 메서드 안에 작성한 순서 그대로 복사된다. 
--%>
<%
if (i < 10) {
  for (int x = 0; x < i; x++) {
    out.println("<p>" + x + "</p>");
  }
}
%>
```



```java
/*
 * Generated by the Jasper component of Apache Tomcat
 * Version: Apache Tomcat/9.0.40
 * Generated at: 2020-12-07 02:19:21 UTC
 * Note: The last modified time of this file was set to
 *       the last modified time of the source file after
 *       generation to assist with modification tracking.
 */
package org.apache.jsp.jsp;

import javax.servlet.*;
import javax.servlet.http.*;
import javax.servlet.jsp.*;

public final class ex03_jsp extends org.apache.jasper.runtime.HttpJspBase
    implements org.apache.jasper.runtime.JspSourceDependent,
                 org.apache.jasper.runtime.JspSourceImports {

  private static final javax.servlet.jsp.JspFactory _jspxFactory =
          javax.servlet.jsp.JspFactory.getDefaultFactory();

  private static java.util.Map<java.lang.String,java.lang.Long> _jspx_dependants;

  private static final java.util.Set<java.lang.String> _jspx_imports_packages;

  private static final java.util.Set<java.lang.String> _jspx_imports_classes;

  static {
    _jspx_imports_packages = new java.util.HashSet<>();
    _jspx_imports_packages.add("javax.servlet");
    _jspx_imports_packages.add("javax.servlet.http");
    _jspx_imports_packages.add("javax.servlet.jsp");
    _jspx_imports_classes = null;
  }

  private volatile javax.el.ExpressionFactory _el_expressionfactory;
  private volatile org.apache.tomcat.InstanceManager _jsp_instancemanager;

  public java.util.Map<java.lang.String,java.lang.Long> getDependants() {
    return _jspx_dependants;
  }

  public java.util.Set<java.lang.String> getPackageImports() {
    return _jspx_imports_packages;
  }

  public java.util.Set<java.lang.String> getClassImports() {
    return _jspx_imports_classes;
  }

  public javax.el.ExpressionFactory _jsp_getExpressionFactory() {
    if (_el_expressionfactory == null) {
      synchronized (this) {
        if (_el_expressionfactory == null) {
          _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();
        }
      }
    }
    return _el_expressionfactory;
  }

  public org.apache.tomcat.InstanceManager _jsp_getInstanceManager() {
    if (_jsp_instancemanager == null) {
      synchronized (this) {
        if (_jsp_instancemanager == null) {
          _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig());
        }
      }
    }
    return _jsp_instancemanager;
  }

  public void _jspInit() {
  }

  public void _jspDestroy() {
  }

  public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response)
      throws java.io.IOException, javax.servlet.ServletException {

    if (!javax.servlet.DispatcherType.ERROR.equals(request.getDispatcherType())) {
      final java.lang.String _jspx_method = request.getMethod();
      if ("OPTIONS".equals(_jspx_method)) {
        response.setHeader("Allow","GET, HEAD, POST, OPTIONS");
        return;
      }
      if (!"GET".equals(_jspx_method) && !"POST".equals(_jspx_method) && !"HEAD".equals(_jspx_method)) {
        response.setHeader("Allow","GET, HEAD, POST, OPTIONS");
        response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, "JSP들은 오직 GET, POST 또는 HEAD 메소드만을 허용합니다. Jasper는 OPTIONS 메소드 또한 허용합니다.");
        return;
      }
    }

    final javax.servlet.jsp.PageContext pageContext;
    javax.servlet.http.HttpSession session = null;
    final javax.servlet.ServletContext application;
    final javax.servlet.ServletConfig config;
    javax.servlet.jsp.JspWriter out = null;
    final java.lang.Object page = this;
    javax.servlet.jsp.JspWriter _jspx_out = null;
    javax.servlet.jsp.PageContext _jspx_page_context = null;


    try {
      response.setContentType("text/html; charset=UTF-8");
      pageContext = _jspxFactory.getPageContext(this, request, response,
      			null, true, 8192, true);
      _jspx_page_context = pageContext;
      application = pageContext.getServletContext();
      config = pageContext.getServletConfig();
      session = pageContext.getSession();
      out = pageContext.getOut();
      _jspx_out = out;

      out.write("<!DOCTYPE html>\r\n");
 // _jspService() 메서드에 안에 넣을 코드를 작성하라!
int i;

      out.write("<html>\r\n");
      out.write("<head>\r\n");
      out.write("<meta charset=\"UTF-8\">\r\n");
      out.write("<title>ex03</title>\r\n");
      out.write("</head>\r\n");

i = 5;

      out.write("<body>\r\n");
      out.write("<h1>스크립트릿(scriptlet)과 JSP 주석");
out.print(i);
      out.write("</h1>\r\n");
      out.write("<!-- \r\n");
      out.write("  이것은 HTML 주석이다.\r\n");
      out.write("  JSP 엔진 입장에서는\r\n");
      out.write("  단지 출력문으로 바꿀 템플릿 데이터일 뿐이다. \r\n");
      out.write(" -->\r\n");

if (i < 10) {
  for (int x = 0; x < i; x++) {
    out.println("<p>" + x + "</p>");
  }
}

      out.write("</body>\r\n");
      out.write("</html>\r\n");
      out.write("\r\n");
    } catch (java.lang.Throwable t) {
      if (!(t instanceof javax.servlet.jsp.SkipPageException)){
        out = _jspx_out;
        if (out != null && out.getBufferSize() != 0)
          try {
            if (response.isCommitted()) {
              out.flush();
            } else {
              out.clearBuffer();
            }
          } catch (java.io.IOException e) {}
        if (_jspx_page_context != null) _jspx_page_context.handlePageException(t);
        else throw new ServletException(t);
      }
    } finally {
      _jspxFactory.releasePageContext(_jspx_page_context);
    }
  }
}

```



### 스크립트릿 응용

```jsp
<%
String[] names = {"홍길동", "임꺽정", "유관순"};
%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>ex04</title>
</head>
<body>
<h1>스크립트릿(scriptlet) 응용</h1>
<ul>
<%
for (String name : names) {
  out.println("<li>" + name + "</li>");
}
%>
</ul>
```

자바코드

```java
String[] names = {"홍길동", "임꺽정", "유관순"};

out.write("\r\n");
out.write("<!DOCTYPE html>\r\n");
out.write("<html>\r\n");
out.write("<head>\r\n");
out.write("<meta charset=\"UTF-8\">\r\n");
out.write("<title>ex04</title>\r\n");
out.write("</head>\r\n");
out.write("<body>\r\n");
out.write("<h1>스크립트릿(scriptlet) 응용</h1>\r\n");
out.write("<ul>\r\n");

for (String name : names) {
  out.println("<li>" + name + "</li>");
}

```



### 표현식(expression element)

- `<=% %>`: expression element(표현식)
- 표현식(expression): 문장 중 에 값을 리턴하는 문장

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
  pageEncoding="UTF-8"%>
<%
String[] names = {"홍길동", "임꺽정", "유관순"};
%>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>ex05</title>
  </head>
  <body>
    <h1>표현식(expression element)</h1>
    <ul>
      <%for (String name : names) {%>
      <li><%=name%></li>
      <%}%>
    </ul>
  </body>
</html>
<%--
  용어 정리
  1) 문장(statement)
  if () {...}
else {...}
for () {...}
int a = 100;

2) 표현식(expression)
  - 문장 중에 값을 리턴하는 문장
  a * b        <---- 곱하기 결과 리턴
  (..)? a : b  <---- 조건에 따라 a 또는 b 값 리턴
  plus(10, 20) <---- plus()의 실행 값 리턴

  out.println("okok")  <---- 이 문장은 값을 리턴하지 않는다. 따라서 표현식이 아니다. 

  표현식(expression element)
  문법:
<%= 표현식 %>
자바 코드:
out.print(표현식)
또는
out.write(표현식)
--%>

```



```java
for (String name : names) {
  out.write("\r\n");
  out.write("<li>");
  out.print(name);
  out.write("</li>\r\n");
}
```



### declaration element: 선언부

```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
  pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>ex06 </title>
  </head>
  <%!
  // 다음과 같이 상속 받은 메서드를 오버라이딩 할 수 있다.
  public void jspInit() {
  System.out.println("ex06.jsp의 jspInit()");
}

  public void jspDestroy() {
    System.out.println("ex06.jsp의 jspDestroy()");
  }
  %>
  <body>
    <h1>선언부(declaration element)</h1>

    100,000,000 입금 = <%=calculate(100000000)%>
  </body>

  <%!
  double interest = 0.025; // 인스턴스 변수

  private String calculate(long money) { // 인스턴스 메서드 
    return String.format("%.2f", money + (money * interest));
  }
  %>

  <%!
{ // 인스턴스 블록
  System.out.println("ex06 인스턴스 생성!");
}

  static { // 스태틱 블록
    System.out.println("ex06 클래스 로딩");
  }
  %>
</html>
```



- 클래스에 멤버를 추가할 때 사용한다.
- `jspInit()`나 `jspDestroy()`와 같은 메서드를 오버라이딩할 때도 사용할 수 있다.
- 선언하는 위치는 상관 없다.
- `<%! 멤버 선언 %>`

```java
class JSP클래스 {
  멤버선언
    
  void _jspService() {
    ...
  }
}
```



```java
// 다음과 같이 상속 받은 메서드를 오버라이딩 할 수 있다.
public void jspInit() {
  System.out.println("ex06.jsp의 jspInit()");
}

public void jspDestroy() {
  System.out.println("ex06.jsp의 jspDestroy()");
}


double interest = 0.025; // 인스턴스 변수

private String calculate(long money) { // 인스턴스 메서드 
  return String.format("%.2f", money + (money * interest));
}


{ // 인스턴스 블록
  System.out.println("ex06 인스턴스 생성!");
}

static { // 스태틱 블록
  System.out.println("ex06 클래스 로딩");
}
```



### 지시문

### page

서블릿 실행과 관련하여 특정 기능을 설정한다.

### include

다른 파일의 내용을 복사해온다.

### taglib

JSTL 등 외부에서 정의한 태그 정보를 가져온다.



### page 지시문

지시문
1) page
  - 서블릿 실행과 관련하여 특정 기능을 설정한다.
2) include
  - 다른 파일의 내용을 복사해온다.
3) taglib
  - JSTL 등 외부에서 정의한 태그 정보를 가져온다.

page 지시문
1) `language="java"`

   - JSP 페이지에서 코드를 작성할 때 사용할 언어를 지정한다.
   - 즉 <% 코드 %>, <%= 표현식 %>, <%! 코드 %> 태그에 코드를 작성할 때 사용할 언어이다.
   - 원래는 다양한 언어를 사용할 경우를 고려해 설계되었지만,
     현재는 java 언어만 사용 가능하다.
   - 이 속성은 생략해도 된다.

2) `contentType="text/html; charset=UTF-8"`

   - 다음 자바 코드를 생성한다.
       response.setContentType("text/html; charset=UTF-8");  
   - **자바에서 출력할 때의 인코딩 설정**

3) `pageEncoding="UTF-8"`

   - **JSP 파일의 인코딩**을 설정한다.
   - JSP 파일을 저장할 때 UTF-8로 저장한다면 위와 같이 선언하라.
   - 생략한다면 에디터에 설정된 문자집합으로 인코딩할 것이다.

4) import="java.net.Socket"
   - 자바의 import 문을 생성한다.
   - 사용법
     `import="java.net.Socket"`
       => 자바 코드: 
          `import java.net.Socket;`
     `import="java.net.Socket,java.net.ServerSocket,java.util.List"`
       => 자바 코드:
          `import java.net.Socket;`
          `import java.net.Serversocket;`
          `import java.util.List;`
   - 한 개의 page 지시문에 여러 개의 import를 작성할 수 있다.
   - 여러 개의 page 지시문을 작성할 수 있다.

5) `trimDirectiveWhitespaces="true"`

   - 지시문 끝에 줄바꿈 코드를 무시하고 싶을 때 사용한다.

6) `buffer="8kb"`

   - 출력 버퍼의 크기를 변경할 때 사용한다. 
   - 지정하지 않으면 기본이 8kb 이다.
   - **출력 내용이 버퍼의 크기를 넘으면 예외가 발생한다.** **서블릿에서는 자동으로 출력**하였다. 그러나 JSP는 예외가 발생한다.

7) `autoFlush="true"`

- 출력 **버퍼가 찼을 때 자동으로 출력**한다.
- 기본은 true 이다.
- **false로 설정**하면 출력 버퍼가 찼을 때 **예외가 발생**한다.
  - `java.io.IOException: 오류: JSP 버퍼 오버플로우`

```jsp
<%@ page 
    language="java" 
    contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"
    import="java.net.Socket"
    import="java.net.ServerSocket"
    import="java.util.List,java.util.Map,java.util.Set"
    trimDirectiveWhitespaces="true"
    buffer="8kb"
    autoFlush="false"%>
<%@ page import="java.sql.Connection"%>
<%@ page import="java.sql.Statement"%>
```



```java
import java.sql.Connection;
import java.sql.Statement;
```



#### include 지시문

```jsp
<h1>지시문(directive element) - include</h1>
<%@ include file="./ex08_header.txt"%>
<p>테스트</p>
<%@ include file="./ex08_footer.txt" %>a
```

```txt
<%@ page pageEncoding="UTF-8"%>
<header>머리말</header>
```


```txt
<%@ page pageEncoding="UTF-8"%>
<footer>꼬리말</footer>
```



1) file="JSP에 포함시킬 파일 경로"

   - 지정한 파일을 JSP로 포함시킨 후에 자바 서블릿 클래스를 생성한다.
     자동 생성된 자바 서블릿 클래스의 소스를 확인해보라!
   - 따라서 일반 텍스트 파일이면 된다. JSP 파일일 필요가 없다.
   - RequestDispatcher의 include()와 다르다.
   - 비록 JSP 파일이 아니더라도 다음을 선언하여 해당 파일의 문자집합을 지정해야 한다. 
       `<%@ page pageEncoding="UTF-8"%>`
     JSP 엔진에 해당 파일의 내용을 가져올 때 pageEncoding에 지정된 문자집합으로
     내용을 인식한다.
     또한 JSP 엔진은 `<%@ page ...%>`는 **참고만 할 뿐 가져오지는 않는다.** 

```java

static {
  _jspx_dependants = new java.util.HashMap<java.lang.String,java.lang.Long>(2);
  _jspx_dependants.put("/jsp/./ex08_header.txt", Long.valueOf(1606203341351L));
  _jspx_dependants.put("/jsp/./ex08_footer.txt", Long.valueOf(1606203341348L));
}

//..

      out.write("<!DOCTYPE html>\r\n");
      out.write("<html>\r\n");
      out.write("<head>\r\n");
      out.write("<meta charset=\"UTF-8\">\r\n");
      out.write("<title>ex08</title>\r\n");
      out.write("</head>\r\n");
      out.write("<body>\r\n");
      out.write("<h1>지시문(directive element) - include</h1>\r\n");
      out.write("<header>머리말</header>");
      out.write("<p>테스트</p>\r\n");
      out.write("<footer>꼬리말</footer>");
      out.write("</body>\r\n");
      out.write("</html>\r\n");

```



pageContext 보관소





### 지시문 - tablelib

```jsp
<%@ page 
    language="java" 
    contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"
    trimDirectiveWhitespaces="true"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>ex09</title>
</head>
<body>
<h1>지시문(directive element) - tablib</h1>
<c:forEach items="홍길동,임꺽정,유관순,안중근,윤봉길,김구,김원봉" var="n">
이름=<%=pageContext.getAttribute("n")%>, ${n}<br>
</c:forEach>
</body>
</html>
```



tablib 지시문
=> 외부에 따로 정의된 JSP 확장 태그를 가져올 때 사용한다.
=> JSP 확장 태그
   1) JSTL(JSP Standard Tag Library)
      - JSP 명세에 추가로 정의된 태그이다.
      - Servlet/JSP API에서는 JSTL 구현체를 제공하지 않는다.
      - 따로 구현된 라이브러리를 다운로드 받아야 한다.
        mvnrepository.com에서 JSTL 라이브러리를 검색하여 프로젝트에 추가하라.
      - 보통 apache.org 사이트에서 구현한 것을 사용한다.
   2) 개발자가 정의한 태그
      - 개발자가 따로 태그를 정의할 수 있다.
      - 그러나 실무에서는 유지보수를 일관성을 위해 JSTL과 같은 표준 API를 사용한다.
      - 즉 개발자가 자신의 회사에서만 사용할 태그를 따로 정의하지 않는다.

=> 사용법
      <%@ taglib 
          uri="확장 태그를 정의할 때 부여한 확장 태그 URI" 
          prefix="확장태그를 사용할 때 붙이는 접두사"%>
   JSP 페이지에서 사용하기
      `<확장_태그_접두사:사용자_태그명 속성명="값" .../>`



JSP에서는 소켓을 임포트할 때 imnport한 라이브러리를 c라고 하고 이름을 붙인 다음에 사용한다.



### JSP 빌트인 객체

- JSP를 가지고 서블릿 클래스를 만들 때 _jspService() 메서드에서 기본으로 준비하는 객체
- JSP 엔진은 **반드시 다음과 같은 이름으로 레퍼런스를 선언**해야 한다.
  즉 **서블릿 컨테이너(ex: 톰캣, jetty, resin 등)에 상관없이 이름이 같다.**

1) request - HttpServletRequest => _jspService() 파라미터이다.
2) response - HttpServletResponse => _jspService() 파라미터이다.
3) pageContext - PageContext => _jspService()의 로컬 변수이다.
4) session - HttpSession => _jspService()의 로컬 변수이다.
5) application - ServletContext => _jspService()의 로컬 변수이다.
6) config - ServletConfig => _jspService()의 로컬 변수이다.
7) out - JspWriter => _jspService()의 로컬 변수이다.
8) page - 서블릿 객체를 가리킨다. 즉 this 이다. => _jspService()의 로컬 변수이다.
9) exception - Throwable => _jspService()의 로컬 변수이다.

   - 이 변수는 JSP 페이지가 <%@ page isErrorPage="true"%>로 설정되었을 때만 존재한다.
   - 주로 오류가 발생되었을 때 실행되는 JSP 페이지인 경우 위 설정을 붙인다. 



### JSP 액션 태그: `jsp:useBean`, `jsp:setProperty`

JSP 액션 태그
=> JSP에서 기본으로 제공하는 JSP 전용 태그
=> 따로 taglib를 사용하여 라이브러리를 선언할 필요가 없다.
=> JSP에서 기본으로 제공하기 때문에 그대로 사용하면 된다.
=> 네임스페이스 이름은 jsp 이다.
   <jsp:태그명 ..../>

jsp:useBean

- JSP에서 사용할 객체를 생성할 때 사용할 수 있다
- 또는 보관소(ServletContext, HttpSession, ServletRequest, PageContext)에 저장된 객체를 꺼낼 때도 사용한다
- 사용법: `<jsp:useBean scope="보관소명" id="객체명" class="클래스명"/>`  
- 주요 속성
  - scope
    - 객체를 꺼내거나 생성된 객체를 저장할 보관소 이름
    - 다음 4개의 값 중 한 개를 지정할 수 있다. 값을 지정하지 않으면 기본이 "page" 이다.
             application(ServletContext), session(HttpSession),
             request(ServletRequest), page(PageContext)
         id 
           - 객체를 꺼내거나 저장할 때 사용할 이름
            class
                - 보관소에서 객체를 찾을 수 없을 때 생성할 객체의 클래스명
                     - 반드시 패키지 이름을 포함해 클래스명(fully-qualified name; FQName)을 지정해야 한다.
             <%@ page import="..."%> 를 선언해도 소용없다.
                     - 객체를 꺼내는 경우 레퍼런스의 타입으로도 사용된다.
                          - 객체를 생성할 때도 사용할 수 있기 때문에 반드시 콘크리트(concrete) 클래스명이어야 한다.
             추상 클래스와 인터페이스는 객체를 생성할 수 없기 때문에 안된다.

```jsp
<%-- bitcamp.vo.Board 객체 생성하기 --%>
<jsp:useBean id="b1" class="com.eomcs.web.vo.Board" scope="page"/>
<%--
위 태그의 자바 코드
com.eomcs.web.vo.Board b1 = (com.eomcs.web.vo.Board) pageContext.getAttribute("b1");
if (b1 == null) {
  b1 = new com.eomcs.web.vo.Board();
  pageContext.setAttribute("b1", b1);
}
 --%>

<%-- scope을 생략하면 기본이 page(PageContext)이다. --%>
<jsp:useBean id="b2" class="com.eomcs.web.vo.Board"/>

<jsp:useBean id="b3" class="com.eomcs.web.vo.Board"/>

<%-- 객체의 setter 메서드를 호출하기 --%>
<jsp:setProperty name="b3" property="no" value="100"/>
<jsp:setProperty name="b3" property="contents" value="내용입니다."/>
<jsp:setProperty name="b3" property="viewCount" value="88"/>
<%-- 단, 속성에 자바 객체의 프로퍼티 타입이 자바 원시 타입과 문자열인 경우 가능하다.
     다른 타입이라면 속성을 따로 처리해야 한다. --%>
<%-- 
<jsp:setProperty name="b3" property="createdDate" value="2019-4-8"/>
--%>

<%=b1%> => out.print(b1);<br>  
<%=b2%> => out.print(b2);<br>
<%=b3%> => out.print(b3);<br> 
<%=b3.toString()%> => out.print(b3.toString());<br>

```



실행결과

```
Board [no=0, contents=null, createdDate=null, viewCount=0, writer=null] => out.print(b1);
Board [no=0, contents=null, createdDate=null, viewCount=0, writer=null] => out.print(b2);
Board [no=100, contents=내용입니다., createdDate=null, viewCount=88, writer=null] => out.print(b3);
Board [no=100, contents=내용입니다., createdDate=null, viewCount=88, writer=null] => out.print(b3.toString());
```

> 최근에는 expression language 를 사용하기 때문에 요즘은 이 방법을 거의 사용하지 않는다. 다만 오래된 시스템을 유지보수할 때는 만날 수도 있다.

```jsp
<jsp:useBean id="s1" type="java.lang.String" scope="application"/>
<%-- 자바코드로 표현해보면,
  String s1 = (String)application.getAttribute("s1");
 --%>


<jsp:useBean id="s2" type="java.lang.String" scope="session"/>
<%-- String s2 = (String)session.getAttribute("s2"); --%>

<jsp:useBean id="s3" type="java.lang.String" scope="request"/>
<%-- String s3 = (String)request.getAttribute("s3"); --%>

<jsp:useBean id="s4" type="java.lang.String" scope="page"/>
<%-- String s4 = (String)pageContext.getAttribute("s4"); --%>


<%=s1%><br>
<%=s2%><br>
<%=s3%><br>
<%=s4%><br>

```

다만 scope 에 따라 어느 보관소에서 꺼내는지가 달라진다. 여기서 `application`은 `ServletContext` 객체이다. 그리고 `page`는 `pageContext`를 가리킨다.

useBean인데 class가 아니라 type을 주면 **객체를 생성하지 않고 꺼내기만 한다.**

jsp:useBean 문법:

<jsp:useBean id="레퍼런스명" type="레퍼런스타입" scope="보관소"/>
=> id

   - 보관소에서 값을 꺼낼 때 사용하는 이름이다.
   - 또한 꺼내 값을 저장하는 변수의 이름으로 사용된다.
=> type 
   - 보관소에서 꺼낸 객체의 타입을 지정할 때 사용한다.
=> scope
   - 값을 꺼내는 보관소를 가리킨다.
=> 예) 
태그: 
    <jsp:useBean id="s4" type="java.lang.String" scope="page"/>
자바코드: 
    String s4 = (String) pageContext.getAttribute("s4");
    if (s4 == null) {

    throw new Exception("객체 꺼내기 오류");

  }

```jsp
<jsp:useBean id="list" type="java.util.ArrayList<String>" scope="page"/>
<%-- 자바코드로 표현해보면,
  java.util.ArrayList<String> list = 
    (java.util.ArrayList<String>) pageContext.getAttribute("list");
  if (list == null) {
    throw new Exception("ArrayList 꺼내기 오류!");
  }
 --%>
```

클래스로 바꿀 때는 제네릭을 쓸 수가 없다. 제네릭을 빼야 한다.

```jsp
<jsp:useBean id="list" class="java.util.ArrayList" scope="page"/>
<%-- 자바코드로 표현해보면,
  java.util.ArrayList<String> list = 
    (java.util.ArrayList<String>) pageContext.getAttribute("list");
  if (list == null) {
    throw new Exception("ArrayList 꺼내기 오류!");
  }
 --%>
```



```java
<jsp:useBean id="list" type="java.util.List<String>" scope="page"/>
<%-- type에는 인터페이스를 지정할 수 있다.
  java.util.List<String> list = 
    (java.util.List<String>) pageContext.getAttribute("list");
 --%>
```



**useBean할 때 class를 지정하면, null일 때 객체를 생성한다.** **type 을 지정하면, null이면 예외를 띄운다** 따라서 class에 인터페이스를 사용할 수 없다. 인터페이스로 객체를 생성할 수 없기 때문이다.

ArrayList에 제네릭을 적용하지 않으면 다음과 같이 어떤 타입의 객체라도 저장할 수 있따. 그러나 `jsp:useBean` 태그에서 `type` 속성을 설정하면 제네릭을 사용할 수 있다. class와 type을 함께 지정하면 된다.

```jsp
<jsp:include page="ex19_header.jsp"/>
<%-- 자바 코드
RequestDispatcher rd = request.getRequestDispatcher("/ex19_header.jsp");
rd.include(request, response);
 --%>
```

인클루드와 포워드 하는 방법은 RequestDispatcher 인클루드 포워드 하는 방법밖에 없다. JSP 자바 코드에서 다른 이유는



**자동페ㅗ워드**

```jsp
<%@ page 
  language="java" 
  contentType="text/html; charset=UTF-8"
  pageEncoding="UTF-8"
  trimDirectiveWhitespaces="true"
  errorPage="ex20_error.jsp"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>ex20</title>
  </head>
  <body>
    <h1>errorPage 속성과 isErrorPage 속성</h1>
    <%
    int value = Integer.parseInt(request.getParameter("value"));
    %>
    10 / <%=value%> = <%=10 / value%>
  </body>
</html>
<%--
  errorPage
  => JSP를 실행하는 중에 오류가 발생했을 때 실행할 JSP를 지정할 수 있다.
  => 어떻게?
  <%@ page errorPage="URL"%>
=> 이 속성에 URL을 지정하지 않으면 오류가 발생했을 때 
서블릿 컨테이너의 기본 오류 출력 페이지가 실행된다.

isErrorPage
=> 오류가 발생했을 때 실행되는 JSP 쪽에서
그 오류 내용을 받을 때 사용한다. 

--%>
```



```jsp
<%@ page 
  language="java" 
  contentType="text/html; charset=UTF-8"
  pageEncoding="UTF-8"
  trimDirectiveWhitespaces="true"
  isErrorPage="true"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>ex20</title>
  </head>
  <body>
    <h1>오류 발생!</h1>
    <%=exception.getMessage()%>
  </body>
</html>
<%--
  오류가 발생했을 때 실행되는 JSP 페이지는 
  exception이라는 변수를 통해 오류 내용을 받을 수 있다.
  단, isErrorPage 속성이 true이어야 해당 변수가 준비된다.
  --%>

```

이 페이지는 반드시 `isErrorPage`를 true로 해야 한다. 그래야만 포워딩하기 전에 발생한 에러 정보를 가져올 수 있다.  만약 `isErrorPage=true`가 없다면 `exception`을 사용할 수 없다. 사용하려고 하면 에러가 난다.

에러가 발생했을 때 



## JSTL



## EL(Expression Language)

- EL(Expression Language)은 콤마(.)와 대괄호([]) 등을 사용하여 객체의 프로퍼티나,
  리스트, 셋, 맵 객체의 값을 쉽게 꺼내고 설정하게 도와주는 문법이다.
  특히 값을 꺼낼 때는 OGNL 표기법을 사용한다.
  
- **OGNL(Object Graph Navigation Language)?**
  객체의 프로퍼티 값을 가리킬 때 사용하는 문법이다.
  파일의 경로처럼 객체에 포함된 객체를 탐색하여 값을 쉽게 조회할 수 있다.
  
- 문법
    ${ 객체명.프로퍼티명.프로퍼티명.프로퍼티명 }
    ${ 객체명["프로퍼티명"]["프로퍼티명"]["프로퍼티명"] }
    
- EL에서 사용할 수 있는 객체?
    pageContext 
      - JSP의 PageContext 객체
    servletContext 
      - ${ pageContext.servletContext.프로퍼티명 }
        자바코드 => pageContext.getServletContext().get프로퍼티()
    session 
      - ${ pageContext.session.프로퍼티명 }
        예) $ { pageContext.session.name }
        => pageContext.getSession().getName();
                    
    
    request 
      - ${ pageContext.request.프로퍼티명 }
    response
    
    param 
      - ${ param.파라미터명 }
        => request.getParameter("파라미터명");
    paramValues 
      - ${ paramValues.파라미터명 }
        => request.getParameterValues("파라미터명");
    header 
      - ${ header.헤더명 }
        => request.getHeader("헤더명");
    headerValues 
      - ${ headerValues.헤더명 }
        => request.getHeaders("헤더명");
    cookie 
      - ${ cookie.쿠키명 }
    initParam 
      - ${ initParam.파라미터명 }
    
    => 보관소에서 값을 꺼내는 문법
    pageScope 
      - ${ pageScope.객체이름 }
        => pageContext.getAttribute("객체이름");
    requestScope 
      - ${ requestScope.객체이름 }
        => request.getAttribute("객체이름");
    sessionScope 
      - ${ sessionScope.객체이름 }
        => session.getAttribute("객체이름");
        예) ${ sessionScope.name }
        => session.getAttribute("name");
    applicationScope 
      - ${ applicationScope.객체이름 }
        => application.getAttribute("객체이름");



### 보관소에서 값 꺼내기

```jsp
<h1>EL - 보관소에 값 꺼내기</h1>
<%
pageContext.setAttribute("name", "홍길동");
request.setAttribute("name", "임꺽정");
session.setAttribute("name", "유관순");
application.setAttribute("name", "안중근");
%>

PageContext 보관소 : ${pageScope.name}<br>
PageContext 보관소 : <%=pageContext.getAttribute("name")%><br>

ServletRequest 보관소 : ${requestScope.namedb}<br>
ServletRequest 보관소 : <%=request.getAttribute("name")%><br>

HttpSession  보관소 : ${sessionScope.name}<br>
HttpSession 보관소 : <%=session.getAttribute("name")%><br>

ServletContext 보관소 : ${applicationScope.name}<br>
ServletContext 보관소 : <%=application.getAttribute("name")%><br>
```



값이 없으면 null이 아니라 빈 문자열이 놓인다.



보관소가 아닌 로컬 변수는 EL에서 사용할 수 없다. 



## JSTL

### JSTL 개요

- JSTL(JSP Standard Tag Library)? 
  - JSP 확장 태그이다.
  - 기본으로 제공하지 않는다.
  - JSTL API를 구현한 외부 라이브러리를 가져와서 사용해야 한다.
- JSTL 라이브러리 가져오기
  - mvnrepository.com 에서 JSTL 검색하여 라이브러리를 정보를 알아낸다.
  - build.gradle 파일의 dependencies {} 블록에 추가한다.
  - 'gradle eclipse' 실행하여 이클립스 설정 파일을 갱신한다.
  - 이클립스 프로젝트를 리프래시 한다.
- JSTL 라이브러리 모듈
  - Core(c) : http://java.sun.com/jsp/jstl/core
  - XML(x) : http://java.sun.com/jsp/jstl/xml
  - I18N(fmt) : http://java.sun.com/jsp/jstl/fmt
  - Database(sql) : http://java.sun.com/jsp/jstl/sql
    - 자바는 모르고 jsp만 아는 사람들은 이걸 쓰겠지만.. jsp를 사용하는 것은 거의 MVC 패턴 안에서만 사용하기 때문에 쓰면 안된다. (jsp는 화면 출력엠나 써라! 안그러면 mvc 패턴 무너짐)
  - Functions(fn) : http://java.sun.com/jsp/jstl/functions
- JSP 페이지에서 JSTL 라이브러리의 모듈 사용하기
  - JSTL 모듈의 네임스페이스를 가져온다.
    <%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%>
    - prefix: 전 세계 모든 개발자가 core 모듈에 대해서는 c 닉네임을 사용한다. 그러니까 이걸 따르도록 하자. 
  - JSTL 태그 사용
    <접두어명:태그명 속성="값" 속성="값"/> 

```groovy
dependencies {
// 의존라이브러리 옵션
// => implementation : 컴파일한 후 생성되는 빌드 파일에 포함된다.
// => compileOnly : 컴파일한 후 생성되는 빌드 파일에 포함되지 않는다.
//

// Thumbnailator 썸네일 생성 라이브러리
implementation 'net.coobird:thumbnailator:0.4.13'

// Apache의 파일업로드 처리 라이브러리
implementation 'commons-fileupload:commons-fileupload:1.4'

compileOnly 'javax.servlet:javax.servlet-api:4.0.1'

implementation 'jstl:jstl:1.2'

implementation 'com.google.guava:guava:28.1-jre'

testImplementation 'junit:junit:4.12'
}
```

톰캣서버에서 제공해주지 않기 때문에 `implementation`을 사용한다.

* I18N(Internationalization 의 약자)
  => 프로그램을 짤 때 여러 언어를 고려해서 코딩하는 것을 말한다.
  => 특히 화면에서 버튼에 제목이나 라벨을 출력할 때 특정 언어로 고정된 값을 출력하지 않고,
   외부 파일(예: label_ko_KR.properties)에서 읽어 온 값을 출력하도록 프로그래밍 하는 것.

* L10N(Localization 의 약자)
  => 특정 언어에 대해 라벨 텍스트를 담은 프로퍼티 파일(예: label_ko_KR.properties)을 
   작성하는 것을 말한다.

jstl.jar에는 사용하는 태그를 처리해주는 클래스들이 들어있다. 아파치에서 구현체를 제공한다. (`org.apache.taglibs.standards`. 드라이버와 같음.)

```jsp
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>

<h2>오호라!!!</h2>

<%
out.println("<h2>오호라!!!</h2>");
%>

<%="<h2>오호라!!!</h2>"%>

${"<h2>오호라!!!</h2>"}

<c:out value="<h2>오호라!!!<h2>"/>
<!-- 글자 그대로 출력한다 -->

</body>
</html>
```



### c:out

```jsp
- 출력문을 만드는 태그이다.
<c:out value="출력될 값" default="기본 값"/>
<c:out value="출력될 값>기본값<c:out>
```



### c:set

```jsp
<%@ page language="java" 
  contentType="text/html; charset=UTF-8"
  pageEncoding="UTF-8"
  trimDirectiveWhitespaces="true"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>JSTL</title>
  </head>
  <body>
    <h1>JSTL - c:set</h1>
    <pre>
- 보관소에 값을 저장한다.
</pre>
    <%
    //request.setAttribute("name1", "홍길동");
    %>
    <c:set scope="request" var="name1" value="홍길동2"/>
    1: ${requestScope.name1}<br>
    2: ${pageScope.name1}<br>
    3: ${name1}<br> 
    <hr>

    <%--
  scope을 생략하면 기본이 PageContext 이다.
  --%>
    <c:set var="name2" value="임꺽정"/>
    1: ${requestScope.name2}<br>
    2: ${pageScope.name2}<br>
    3: ${name2}<br>
    <hr>

    <%-- 
  시작 태그와 끝 태그 사이(content)에 값을 넣을 수 있다.
  --%>
    <c:set var="name3">유관순</c:set>
    1: ${requestScope.name3}<br>
    2: ${pageScope.name3}<br>
    3: ${name3}<br>

    <h2>객체의 프로퍼티 값 설정하기</h2>
    <jsp:useBean id="m1" class="com.eomcs.web.vo.Member"/>
    <%--
  Member m1 = (Member) pageContext.getAttribute("m1");
    if (m1 == null) {
      m1 = new Member();
      pageContext.setAttribute("m1", m1);
    }
    --%>
    <jsp:setProperty name="m1" property="no" value="100"/>
    <%-- 
  m1.setNo(100);
    --%>

    <c:set target="${pageScope.m1}" property="email" value="hong@test.com"/>
    <%--
  Object obj = pageContext.getAttribute("m1");
    Method m = obj.getClass().getMethod("setEmail", String.class);
    m.invoke(obj, "hong@test.com");

    => m1.setEmail("hong@test.com");
    --%>

    ${pageScope.m1.no}<br>
    ${pageScope.m1.email}<br>
  </body>
</html>
```

`jsp:setProperty`나 `c:set`이나 그 기능은 같다.

> JSTL의 문법을 본따서 만든 것이 mybatis이다. 

### c:set

조건문을 만든다.

```jsp
<c:set var="name" value="홍길동"/>
<c:set var="age" value="26"/>
<c:set var="gender" value="man"/>

<c:if test="${not empty name}">
    <p>${name}님 환영합니다!
</c:if>
<c:if test="${age < 19}">
    <p>미성년입니다.</p>
</c:if>
<c:if test="${age >= 19}">
    <p>성년입니다.</p>
</c:if>
```

- 조건문의 결과를 보관소에 저장하기
- var 속성으로 변수이름을 설정하면, 조건문의 테스트 결과는 지정된 이름으로 보관소에 저장된다.

```java
<c:if test="${gender == 'woman'}" var="r1"/>
${r1}<br>
${pageScope.r1 ? "여성" : "남성"}<br>
```



### c:choose

- 다중 조건문을 만든다.
- 자바의 `switch`와 유사하다.

```jsp
<c:set var="name" value="홍길동"/>
<c:set var="age" value="26"/>
<%--
pageContext.setAttribute("name", "홍길동");
pageContext.setAttribute("age", "16");
--%>

<c:choose>
    <c:when test="${age < 19}">
        <p>미성년입니다.</p>
    </c:when>
    <c:when test="${age >= 19 and age < 65}">
        <p>성년입니다.</p>
    </c:when>
    <c:otherwise>
        <p>노인입니다.</p>
    </c:otherwise>
</c:choose>
```

### c:forEach

#### 배열

```jsp
<%
pageContext.setAttribute("names", new String[]{"홍길동", "임꺽정", "유관순"});

/*
String[] names = (String[]) pageContext.getAttribute("names");
for (String n : names) {
  out.println("<li>" + n + "</li>");
}
*/
%>

<ul>
<c:forEach items="${pageScope.names}" var="n">
    <li>${n}</li>
</c:forEach>
</ul>
```

> 굳이 pageScope.names 할 필요 없이 names 하면 된다.

#### Collection 객체

```jsp
<%
List<String> names2 = new ArrayList<>();
names2.add("홍길동");
names2.add("임꺽정");
names2.add("유관순");
pageContext.setAttribute("names2", names2);
%>

<ul>
<c:forEach items="${pageScope.names2}" var="n">
    <li>${n}</li>
</c:forEach>
</ul>
```

#### Map 객체

```jsp
<%
Map<String,Object> names3 = new HashMap<>();
names3.put("s01", "홍길동");
names3.put("s02", "임꺽정");
names3.put("s03", "유관순");
pageContext.setAttribute("names3", names3);
%>

<ul>
<%-- Map 객체에 대해 반복문을 돌리면 var로 저장되는 것은 
     key와 value를 갖고 있는 Entry 객체이다. --%>
<c:forEach items="${pageScope.names3}" var="n">
<c:forEach items="${pageScope.names3}" var="n">
    <li>${n.getKey()} : ${n.getValue()} => ${n.key} : ${n.value}</li>
</c:forEach>
</c:forEach>
</ul>
```

#### CSV 문자열

```jsp
<%
pageContext.setAttribute("names4", "홍길동,임꺽정,유관순,김구");
%>

<ul>
<c:forEach items="${pageScope.names4}" var="n">
    <li>${n}</li>
</c:forEach>
```

### c:forTockens

```jsp
<%
pageContext.setAttribute("names1", "홍길동,임꺽정,유관순,김구");

/*
String str = (String) pageContext.getAttribute("names1");
String[] values = str.split(",");
for (String n : values) {
  out.println("<li>" + n + "</li>");
}
*/
%>

<ul>
<c:forTokens items="${pageScope.names1}" var="n" delims=",">
    <li>${n}</li>
</c:forTokens>
</ul>
  
```

#### Query String 문자열

```jsp
<%
pageContext.setAttribute("qs", "name=홍길동&age=20&tel=1111-2222");
%>

<ul>
<c:forTokens items="${pageScope.qs}" var="n" delims="&">
    <li>${n}</li>
</c:forTokens>
</ul>

```

### fmt:parseDate

JSP에서 redirect하려면 

```jsp
<%
pageContext.setAttribute("today", new Date());
%>

<fmt:formatDate value="${pageScope.today}" 
                pattern="yyyy-MM-dd"/><br>
<fmt:formatDate value="${pageScope.today}" 
                pattern="MM/dd/yyyy"/><br>
<fmt:formatDate value="${pageScope.today}" 
                pattern="yyyy-MM-dd hh:mm:ss"/><br>
<hr>

<fmt:formatDate value="${pageScope.today}" 
                pattern="yyyy-MM-dd"
                var="str1"/>

<p>오늘 날짜는 '${pageScope.str1}'입니다.</p>  
```



### fmt:formatDate



## PMS: EL 및 JSTL

```jsp
<%
List<Board> list = (List<Board>) request.getAttribute("list");
%>

<table border='1'>
<thead><tr><th>번호</th><th>제목</th><th>작성자</th><th>등록일</th><th>조회수</th></tr></thead>
<tbody>
<%for (Board b : list) {%>
<tr>
  <td><%=b.getNo()%></td>
  <td><a href='detail?no=<%=b.getNo()%>'><%=b.getTitle()%></a></td>
  <td><%=b.getWriter().getName()%></td>
  <td><%=b.getRegisteredDate()%></td>
  <td><%=b.getViewCount()%></td>
</tr>
<%}%>
</tbody>
</table>
```



```jsp
<c:forEach items="${list}" var="b">
<tr>
  <td>${b.no}</td>
  <td><a href='detail?no=${b.no}%>'>{b.no}</a></td>
  <td>{b.writer.name}</td>
  <td>{b.registeredDate}</td>
  <td>{b.viewCount}</td>
</tr>
</c:forEach>
```



DetailServlet예외는 여기서 처리하자.

```java
if (board == null) {
  throw new Exception("해당 번호의 게시글이 없습니다!");
}
```



JSP 안에서 자바 함수가 있어야 할 것 같으면 그냥 그전대로 하면 된다. jstl을 하는 이유는 편하라고 하는 것이다. 유지보수가 쉬운 쪽으로 하자.

`${  project.title}`와 같이 공백 주는 것 ㄱ괜찮다.