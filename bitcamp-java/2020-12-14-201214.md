### ContextLoaderListener



### Spring WebMVC

![image](https://user-images.githubusercontent.com/50407047/102029521-13e3ac80-3df2-11eb-9229-d679b26f60ce.png)

FrontController는 클라이언트 요청을 제어하고, PageController를 실행하고, 



순리는 우리가 먹는 걸 우리가 생산해야 해서 먹어야 한다. 고기도 우리가 직접 사냥해서 먹어야 한다. 그런데 현대 사회에서는 다른 사람이 제공한 것을 사먹기만 하면 된다. 마찬가지로 우리도 원래는 생성자에서 직접 `projectService = new ProjectService`를 해서 직접 생성해서 사용했다. 그러나 외부에서 주입받아 쓴다.

```java
public ProjectController(ProjectService projectService) {
  this.projectService = projectService;
}
```

원래는 필요한 시점에 객체를 생성해서 사용하는 것이 정상이다. 그런데 왜 주입받을까? 사회 구조가 단순할 때는 직접 농사짓고 살았지만 사회가 복잡해지면서 그렇게 할 수가 없게 되었다. 그러나 메서드가 호출될 때마다 객체가 필요할 때마다 `new ~` 이렇게 객체를 만들어 쓴다면 메모리를 낭비하고, 관리가 힘들어진다. 그래서 객체관리를 효율적으로 하기 위해서 역제어가 등장했다. 역제어가 등장한 이유는 대단위 프로젝트
일반적으로는 명령어 실행을 위에서 아래로 순차적으로 실행한다. 이와 반대로 역제어(Inversion of Control)는 대단위 프로젝트에서 객체를 효율적으로 관리하고, 실행흐름을 효율적으로 관리하기 위한 기법이다. 역제어의 예는 DI와 EventListner이다. 원래는 사용하는 쪽에서 객체를 준비해야 하는데, 외부에서 사용할 객체를 제공하는 것을 말한다. 메서드를 명시적으로 호출하는 것이 아니라, 어떤 상태에 놓일 때 메서드가 호출되는 것을 EventListener라고 한다. 

> ex) 그냥 작업을 하는 것이 아니라, 특정 사건이 있을 때 작업을 하는 것.  ex) 배달. 배달 요청이 들어오면 작업을 한다. 일반적인 업무 흐름이 아니다. 일반 흐름은 9시부터 6시까지 일하는 것.

> ex) 비트캠프에 들어오면 컴퓨터, 마우스 키보드라는 의존 객체를 주입해준다.



역제어의 대표적인 예가 DI(Dependency Injection; 의존객체의 주입; 의존성 주입)이다. 대단위 프로젝트에서 객체 관리를 효율적으로 하기 위해서 의존객체의 주입이 필요했다. 

또한 Event Listner.  원래는 개발자가 호출할 때 명시적으로 메서드를 호출해야 한다. 서버가 시작할 때 서블릿 콘테이너가 `contextInitialized`를 호출한다. 이처럼 개발자가 직접 호출하는 것이 아니라 호출 당하는 메서드를 콜백 메서드라고 부른다. `EventListner`는 특정 상태에 놓일 때 메서드가 호출되는 것을 말한다. 

> 지금은 역제어와 순차적 실행이 혼재되어 있다. 

|                              | 역제어                              | 순차적으로 실행                      |
| ---------------------------- | ----------------------------------- | ------------------------------------ |
| **DI(Dependency Injection)** | 외부에서 사용할 객체를 제공         | 사용하는 쪽에서 객체를 준비          |
| **Event Listener**           | 특정 상태에 놓일 때 메서드가 호출됨 | 개발자가 명시적으로 메서드 호출한다. |



## Reflection API

### 클래스 로딩

- 클래스가 로딩되어 있지 않다는 조건
  - 클래스의 스태틱 멤버(변수, 메서드, 중첩클래스)를 사용할 때 
  - `new` 명령을 사용하여 인스턴스를 생성하려 할 때 
  - `Class.forName()`을 이용하여 **임의로 클래스를 로딩**할 때
    - 파라미터로 패키지명을 포함한 전체 클래스 이름을 지정해야 한다.
    - FQName(QName; fully qualified class name): 패키지명을 포함한 전체 클래스 이름

- 클래스 **로딩 과정**에서 하는 일
  - **스태틱 변수를 준비**한다.
  - **스태틱 블록을 실행**한다.
- **레퍼런스 선언은 클래스 로딩과 상관 없다.** `A obj = null`
- 배열 레퍼런스 선언도 클래스 로딩과 상관 없다: `A[] arr`
- 레퍼런스배열도 마찬가지로 클래스 로딩과 상관 없다. 레퍼런스를 100개를 만들든 1000개를 만들든 주소를 담는 변수이기 때문에 클래스 로딩과 상관 없는 것이다. 

```java
// Reflection API : 클래스 로딩
package com.eomcs.reflect.ex01;

class A {
  static int i;

  static void m() {
    i = 100;
  }

  static {
    System.out.println("A 클래스 로딩!");
  }
}


public class Exam01 {

  public static void main(String[] args) throws Exception {
    // 클래스 로딩 과정에서 하는 일
    // => 스태틱 변수를 준비한다.
    // => 스태틱 블록을 실행한다.

    // A.i = 100; // 클래스 로딩 확인!
    // A.m(); // 클래스 로딩 확인!
    // new A(); // 클래스 로딩 확인!
    // new A(); // 클래스는 중복으로 로딩되지 않는다.
    Class.forName("com.eomcs.reflect.ex01.A");

    // A obj = null; // 레퍼런스 선언은 클래스 로딩과 상관 없다.
    // A[] arr; // 배열 레퍼런스 선언도 클래스 로딩과 상관 없다.
    // arr = new A[100]; // 레퍼런스 배열도 마찬가지로 클래스 로딩과 상관없다.

  }

}
```

### 중첩 클래스 로딩

**바깥 클래스와 중첩 클래스는 전혀 다른 클래스**이다. **바깥 클래스가 로딩된다고 중첩 클래스가 로딩되진 않는다**. 그러나 **중첩 클래스를 로딩**하려면 **바깥 클래스를 알아야 하기 때문에** 이 경우 **바깥 클래스도 로딩된다.**

```java
// Reflection API : 중첩 클래스 로딩
package com.eomcs.reflect.ex01;

public class Exam02 {

  static {
    System.out.println("Exam02 로딩됨!");
  }

  static class A {
    static int s_var = 100;
    int i_var = 200;

    static void s_m() {}

    void i_m() {}

    static {
      System.out.println("Exam02의 중첩클래스 A 로딩됨!");
    }
  }

  public static void main(String[] args) throws Exception {
    Class.forName("com.eomcs.reflect.ex01.Exam02");
    // => 바깥 클래스가 로딩되었다고 중첩 클래스가 자동으로 로딩되는 것은 아니다.

    // Class.forName("com.eomcs.reflect.ex01.Exam02$A");
    // => 중첩 클래스는 "바깥클래스명$중첩클래스명" 형식의 이름을 갖는다.
    // => 중첩 클래스를 로딩하려면 바깥 클래스를 알아야 하기 때문에
    // 이 경우 바깥 클래스도 로딩된다.
    // 주의!
    // => 중첩 클래스의 레퍼런스나 인스턴스를 생성할 때는
    // 클래스 이름에 $를 붙이지 않는다.
    com.eomcs.reflect.ex01.Exam02.A obj;
    obj = new com.eomcs.reflect.ex01.Exam02.A();


    // Class.forName("com.eomcs.reflect.ex01.Exam02$A");
    // => 이미 바깥 클래스가 로딩되어 있다면 다시 로딩하지 않는다.
    // => 이미 중첩 클래스가 로딩되어 있다면 다시 로딩하지 않는다.

  }

}

```



### 클래스 로딩과 `class`라는 스태틱 변수

자바의 모든 클래스는 class라는 특별한 스태틱 변수를 갖고 있다. "class" 변수에는 해당 클래스의 정보를 담은 Class 객체의 주소가 저장되어 있다. 즉 다음 코드와 같은 값을 리턴한다.

```java
Class clazz = Class.forName("com.eomcs.reflect.ex01.Exam03$A");
```

하지만 이 방식으로 클래스를 로딩하면 static {} 블록을 실행하지 않는다. 물론 스태틱 멤버를 사용하는 최초의 순간에는 static 블록이 실행될 것이기 때문에 "클래스 로딩 후 스태틱 블록 실행" 명제는 지켜진다. 이 방법이 forName()을 호출하는 것 보다 안 좋은 이유는? forName()의 파라미터는 문자열이다. 즉 외부에서 문자열을 입력 받아 해당 클래스를 임의로 로딩할 수 있지만, "class"라는 스태틱 변수를 사용하는 것은 자바 소스 안에 명확히 해당 클래스를 지정해야 하기 때문에 임의로 다른 클래스를 로딩하는 코드를 작성할 수 없다. 즉 다른 클래스를 로딩하고 싶으면 소스 코드를 변경해야 한다.

```java
Class clazz = A.class; // 클래스가 로딩되지 않는다.
Class clazz = Class.forName("com.eomcs.reflect.ex01.Exam03$A"); // 클래스 로딩
```

결과는 결국 같다. 

`forName()`은 이렇게 프로그램 아규먼트나 키보드 입력을 통해 클래스 이름을 입력받아서 로딩할 수 있다. `Class.forName(className);`  반면 `class` 변수를 사용하게 되면 코드로 이름을 고정하기 때문에 임의로 클래스를 로딩할 수 없다. 다른 클래스를 가져오려면 소스 코드를 변경해야 한다.

```java
// Reflection API : 클래스 로딩과 "class"라는 스태틱 변수
package com.eomcs.reflect.ex01;

import java.util.Scanner;

class X {
  static {
    System.out.println("X 클래스 로딩");
  }
}


class Y {
  static {
    System.out.println("Y 클래스 로딩");
  }
}


class Z {
  static {
    System.out.println("Z 클래스 로딩");
  }
}


public class Exam04 {

  public static void main(String[] args) throws Exception {
    Scanner keyScan = new Scanner(System.in);
    System.out.println("로딩할 클래스명을 입력하시오? ");
    String className = keyScan.nextLine();
    keyScan.close();

    Class clazz = Y.class;
  }

}
```



### 클래스 로딩과 인스턴스 생성

```java
public class Exam05 {

  static class A {
    void m() {
      System.out.println("Hello!");
    }
  }

  public static void main(String[] args) throws Exception {
    Class clazz = Class.forName("com.eomcs.reflect.ex01.Exam05$A");

    // 타입(클래스) 정보만 있다면 인스턴스 생성할 수 있다.
    A obj = (A) clazz.newInstance();
    obj.m();

    // deprecated 메서드이다.
    // 자바는 생성자를 이용하여 인스턴스를 생성할 것을 권고하고 있다.
  }

}
```

- 일반적인 인스턴스 생성
- 클래스 정보를 가지고 인스턴스 생성
  - 클래스 정보를 로딩한다.



### 클래스 정보 추출: 클래스 이름 알아내기

```java
// 클래스 정보 추출 - 클래스 이름 알아내기
package com.eomcs.reflect.ex02;

public class Exam01 {

  static class A {}

  static Object obj = new A () {

  };

  public static void main(String[] args) throws Exception {
    // 1) 패키지 멤버 클래스 
    Class<?> clazz = Class.forName("java.lang.String");

    // 클래스의 타입 객체를 통해 클래스 정보를 추출할 수 있다.
    System.out.println(clazz.getSimpleName()); // String
    System.out.println(clazz.getName()); // java.lang.String
    System.out.println(clazz.getCanonicalName()); // java.lang.String
    System.out.println(clazz.getTypeName()); // java.lang.String

    System.out.println("=================");
    // 2) 중첩 클래스
    Class<?> clazz2 = Class.forName("com.eomcs.reflect.ex02.Exam01$A");

    System.out.println(clazz2.getSimpleName()); // A
    System.out.println(clazz2.getName()); // com.eomcs.reflect.ex02.Exam01$A
    System.out.println(clazz2.getCanonicalName()); // com.eomcs.reflect.ex02.Exam01.A
    System.out.println(clazz2.getTypeName()); // com.eomcs.reflect.ex02.Exam01$A

    // 3) 익명 클래스
    Class<?> clazz3 = obj.getClass();
    System.out.println(clazz3.getSimpleName()); //
    System.out.println(clazz3.getName()); // com.eomcs.reflect.ex02.Exam01$1
    System.out.println(clazz3.getCanonicalName()); // null
    System.out.println(clazz3.getTypeName()); // com.eomcs.reflect.ex02.Exam01$1

  }
}
```

`Class<?>` 컴파일러에게 무슨 클래스인지는 알 바 없고, 경고 띄우지 마! 라고 명령한다. 



### 클래스 정보 추출 - 클래스의 수퍼 클래스 정보 알아내기

```java
package com.eomcs.reflect.ex02;

public class Exam02 {
  static class A {
  }
  static class B extends A {
  }
  static class C extends B {
  }

  public static void main(String[] args) throws Exception {
    Class<?> clazz = Class.forName("com.eomcs.reflect.ex02.Exam02$C");

    // 수퍼 클래스의 타입을 알아내기
    Class<?> superClazz = clazz.getSuperclass();
    System.out.println(superClazz.getName());
    System.out.println(superClazz.getSuperclass().getName());
  }
}

```



### 클래스 정보 추출: 클래스의 중첩 클래스 정보 알아보기

```java
// 클래스 정보 추출 - 클래스의 중첩 클래스 정보 알아내기
package com.eomcs.reflect.ex02;

public class Exam03 {

  static class A {

    static class B {
    } // static nested class

    class C {
    } // non-static nested class == inner class

    public void m() {
      class D {
      } // local class
    }

    public void m2() {
      Object obj = new Object() {}; // anonymous class
    }

    public static class E {
    }

    public class F {
    }

    public interface X {
    }
  }

  public static void main(String[] args) throws Exception {
    Class<?> clazz = Class.forName("com.eomcs.reflect.ex02.Exam03$A");

    // public 으로 공개된 중첩 클래스 및 인터페이스 정보를 가져온다.
    Class<?>[] nestedList = clazz.getClasses();

    for (Class<?> nested : nestedList) {
      System.out.println(nested.getName());
    }

  }

}

```

다음과 같이 `getDeclaredClasses()` 를 사용하면 접근 범위에 상관 없이 모든 중첩 클래스 및 인터페이스 정보를 가져온다. 메서드 안에 정의된 로컬 클래스는 대상이 아니다.

```java
Class<?>[] nestedList = clazz.getDeclaredClasses();
```



```
com.eomcs.reflect.ex02.Exam04$A$B
com.eomcs.reflect.ex02.Exam04$A$C
com.eomcs.reflect.ex02.Exam04$A$E
com.eomcs.reflect.ex02.Exam04$A$F
com.eomcs.reflect.ex02.Exam04$A$G
com.eomcs.reflect.ex02.Exam04$A$H
```



### 구현 인터페이스 정보 알아내기

```java
public class Exam05 {

  static interface A {
  }

  static interface B {
  }

  static interface C {
  }

  static class D implements A, B, C {
  }

  public static void main(String[] args) throws Exception {
    Class<?> clazz = Class.forName("com.eomcs.reflect.ex02.Exam05$D");

    // 해당 클래스가 구현한 인터페이스 정보를 가져온다.
    Class<?>[] list = clazz.getInterfaces();
    for (Class<?> c : list) {
      System.out.println(c.getName());
    }
  }
}
```

`getInterfaces()` => Reflection API를 사용하면 어떤 클래스가 어떤 인터페이스를 구현했는지 알아낼 수 있다. 



### 패키지 정보 알아내기

```java
// 클래스 정보 추출 - 패키지 정보 알아내기
package com.eomcs.reflect.ex02;

public class Exam06 {

  static interface A {
  }

  static interface B {
  }

  static interface C {
  }

  static class D implements A, B, C {
  }

  public static void main(String[] args) throws Exception {
    Class<?> clazz = Class.forName("com.eomcs.reflect.ex02.Exam06$D");

    // 해당 클래스의 패키지 정보를 가져온다.
    Package p = clazz.getPackage();
    System.out.println(p.getName());
  }
}
```

### 메서드 정보 추출 

`getMethods()` 메서드를 사용하면 해당 클래스에 선언된 `public` 메서드와 상속받은 `public` 메서드가 리스트로 반환된다.

```java
Method[] list = clazz.getMethods();
```

```java
// 메서드 정보 추출
package com.eomcs.reflect.ex03;

import java.lang.reflect.Method;

public class Exam01 {
  public static void m1() {}

  public void m2() {}

  protected void m3() {}

  void m4() {}

  private void m5() {}

  public static void main(String[] args) {
    Class<?> clazz = Exam01.class;

    // 클래스에서 메서드 정보를 추출하기
    // => 해당 클래스에 선언된 public 메서드 + 상속 받은 public 메서드
    Method[] list = clazz.getMethods();
    for (Method m : list) {
      System.out.println(m.getName());
    }
  }

}
```

실행결과

```console
main
m2
m1
wait
wait
wait
equals
toString
hashCode
getClass
notify
notifyAll
```



#### 현재 클래스에 선언된 모든 메서드 정보 추출

```java
Method[] list = clazz.getDeclaredMethods();
```

```console
m3
m1
m5
m4
m2
main
```



#### 특정 메서드만 추출

```java
  public static void main(String[] args) throws Exception {
    Class<?> clazz = Exam03.class;

    // 해당 클래스에 선언된 메서드와 상속 받은 메서드까지 포함하여
    // 파라미터가 없는 "m3" 이름을 가진 public 메서드 추출
    // Method m = clazz.getMethod("m3"); // public이 아니기 때문에 못 찾는다.
    Method m = clazz.getMethod("m1"); // OK!
    System.out.println(m.getName());
    System.out.println(clazz.getMethod("toString").getName());
    System.out.println("----------------------");

    // => public 이 아닌 메서드를 찾고 싶다면,
    m = clazz.getDeclaredMethod("m3"); // OK
    System.out.println(m.getName());

    // => 단 현재 클래스에 정의된 메서드를 찾는다.
    // => 상속 받은 메서드는 제외한다.
    System.out.println(clazz.getDeclaredMethod("toString")); // 예외 발생!
    // 상속 받은 메서드는 못찾는다.
  }
}
```

`getMethods`는 상속받은 public 메서드, `getDeclaredMethods()`는 클래스에 선언된 메서드만.

메서드를 찾지 못했을 때는 예외가 발생한다.

```
m1
Exception in thread "main" java.lang.NoSuchMethodException: com.eomcs.reflect.ex03.Exam03.toString()
	at java.lang.Class.getDeclaredMethod(Unknown Source)
toString
----------------------
m3
	at com.eomcs.reflect.ex03.Exam03.main(Exam03.java:34)

```



```java
public class Exam04 {
  public void m1() {}

  public void m2(String s) {}

  public void m3(String s, int i) {}

  public static void main(String[] args) throws Exception {
    Class<?> clazz = Exam04.class;

    // 파라미터가 없는 메서드를 찾을 때는 파라미터의 타입 정보를 넘기지 않는다.
    System.out.println(clazz.getMethod("m1").getName());

    // 파라미터가 있는 메서드를 찾을 때 그 파라미터의 타입 정보를 넘겨야 한다.
    // 타입정보 = 클래스 정보 = Class 객체
    Class<?> parameterType = String.class;
    Method m = clazz.getMethod("m2", parameterType);
    System.out.println(m.getName());

    parameterType = Class.forName("java.lang.String");
    m = clazz.getMethod("m2", parameterType);
    System.out.println(m.getName());

    // primitive 타입도 클래스 정보가 있다.
    // int => int.class
    // byte,short,int,long,float,double,boolean,char 는 비록 클래스는 아니지만,
    // 일반 클래스처럼 타입 정보를 꺼낼 수 있도록 "class"라는 스태틱 변수를 제공한다.
    Class<?> intType = int.class;
    Class<?> stringType = String.class;
    m = clazz.getMethod("m3", stringType, intType);
    System.out.println(m.getName());
    
    // 위 네 줄은 다음과 같다.
    System.out.println(clazz.getMethod("m3", String.class, int.class).getName());
  }
}
```



```m1
m1
m2
m2
m3
m3
```

#### 메서드 호출

```java
public class Exam05 {
  // 스태틱 메서드
  public static void plus(int a, int b) {
    System.out.printf("합계: %d\n", a + b);
  }

  // 인스턴스 메서드
  public void minus(int a, int b) {
    System.out.printf("빼기: %d\n", a - b);
  }

  public static void main(String[] args) throws Exception {
    Class<?> clazz = Exam05.class;

    // 메서드 호출 방법
    // invoke(인스턴스, 아규먼트, ...);
    //

    // 1) 스태틱 메서드를 찾아 호출하기
    Method m = clazz.getMethod("plus", int.class, int.class);

    // => 스태틱 메서드이기 때문에 인스턴스는 지정할 필요가 없다.
    m.invoke(null, 10, 20);


    // 2) 인스턴스 메서드를 찾아 호출하기
    m = clazz.getMethod("minus", int.class, int.class);

    // => 인스턴스 메서드를 호출할 때는 반드시 인스턴스 주소를 넘겨야 한다.
    // m.invoke(null, 10, 20); // 예외 발생!

    Exam05 obj = new Exam05();
    m.invoke(obj, 10, 20); // Reflection API를 사용하여 호출
    obj.minus(10, 20); // 인스턴스 메서드를 일반적으로 호출할 때
  }
}
```

스태틱 메서드의 경우 인스턴스는 지정할 필요가 없다. `m.invoke(null, 10, 20)`

인스턴스 메서드의 경우 메서드를 찾은 다음에 반드시 인스턴스를 생성한 후 인스턴스 주소를 주고 호출해야 한다. 인스턴스 주소가 없으면 인스턴스 메서드를 호출할 수 없다. (null pointer exception)

```java

```

프레임워크를 만들 때나 `m.invoke` 같은 메서드를 사용한다. 프레임워크를 만들 때는 어떤 메서드를 사용하는 쪽에서 만들 지 모르기 때문이다. 이걸 알아야지 스프링 프레임워크의 내부 구조를 알 수 있다.



### 생성자

#### 생성자 정보 가져오기

생성자로부터 파라미터 정보를 가져올 수 있다. `getParameterCount()`는 파라미터 개수를 리턴한다.

```java
public class Exam01 {

  public Exam01() {}

  public Exam01(int i) {}

  public Exam01(String s, int i) {}

  public static void main(String[] args) {
    Class<?> clazz = Exam01.class;

    // 생성자 목록 가져오기
    Constructor<?>[] list = clazz.getConstructors();
    for (Constructor<?> c : list) {
      System.out.printf("%s(%d)\n", c.getName(), c.getParameterCount());
    }
  }
}
```

실행결과

```
com.eomcs.reflect.ex04.Exam01(2)
com.eomcs.reflect.ex04.Exam01(1)
com.eomcs.reflect.ex04.Exam01(0)
```



파라미터가 없는 기본 생성자 가져오기

```java
Constructor<?> c = clazz.getConstructor();
```



`getConstructor(가변 파라미터)`: 

```java
// 생성자 : 특정 생성자 정보 가져오기
package com.eomcs.reflect.ex04;

import java.lang.reflect.Constructor;

public class Exam02 {

  public Exam02() {}

  public Exam02(int i) {}

  public Exam02(String s, int i) {}

  public static void main(String[] args) throws Exception {
    Class<?> clazz = Exam02.class;

    // 특정 생성자만 가져오기
    Constructor<?> c = clazz.getConstructor();
    System.out.printf("%s(%d)\n", c.getName(), c.getParameterCount());


    // int 값을 받는 생성자 가져오기
    Constructor<?> c2 = clazz.getConstructor(int.class);
    System.out.printf("%s(%d)\n", c2.getName(), c2.getParameterCount());

    // String과  int 값을 순서대로 받는 생성자 가져오기
    Constructor<?> c3 = clazz.getConstructor(String.class, int.class);
    System.out.printf("%s(%d)\n", c3.getName(), c3.getParameterCount());

    // 해당 타입의 값을 받는 생성자가 없을 때?
    // 예외 발생 (리턴값이 null이 아니다)
    Constructor<?> c4 = clazz.getConstructor(String.class);
    System.out.printf("%s(%d)\n", c4.getName(), c4.getParameterCount());
  }
}
```
파라미터 타입이 클래스인 것은 파라미터의 타입 정보를 가져가라는 것이다.

```
com.eomcs.reflect.ex04.Exam02(0)
com.eomcs.reflect.ex04.Exam02(1)
com.eomcs.reflect.ex04.Exam02(2)
Exception in thread "main" java.lang.NoSuchMethodException: com.eomcs.reflect.ex04.Exam02.<init>(java.lang.String)
	at java.lang.Class.getConstructor0(Unknown Source)
	at java.lang.Class.getConstructor(Unknown Source)
	at com.eomcs.reflect.ex04.Exam02.main(Exam02.java:32)
```



#### 생성자 호출하기

```java
// 생성자 : 생성자 호출하기
package com.eomcs.reflect.ex04;

import java.lang.reflect.Constructor;

public class Exam03 {
  int value;

  public Exam03(int i) {
    this.value = i;
  }

  public void print() {
    System.out.printf("value=%d\n", this.value);
  }

  public static void main(String[] args) throws Exception {
    Class<?> clazz = Exam03.class;

    // newInstance()는 객체를 생성한 후 기본 생성자를 호출한다.
    // Exam03은 기본 생성자가 없기 때문에 실행 오류가 발생한다!
    // Exam03 obj = (Exam03) clazz.newInstance(); // 실행 오류!

    // 해결=> 생성자를 준비한다.
    Constructor<?> c = clazz.getConstructor(int.class);

    // 생성자 객체를 통해 인스턴스를 생성해야 한다.
    // autoBoxing해서 들어가고, autoUnboxing해서 실제 메서드에 넘겨준다.
    Exam03 obj = (Exam03) c.newInstance(200);
    obj.print();
  }
}
```

생성자 객체를 통해서 인스턴스를 생성한다.



### 파라미터

#### 파라미터 정보 알아내기

```java
public class Exam01 {

  public void m1(String name, int age) {}

  public void m2() {}

  public void m3(File file, String name) {}

  public static void main(String[] ok) {
    Class<?> clazz = Exam01.class;

    // 클래스에 정의된 메서드를 모두 가져온다.
    Method[] methods = clazz.getDeclaredMethods();
    for (Method m : methods) {
      System.out.printf("%s:\n", m.getName());

      // 메서드의 파라미터 정보를 가져온다.
      Parameter[] parameters = m.getParameters();
      for (Parameter p : parameters) {
        System.out.printf(" %s : %s\n", p.getName(), p.getType().getName());
      }
    }
  }

}

```

실행 결과

```
m2:
m3:
 arg0 : java.io.File
 arg1 : java.lang.String
m1:
 arg0 : java.lang.String
 arg1 : int
main:
 arg0 : [Ljava.lang.String;
```

파라미터의 이름은 argx 행태로 되어 있다. .class 파일에는 분명히 파라미터 이름이 보관되어 있지만, Reflection API에서는 보관된 값을 꺼낼 수 없다. 꺼내려면 직접 .class 파일을 읽어서 파라미터 정보를 알아내야 한다. 컴파일할 때 파라미터 이름을 Reflection API에서 꺼낼 수 있도록 설정해준다면, 그렇다면 원래의 파라미터 이름을 알아낼 수 있다. 즉 -parameters 옵션을 추가하여 컴파일하면 Reflection API로 파라미터 이름을 `> javac -d bin/main -encoding UTF-8 -parameters src/com/eomcs/reflect/ex05/Exam01.java`. 그런데 일반적으로 이 옵션을 붙여 컴파일 하지 않는다. 그럼에도 불구하고 Spring Framework나 eclipse IDE에서는 메서드의 파라미터 이름을 정확하게 추출한다. 그것은 Spring 프레임워크나 이크립스 IDE가 **직접 .class 파일을 읽고 분석해서 해당 정보를 추출**하기 때문이다.

이클립스 Compiler 옵션: Store information about method 를 체크하면 리플렉션 API를 사용해서 정확하게 그 이름을 꺼낼 수 있다.

리플랙션에서 꺼낼려면 `-parameters`를 사용해서 명확하게 따로 저장해야 한다. 그럼 그만큼 메모리를 더 많이 차지한다. 



### 리턴 타입

만약 배열일 경우는 

```java
public class Exam02 {

  public String m1(String name, int age) {
    return null;
  }

  public char[] m2() {
    return null;
  }

  public ArrayList<String> m3(File file, String name) {
    return null;
  }

  public void m4() {}

  public static void main(String[] ok) {
    Class<?> clazz = Exam02.class;

    // 클래스에 정의된 메서드를 모두 가져온다.
    Method[] methods = clazz.getDeclaredMethods();
    for (Method m : methods) {
      System.out.printf("%s:\n", m.getName());

      // 메서드의 리턴 타입 가져오기
      Class<?> returnType = m.getReturnType();
      System.out.printf("    리턴: %s\n", returnType.getName());
    }
  }

}
```



```java
public class Exam02 {

  public String m1(String name, int age) {
    return null;
  }

  public char[] m2() {
    return null;
  }

  public ArrayList<String> m3(File file, String name) {
    return null;
  }
  
  public void m4() {}

  public Map<String, File> m5() {
    return null;
  }

  public static void main(String[] ok) {
    Class<?> clazz = Exam02.class;

    Method[] methods = clazz.getDeclaredMethods();
    for (Method m : methods) {
      System.out.printf("%s:\n", m.getName());
      System.out.println("리턴타입: " + m.getReturnType().getTypeName());
      // 메서드의 리턴 타입 가져오기
      Type returnType = m.getGenericReturnType();
      if (returnType instanceof ParameterizedType) {
        Type[] typeArguments = ((ParameterizedType)returnType).getActualTypeArguments();
        for (Type typeArgument : typeArguments) {
          System.out.println("제네릭 타입:" + typeArgument.getTypeName());
        }
      }
    }
  }
}
```







### 애노테이션 유지 정책

애노테이션 유지 정책을 RUNTIME이라고 지정하면 해당 애노테이션은 `.class` 파일에도 남아 있고, 실행 중에 추출할 수 있다.

```java
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation3 {
    String value();
}
```

RetentionPolicy에서는 CLASS, RUNTIME, SOURCE가 있다. 

``` java
// 애노테이션의 유지 정책을 지정하지 않으면 기본이 CLASS이다.
@Retention(RetentionPolicy.CLASS)
public @interface MyAnnotation {
    String value();
}
```

소스

```java
// 애노테이션 유지 정책을 SOURCE라고 지정하면 
// 해당 애노테이션은 컴파일할 때 제거된다.
@Retention(RetentionPolicy.SOURCE)
public @interface MyAnnotation2 {
    String value();
}
```

애노테이션 사용

```java
@MyAnnotation(value="값") // 유지정책 => CLASS 
@MyAnnotation2(value="값") // 유지정책 => SOURCE 
@MyAnnotation3(value="값") // 유지정책 => RUNTIME 
public class MyClass  {
}
```

클래스 파일을 보면 MyAnnotation2는 없는데, 이는 SOURCE로 애노테이션 유지 정책을 설정하면 컴파일 할 때 제거되기 때문이다.

애노테이션 확인

```java
// 애노테이션 확인
package com.eomcs.annotation.ex2;

public class Exam01 {

  public static void main(String[] args) {
    // 클래스 정보 객체로부터 애노테이션 정보 추출
    Class<?> clazz = MyClass.class;

    // => 유지정책 : CLASS
    MyAnnotation obj = clazz.getAnnotation(MyAnnotation.class);
    if (obj == null) {
      System.out.println("MyAnnotation을 추출할 수 없습니다!");
    }

    // => 유지정책 : SOURCE
    MyAnnotation2 obj2 = clazz.getAnnotation(MyAnnotation2.class);
    if (obj2 == null) {
      System.out.println("MyAnnotation2를 추출할 수 없습니다!");
    }

    // => 유지정책 : RUNTIME
    MyAnnotation3 obj3 = clazz.getAnnotation(MyAnnotation3.class);
    if (obj3 == null) {
      System.out.println("MyAnnotation3를 추출할 수 없습니다!");
    } else {
      // 값을 꺼낼 때는 메서드 호출하듯이 꺼내면 된다.
      System.out.println("MyAnnotation3.value=" + obj3.value());
    }

  }
}
```



```
MyAnnotation을 추출할 수 없습니다!
MyAnnotation2를 추출할 수 없습니다!
MyAnnotation3.value=값
```

MyAnnotation2는 당연히 없다.  .class 파일에 아예 없기 때문이다. 그런데 MyAnnotation은 왜 추출할 수 없을까? class일 경우 리플랙션 API로 추출할 수 없다. 오직 추출할 수 있는 것은 retention 정책이 RUNTIME으로 설정한 애노테이션이다.



### 애노테이션 프로퍼티

####  필수 프로퍼티

```java
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation {
    String value(); // default 값을 지정하지 않으면 필수 프로퍼티
                    // 즉 애노테이션을 사용할 때 반드시 값을 지정해야 한다.
}
```

#### 선택 프로퍼티

```java
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation2 {
    String value() default "홍길동"; 
        // default 값이 있으면, 
        // 애노테이션을 사용할 때 값을 지정하지 않아도 된다.
}
```

#### 애노테이션 프로퍼티 값 지정하기

```java
// 애노테이션 프로퍼티 값 지정하기
package com.eomcs.annotation.ex3;

// must define attribute value
// @MyAnnotation // 필수 프로퍼티 값을 지정하지 않으면 컴파일 오류!
@MyAnnotation(value="값") // OK!
@MyAnnotation2 // 애노테이션의 프로퍼티 값을 지정하지 않으면 default 값이 사용된다.
// @MyAnnotation2(value="물론 이렇게 프로퍼티 값을 지정해도 된다.")
public class MyClass {
}

```



### 애노테이션 프로퍼티 값 지정하기

#### value 프로퍼티

```java
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation {
    String value();
}
```

#### 일반 프로퍼티

```java
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation2 {
    String tel(); 
}
```

#### 프로퍼티 생략 

```java
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation3 {
  String value();
  String tel();
}
```





#### 프로퍼티 이름 생략

```java
// 애노테이션 프로퍼티 값 지정하기 - 프로퍼티 이름 생략
package com.eomcs.annotation.ex4;

// @MyAnnotation(value="홍길동") // OK!
@MyAnnotation("홍길동") // OK! value 프로퍼티는 이름 생략 가능!
public class MyClass {
}
```



```java
// 애노테이션 프로퍼티 값 지정하기 - 프로퍼티 이름 생략
package com.eomcs.annotation.ex4;

@MyAnnotation2(tel = "222-2222") // OK!
// @MyAnnotation2("222-2222") // value 속성이 아닌 경우 생략 불가!
public class MyClass2 {
}

```

tel 프로퍼티는 필수이다. 반드시 값을 지정해야 한다. 값을 지정하지 않으면 

```java
// 애노테이션 프로퍼티 값 지정하기 - 프로퍼티 이름 생략
package com.eomcs.annotation.ex4;

@MyAnnotation3(value = "홍길동", tel = "222-2222") // OK!

// @MyAnnotation3(tel = "222-2222", value = "홍길동") // OK!
// => 프로퍼티 값을 설정할 때 순서는 상관없다.

// @MyAnnotation3("홍길동",tel="222-2222")
// value 외 다른 프로퍼티 값도 지정할 경우,
// value 이름 생략 불가!
// value 값만 지정할 때 생략 가능!
public class MyClass3 {
}

```







```java
@RequestMapping(value="/board")
```



### 배열 애노테이션

배열이 아닐 때

```java
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation {
    String v1() default "가나다";
    int v2() default 100;
    float v3() default 3.14f;
}
```

배열 프로퍼티의 기본값을 지정할 때 중괄호를 사용한다.

```java
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation2 {
    // 배열 프로퍼티의 기본 값을 지정할 때 중괄호를 사용한다.
    String[] v1() default {"가나다","라마바"};
    int[] v2() default {100,200};
    float[] v3() default {3.14f,5.14f};
}
```

배열값이 한 개일 경우 중괄호를 생략할 수 있다.

```java
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation3 {
    // 배열 값이 한 개일 경우 중괄호를 생략할 수 있다.
    String[] v1() default "가나다";
    int[] v2() default 100;
    float[] v3() default 3.14f;
}
```



배열 값 추출

```java
// 애노테이션 프로퍼티 값 추출 - 배열 값 추출
package com.eomcs.annotation.ex5;

public class Exam02 {

  public static void main(String[] args) {
    Class<?> clazz = MyClass2.class;
    MyAnnotation2 obj = clazz.getAnnotation(MyAnnotation2.class);

    System.out.println(obj.v1()[0]);
    System.out.println(obj.v2()[0]);

    float[] values = obj.v3();
    System.out.println(values[0]);

    System.out.println(obj.v1()[1]);
    System.out.println(obj.v2()[1]);
    System.out.println(values[1]);

  }
}
```

```console
가나다
100
3.14
라마바
200
5.14
```



#### 배열 값 지정

```java
@MyAnnotation3(
    // 배열 값을 지정할 때 중괄호를 사용한다.
    v1 = {"홍길동", "임꺽정", "유관순"}, //
    v2 = {1000, 2000, 3000, 4000, 5000}, //
    v3 = {1.12f, 2.23f, 3, 34f})
public class MyClass4 {
}
```



```java
public static void main(String[] args) {
  Class<?> clazz = MyClass4.class;
  MyAnnotation3 obj = clazz.getAnnotation(MyAnnotation3.class);

  printValues(obj.v1()); // 홍길동, 임꺽정, 유관순, 
  printValues(obj.v2()); // 1000, 2000, 3000, 4000, 5000, 
  printValues(obj.v3()); // 1.12, 2.23, 3.0, 34.0, 
}
```



```java
@MyAnnotation3(
        // 배열 값이 한 개일 경우 중괄호를 생략할 수 있다.
        v1="임꺽정",
        v2=1111,
        v3=1.11f)
public class MyClass5 {
}
```

```console
임꺽정, 
1111, 
1.11, 
```



**로그인**

원래 pageController에서 `RequestMapping(value="{/auth}")`이렇게 해야 한다. 그러나 값이 한 개일 때는 중괄호 생략이 가능하고, 

```java
@RequestMapping(value="login", method=Request.getMethod())
```



### 애노테이션 적용 범위

`@Target`을 사용하여 **애노테이션을 붙일 수 있는 범위**를 지정할 수 있다. `ElementType.METHOD`일 때는 메서드만 가능하다. 클래스나 필드는 불가능하다. 애노테이션을 붙이는 목표 지점을 통제할 수 있다. `ElementType.Type`하면 클래스, 인터페이스 선언부에도 애노테이션을 붙일 수 있다.

```java
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation {
  String v1() default "가나다";
}
```



`@Controller`는 클래스에만 붙일 수 있다.

`@Autowired`는 메서드가 아니라 필드에만 붙일 수 있다. 



## 스프링

### IoC 컨테이너

- bean container 라고도 부른다.
- 인스턴스의 생성과 관리를 담당한다.
- 각 객체가 의존하는 객체(dependency)를 주입한다. "의존 객체 주입(dependency injection; DI)"이라 부른다. 그래서 "DI 컨테이너"라고도 부른다.



#### Spring IoC 컨테이너

- spring.io 사이트에서 제공하는 프레임워크이다.
- 프로젝트에 Spring IoC 컨테이너 포함하기
  - mvnrepository.com 또는 search.maven.org에서 spring-context 로 라이브러리를 검색한다.
  - build.gradle 에 의존 라이브러리 정보를 추가한다.

![image](https://user-images.githubusercontent.com/50407047/102052144-0f86b600-3e29-11eb-8194-2e5e4d3e4dda.png)





![image](https://user-images.githubusercontent.com/50407047/102052062-f251e780-3e28-11eb-8855-9633a8df1024.png)

ApplicationContext 구현체(implements, 인터페이스를 구현한 클래스 또는 그 클래스의 인스턴스)의 종류



```java
ApplicationContext iocContainer = new ClassPathXmlApplicationContext(//
  "com/eomcs/spring/ioc/ex01/a/application-context.xml");
```



#### 2. 운영체제의 파일 시스템에서 설정 파일을 찾는 IoC 컨테이너

- 자바 classpath가 아닌 다른 폴더에 설정파일이 있을 경우 사용한다.
- 설정 파일 경로를 지정할 때 파일 시스템 경로를 지정해야 한다.
- 단, URL 형식으로 지정해야 한다.
- 예: file://설정파일경로
- URL 형식에서는 파일 시스템을 가리킬 때 접두어 `file://`를 붙인다.
- 절대 경로를 설정하는 것이기 때문에 사용하지 않는 것이 좋다.



#### 3. 자바 클래스 파일의 애노테이션으로부터 설정 정보를 추출한다.

- 현업에서 가장 많이 사용하는 방법이다.
- 자바 클래스로 설정 정보를 다루는 것을 'Java Config' 라 부른다.
- 생성자 파라미터로 Java Config 클래스의 타입 정보를 넘긴다.

```java
public class Exam01 {
  public static void main(String[] args) {
    // 3) 자바 클래스 파일의 애노테이션으로부터 설정 정보를 추출한다.
    // => 자바 클래스로 설정 정보를 다루는 것을 'Java Config' 라 부른다.
    // => 생성자 파라미터로 Java Config 클래스의 타입 정보를 넘긴다.
    ApplicationContext iocContainer = new AnnotationConfigApplicationContext(//
        AppConfig.class);

    System.out.println("실행 완료!");
  }
}
```



```java
// 클래스 선언부에 애노테이션으로 스프링 설정에 관한 정보를 지정할 수 있다.
public class AppConfig {
  // 필드나 메서드로 스프링 관련 설정을 수행할 수 있다.
}
```



### XML 방식과 App 방식의 비교

#### XML Config

```java
public class Exam01 {
  public static void main(String[] args) {
    ApplicationContext iocContainer = new ClassPathXmlApplicationContext(//
        "com/eomcs/spring/ioc/ex01/d/application-context.xml");

    // 현재 IoC 컨테이너에 들어 있는 객체를 출력해 보자.
    SpringUtils.printBeanList(iocContainer);

    System.out.println("실행 완료!");
  }
}
```





### IoC 컨테이너에 들어 있는 객체 알아내기

- 빈(bean) = 객체(object) = 인스턴스(instance)
- 자바 객체 생성 규칙에 따라 만든 인스턴스를 부르는 말이었다.
- 그러나 일반적으로 객체를 부를 때도 '빈'이라는 용어를 사용한다.

```java

public class SpringUtils {
  public static void printBeanList(ApplicationContext iocContainer) {
    // IoC 컨테이너에 들어있는 객체 알아내기
    // 빈(bean) = 객체(object) = 인스턴스(instance)
    // 자바 객체 생성 규칙에 따라 만든 인스턴스를 부르는 말이었다.
    // 그러나 일반적으로 객체를 부를 때도 '빈'이라는 용어를 사용한다.
    System.out.println("--------------------------------");
    int count = iocContainer.getBeanDefinitionCount();
    System.out.printf("빈 개수: %d\n", count);

    String[] beanNames = iocContainer.getBeanDefinitionNames();
    for (String name : beanNames) {
      System.out.printf("%s = %s\n", 
          name, iocContainer.getBean(name).getClass().getName());
    }
    System.out.println("--------------------------------");
  }

  public static void printBeanAliases(
      ApplicationContext iocContainer, String beanName) {
    System.out.printf("['%s' 빈의 별명 목록]\n", beanName);
    String[] aliases = iocContainer.getAliases(beanName);
    for (String alias : aliases) {
      System.out.println(alias);
    }
  }

  public static void printBeanNames(ApplicationContext iocContainer) {
    System.out.println("[생성된 빈의 이름 목록]");
    String[] names = iocContainer.getBeanDefinitionNames();
    for (String name : names) {
      System.out.println(name);
    }
    System.out.println("-----------------------------------");
  }
}
```

xml

```java
public class Exam01 {
  public static void main(String[] args) {
    ApplicationContext iocContainer = new ClassPathXmlApplicationContext(//
        "com/eomcs/spring/ioc/ex01/d/application-context.xml");

    // 현재 IoC 컨테이너에 들어 있는 객체를 출력해 보자.
    SpringUtils.printBeanList(iocContainer);

    System.out.println("실행 완료!");
  }
}
```

```
--------------------------------
빈 개수: 0
--------------------------------
실행 완료!
```



애노테이션

```java
public class Exam02 {
  public static void main(String[] args) {
    ApplicationContext iocContainer = new AnnotationConfigApplicationContext(//
        AppConfig.class);

    // 현재 IoC 컨테이너에 들어 있는 객체를 출력해 보자.
    SpringUtils.printBeanList(iocContainer);

    // AnnotationConfigApplicationContext는
    // 애노테이션 처리에 필요한 도구를 기본 포함하고 있다.
    // 또한 Java Config 클래스(AppConfig)의 객체도 포함한다.


    System.out.println("실행 완료!");
  }
}
```

실행결과

```
--------------------------------
빈 개수: 6
org.springframework.context.annotation.internalConfigurationAnnotationProcessor = org.springframework.context.annotation.ConfigurationClassPostProcessor
org.springframework.context.annotation.internalAutowiredAnnotationProcessor = org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor
org.springframework.context.annotation.internalCommonAnnotationProcessor = org.springframework.context.annotation.CommonAnnotationBeanPostProcessor
org.springframework.context.event.internalEventListenerProcessor = org.springframework.context.event.EventListenerMethodProcessor
org.springframework.context.event.internalEventListenerFactory = org.springframework.context.event.DefaultEventListenerFactory
appConfig = com.eomcs.spring.ioc.ex01.d.AppConfig
--------------------------------
실행 완료!
```

위와 같이 AnnotationConfigApplicationContext는 애노테이션 처리에 필요한 도구를 기본 포함하고 있다. 또한 Java Config 클래스(AppConfig)의 객체도 포함한다.

**application-context**

```xml
<bean id="c1" class="com.eomcs.spring.ioc.ex01.Car"/>
```

결과

```
--------------------------------
빈 개수: 1
c1 = com.eomcs.spring.ioc.ex01.Car
--------------------------------
실행 완료!
```

**AppConfig**

클래스 선언부에 애노테이션으로 스프링 설정에 관한 정보를 지정할 수 있다.

```java
public class AppConfig {

  // 객체 생성
  @Bean // 주석으로 막으면 스프링 IoC 컨테이너가 자동으로 실행하지 않는다.
  public Car c1() {
    return new Car();
  }
}
```

즉 `@Bean`을 하면 의미있는 메서드가 된다.



클래스를 찾을 패키지를 지정한다. 그러면 IoC 컨테이너는 `@Component` 등의 애노테이션이 붙은 클래스를 찾아 인스턴스를 생성하여 보관한다.

```xml
<context:component-scan base-package="com.eomcs.spring.ioc.ex01"/>
```

`xmlConfig`와 `javaConfig` 두 개가 있다. 

```java
@ComponentScan("com.eomcs.spring.ioc.ex01")
public class AppConfig {

}
```



### IoC 컨테이너에서 객체 꺼내기

```xml
<!-- 객체 생성 -->
  <bean id="c1" class="com.eomcs.spring.ioc.ex01.Car"/>
```

Spring IoC 컨테이너가 객체를 생성하고 c1으로 보관한다는 뜻이다.



**이름**이나 **타입 정보**로 객체를 꺼낼 수 있다.

```java
// 1) 객체 이름으로 꺼내기
// c1이라는 이름으로 저장된 객체를 꺼내라.
System.out.println(iocContainer.getBean("c1"));

// 2) 객체 타입으로 꺼내기
// Car 타입의 객체를 꺼내라.
System.out.println(iocContainer.getBean(Car.class));
```

해당 이름의 객체가 들어 있지 않다면 **null을 리턴하는 것이 아니라 예외가 발생한다.**

```java
// 존재하지 않는 객체 꺼내기
System.out.println(iocContainer.getBean("c2"));

// 해당 이름의 객체가 들어 있지 않다면,
// => null을 리턴하는 것이 아니라 예외가 발생한다.
```

```console
xception in thread "main" org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named 'c2' available
```



IoC 컨테이너가 생성해야 할 객체에 대한 정보 설정하기

IoC 컨테이너에게 Car라는 클래스를 찾아 객체를 생성해서 c1라는 이름으로 저장하라. 는 명령이다.

```xml
<!-- IoC 컨테이너가 생성해야 할 객체에 대한 정보 설정하기 
         => IoC 컨테이너는 다음 태그를 보고 설정된 정보에 따라 객체를 생성한다.
    -->

<!-- id: 빈의 이름. 생성된 객체를 컨테이너에 보관할 때 사용할 key.
         class: 빈의 클래스명. 생성할 객체의 클래스 정보. 
         반드시 fully-qualified class name(FQName, QName) 이어야 한다.
         =>  Spring IoC 컨테이너는 기본 생성자를 호출하여 객체를 생성한다.
    -->
<bean id="c1" class="com.eomcs.spring.ioc.ex02.Car"></bean>

<!-- 시작 태그와 끝 태그 사이에 내용이 없다면 끝 태그를 생략할 수 있다.
         단 생략을 표시하기 위해 반드시 시작태그의 끝에 /을 붙여라 -->
<bean id="c2" class="com.eomcs.spring.ioc.ex02.Car"/>  
```



### 빈의 이름을 지정하는 다양한 방법

```xml
<!-- 빈의 이름을 지정하는 다양한 방법 -->

<!-- id: 빈의 이름 -->
<bean id="c1" class="com.eomcs.spring.ioc.ex02.Car"/>

<!-- id 전체가 하나의 문자열로 취급된다.  
       즉 "c11 c12 c13" 문자열이 객체 아이디로 사용된다.-->
<bean id="c11 c12 c13" class="com.eomcs.spring.ioc.ex02.Car"/>

<!-- name: 빈의 별명 -->
<bean id="c2" name="c3" class="com.eomcs.spring.ioc.ex02.Car"/>   

<!-- id를 지정하지 않고 name만 지정하면 name이 id로 사용된다. -->
<bean name="c4" class="com.eomcs.spring.ioc.ex02.Car"/>  

<!-- name 속성에 여러 개의 별명을 지정할 수 있다. -->
<bean id="c5" name="c51 c52 c53" class="com.eomcs.spring.ioc.ex02.Car"/>  
<bean id="c6" name="c61,c62,c63" class="com.eomcs.spring.ioc.ex02.Car"/>  
<bean id="c7" name="c71;c72;c73" class="com.eomcs.spring.ioc.ex02.Car"/> 

<!-- name 속성에 여러 개의 별명을 입력할 때 공백, 콤마(,), 세미콜론(;)을 
         사용할 수 있다. 그 외에는 불가하다! -->
<bean id="c8" name="c81:c82:c83" class="com.eomcs.spring.ioc.ex02.Car"/>  

<!-- id 없이 name에 여러 개의 별명을 지정할 때는 그 중에서 첫 번째 별명이 
         id로 사용된다. -->
<bean name="c91 c92 c93" class="com.eomcs.spring.ioc.ex02.Car"/>

```

> 콤마, 세미콜론으로 하지 말고 그냥 공백으로 구분하자.

> 그러니까 id나 name 둘 중에 하나만 쓰자. 

```console
c1 = com.eomcs.spring.ioc.ex02.Car
c11 c12 c13 = com.eomcs.spring.ioc.ex02.Car
c2 = com.eomcs.spring.ioc.ex02.Car
c4 = com.eomcs.spring.ioc.ex02.Car
c5 = com.eomcs.spring.ioc.ex02.Car
c6 = com.eomcs.spring.ioc.ex02.Car
c7 = com.eomcs.spring.ioc.ex02.Car
c8 = com.eomcs.spring.ioc.ex02.Car
c91 = com.eomcs.spring.ioc.ex02.Car
```

### 빈의 별명 알아내기

```java
String[] aliases = iocContainer.getAliases("c91");
System.out.println("[별명]");
for (String alias : aliases) {
  System.out.println(alias); // c93, c92
}
```

- id만 설정한 경우 별명은 없다.
- 별명만 여러개인 경우
  - 첫 번재 별명이 id로 사용된다. 나머지 별명이 별명으로 사용된다.
  - 여러 개의 별명을 지정할 때 공백( )/콤마(,)/세미콜론(;)을 사용하여 별명을 구분할 수 있다. 그 외의 문자는 구분자로 사용할 수 없다. 그래서 "c8" 별명은 한 개 밖에 없다. 왜? 콜론(:)은 구분자로 사용하지 않기 때문이다. 그냥 일반 문자로 취급한다.

- **id든 별명이든 객체를 꺼낼 때는 아무것이나 사용해도 상관 없다.**

  ```java
  System.out.println(iocContainer.getBean("c5")); //ID: 
  System.out.println(iocContainer.getBean("c51")); //별명: 
  ```

### 빈 생성 정책

scope 속성에 빈의 생성 정책을 지정할 수 있다.

- **singleton**: 한 개의 객체만 생성. **지정하지 않으면 기본이 singleton이다.**

  > singleton이라고 명시하지 않으면 singleton이다.

- **prototype**: getBean() 호출할 때마다 생성

  - `getBean()`을 호출할 대마다 새 객체를 만들어 리턴한다.
  - 특별한 경우가 아니면 이 방식을 사용하지 않는다.
  - 객체가 계속 생성되기 때문에 가비지가 많이 발생할 수 있다.
  - 그래서 IoC 컨테이너는 singleton 방식으로 객체를 다룬다.

```java
<!-- scope 속성의 기본 값은 singleton -->
<!-- singleton 객체는 IoC 컨테이너가 생성될 때 미리 준비된다. -->
<bean id="c1" class="com.eomcs.spring.ioc.ex02.Car" />
<bean id="c2" class="com.eomcs.spring.ioc.ex02.Car" scope="singleton"/>

<!-- prototype 객체는 getBean()을 호출할 때 생성된다. -->
<bean id="c3" class="com.eomcs.spring.ioc.ex02.Car" scope="prototype"/>
```



IoC 컨테이너가 생성될 때, "singleton" 객체는 기본으로 생성된다. 객체가 생성되지 않았더라도 빈의 이름은 모두 등록되어 있다.

```java
Car obj1 = (Car) iocContainer.getBean("c1");
Car obj2 = (Car) iocContainer.getBean("c1");
Car obj3 = (Car) iocContainer.getBean("c1");

System.out.println(obj1 == obj2);
System.out.println(obj1 == obj3);
```

singleton으로 설정된 객체는 오직 한 개만 생성된다. getBean()을 여러 번 호출하더라도 같은 객체를 리턴한다.

```java
Car() 생성자 호출됨!
Car() 생성자 호출됨!
true
true
```



### 익명 객체의 이름

- 빈의 이름을 지정하지 않을 경우 FQName과 인덱스 번호가 객체의 이름으로 사용된다. 
- FQName#인덱스번호
- 예) com.eomcs.spring.ioc.ex02.Car#0
- 익명 객체의 수 만큼 인덱스 번호가 증가한다.
- 특히 0번 익명 객체의 별명은 클래스명과 같다. 즉 com.eomcs.spring.ioc.ex02.Car#0 이름을 가진 익명 객체의 별명은 com.eomcs.spring.ioc.ex02.Car 이다.
- 그외 익명 객체는 별명이 붙지 않는다.

```xml
<bean class="com.eomcs.spring.ioc.ex02.Car"/>
<bean class="com.eomcs.spring.ioc.ex02.Car"/>
<bean class="com.eomcs.spring.ioc.ex02.Car"/>
<bean class="com.eomcs.spring.ioc.ex02.Car"/>

<!-- 인덱스 번호는 클래스마다 0부터 시작한다. -->
<bean class="com.eomcs.spring.ioc.ex02.Engine"/>
<bean class="com.eomcs.spring.ioc.ex02.Engine"/>
<bean class="com.eomcs.spring.ioc.ex02.Engine"/>
```

익명 객체의 이름

`getBeanDefinitionNames()`는 컨테이너 안에 저장된 빈 객체를 리턴한다.

```java
System.out.println("[빈 이름]");
String[] names = iocContainer.getBeanDefinitionNames();
for (String name : names) {
  System.out.println(name);
}
```



```java
[빈 이름]
com.eomcs.spring.ioc.ex02.Car#0
com.eomcs.spring.ioc.ex02.Car#1
com.eomcs.spring.ioc.ex02.Car#2
com.eomcs.spring.ioc.ex02.Car#3
com.eomcs.spring.ioc.ex02.Engine#0
com.eomcs.spring.ioc.ex02.Engine#1
com.eomcs.spring.ioc.ex02.Engine#2
```

같은 클래스에 대해 첫 번째 익명 객체만이 별명을 갖는다.

```java
SpringUtils.printBeanAliases(iocContainer, //
"com.eomcs.spring.ioc.ex02.Car#0");
// 같은 클래스에 대해 첫 번째 익명 객체 만이 별명을 갖는다.
System.out.println("------------------");

SpringUtils.printBeanAliases(iocContainer, //
"com.eomcs.spring.ioc.ex02.Car#1");
// 같은 클래스에 대해 두 번째 익명 객체부터는 별명이 없다.

```

```console
['com.eomcs.spring.ioc.ex02.Car#0' 빈의 별명 목록]
com.eomcs.spring.ioc.ex02.Car
------------------
['com.eomcs.spring.ioc.ex02.Car#1' 빈의 별명 목록]
```



### 호출할 생성자 지정하기

**Car**

```java
public class Car {
  String model;
  String maker;
  int cc;

  public Car() {
    System.out.println("Car() 생성자 호출됨!");
  }


  public Car(int cc) {
    System.out.println("Car(int) 생성자 호출됨!");
    this.cc = cc;
  }

  public Car(String model) {
    System.out.println("Car(String) 생성자 호출됨!");
    this.model = model;
  }

  public Car(int cc, String model) {
    System.out.println("Car(int, String) 생성자 호출됨!");
    this.model = model;
    this.cc = cc;
  }
```

**Engine**

```java
public class Engine {
  String maker;
  int valve;
  int cylinder;

  public Engine(String maker) {
    System.out.println("Engine(String) 생성자 호출됨!");
  }
```

- 생성자의 파라미터 값을 주지 않으면 기본 생성자가 호출된다.
- 파라미터 값을 설정하면 그 값에 맞는 생성자가 선택되어 호출된다.
- `<constructor-arg/>` 엘리먼트를 사용하여 호출될 생성자를 지정할 수 있다.
- 즉 생성자를 호출할 때 넘겨줄 값을 지정하면 스프링 IoC 컨테이너는 그 값을 받을 생성자를 찾아 호출한다. 
- 파라미터의 개수가 같은 생성자가 여러 개 있을 경우 스프링 IoC 컨테이너는 내부의 정책에 따라 적절한 생성자를 선택한다. 보통 String 타입이 우선이다. 생성자를 정의한 순서는 상관 없다.
- 인덱스 번호로 아규먼트를 제어하는 것이 권장된다.
- 또한 Car와 같이 생성자를 만들지 않는 것이 좋다.

```xml
<!-- 호출할 생성자 지정하기 -->

<!-- 생성자의 파라미터 값을 주지 않으면 기본 생성자가 호출된다.
  Car() 생성자 호출됨!-->
<bean id="c1" class="com.eomcs.spring.ioc.ex03.Car"/>

<!-- Car(String) 생성자 호출됨!-->
<bean id="c2" class="com.eomcs.spring.ioc.ex03.Car">
  <constructor-arg>
    <value>티코</value>
  </constructor-arg>
</bean>

    <!-- 한 개의 파라미터 값을 받는 생성자가 여러 개 있을 경우,
         String 타입의 값을 받는 생성자가 우선하여 선택된다. 
         생성자를 정의한 순서는 상관없다.
Car(String) 생성자 호출됨!-->
<bean id="c3" class="com.eomcs.spring.ioc.ex03.Car">
  <constructor-arg>
    <value>1980</value>
  </constructor-arg>
</bean>

<!-- 한 개의 파라미터를 가지는 생성자가 여러 개 있을 경우, 
         특정 생성자를 지정하고 싶다면 파라미터의 타입을 지정하라! 
Car(int) 생성자 호출됨!-->
<bean id="c4" class="com.eomcs.spring.ioc.ex03.Car">
  <constructor-arg>
    <value type="int">1980</value>
  </constructor-arg>
</bean>

<!-- 파라미터가 여러 개인 생성자를 호출할 경우 
         IoC 컨테이너가 가장 적합한 생성자를 찾아 호출한다. 
Car(String, int) 생성자 호출됨!-->
<bean id="c5" class="com.eomcs.spring.ioc.ex03.Car">
  <constructor-arg>
    <value type="java.lang.String">소나타</value>
  </constructor-arg>
  <constructor-arg>
    <value type="int">1980</value>
  </constructor-arg>
</bean>
<!-- Car(String, int) 생성자 호출됨!-->
<bean id="c6" class="com.eomcs.spring.ioc.ex03.Car">
  <constructor-arg>
    <value type="int">1980</value>
  </constructor-arg>
  <constructor-arg>
    <value type="java.lang.String">소나타</value>
  </constructor-arg>
</bean>

<!-- 파라미터의 값을 설정할 때 이름을 지정해도 
         개발자가 임의로 특정 생성자를 호출하게 제어할 수 없다.
         IoC 컨테이너가 판단하여 적절한 생성자를 호출한다. -->
<!-- Car(String, int) 생성자 호출됨!-->
<bean id="c7" class="com.eomcs.spring.ioc.ex03.Car">
  <constructor-arg name="cc">
    <value type="int">1980</value>
  </constructor-arg>
  <constructor-arg name="model">
    <value type="java.lang.String">소나타</value>
  </constructor-arg>
</bean>
<!-- Car(String, int) 생성자 호출됨!-->
<bean id="c8" class="com.eomcs.spring.ioc.ex03.Car">
  <constructor-arg name="model">
    <value type="java.lang.String">소나타</value>
  </constructor-arg>
  <constructor-arg name="cc">
    <value type="int">1980</value>
  </constructor-arg>
</bean>

<!-- index 속성을 사용하여 파라미터 값이 들어가는 순서를 지정할 수 있다.
         즉 개발자가 어떤 생성자를 호출할 지 지정할 수 있다. -->
<!-- Car(String, int) 생성자 호출됨!-->
<bean id="c9" class="com.eomcs.spring.ioc.ex03.Car">
  <constructor-arg index="0">
    <value type="java.lang.String">소나타</value>
  </constructor-arg>
  <constructor-arg index="1">
    <value type="int">1980</value>
  </constructor-arg>
</bean>

<!-- Car(int, String) 생성자 호출됨!-->
<bean id="c10" class="com.eomcs.spring.ioc.ex03.Car">
  <constructor-arg index="1">
    <value type="java.lang.String">소나타</value>
  </constructor-arg>
  <constructor-arg index="0">
    <value type="int">1980</value>
  </constructor-arg>
</bean>

<!-- 기본 생성자가 없으면 예외 발생! -->
<!--
    <bean id="e1" class="com.eomcs.spring.ioc.ex03.Engine"/>
    -->
```



#### 생성자의 파라미터 값을 지정하는 간단한 방법

```xml
<!-- 호출할 생성자 지정하기 II -->

<!-- 생성자의 파라미터 값을 지정하는 간단한 방법 -->
<bean id="c1" class="com.eomcs.spring.ioc.ex03.Car">
  <constructor-arg type="java.lang.String" value="티코"/>
</bean>

<!-- index로 파라미터의 순서를 지정하기 -->
<bean id="c2" class="com.eomcs.spring.ioc.ex03.Car">
  <constructor-arg index="0" type="java.lang.String" value="티코"/>
  <constructor-arg index="1" type="int" value="890"/>
</bean>

<!-- value 속성에 지정한 값은 문자열이다.
         생성자를 호출하여 값을 넣을 때 
         IoC 컨테이너는 이 문자열을 파라미터 타입으로 형변환하여 넣는다. 
         단 primitive type에 대해서만 형변환할 수 있다.
         다른 타입은 불가하다 -->
<bean id="c3" class="com.eomcs.spring.ioc.ex03.Car">
  <constructor-arg index="0" value="티코"/>
  <constructor-arg index="1" value="890"/>
</bean>
```



만약 value 속성에 설정한 문자열 값을 생성자의 파라미터 타입의 값으로 형변환 할 수 없다면 실행 오류가 발생할 것이다. 즉 다음에서 value="aaa"는 cc 파라미터의 int 값으로 바꿀 수 없기 때문에 오류 발생!

```xml
<bean id="c4" class="com.eomcs.spring.ioc.ex03.Car">
  <constructor-arg index="0" value="티코"/>
  <constructor-arg index="1" value="aaa"/>
</bean>
```



```console
Related cause: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'c4' defined in class path resource [com/eomcs/spring/ioc/ex03/c/application-context.xml]: Unsatisfied dependency expressed through constructor parameter 1: Could not convert argument value of type [java.lang.String] to required type [int]: Failed to convert value of type 'java.lang.String' to required type 'int'; nested exception is java.lang.NumberFormatException: For input string: "aaa"
```



#### 파라미터를 bean 태그의 속성 값으로 지정

생성자의 파라미터 값을 지정할 때 contstructor-arg 태그가 아닌 **bean 태그의 속성 값으로 지정**할 수 있다. 단, `beans` 태그의 선언부에 `xmlns:c="http://www.springframework.org/schema/c"` 설정을 추가해야 한다. 

```xml
<bean id="c1" class="com.eomcs.spring.ioc.ex03.Car" c:model="티코"/>
<bean id="c2" class="com.eomcs.spring.ioc.ex03.Car" c:cc="1980"/>
<bean id="c3" class="com.eomcs.spring.ioc.ex03.Car" c:model="티코" c:cc="890"/>

<!-- 물론 순서를 지정할 수 있다. 
         => 방법:
           c:_인덱스번호="값"
         => 인덱스는 0부터 시작한다.
    -->
<bean id="c4" class="com.eomcs.spring.ioc.ex03.Car" c:_1="티코" c:_0="890"/>
```

단, 이 방식은 **타입을 지정할 수가 없다**. 이 방법은 직관적이기 때문에 실문에서 많이 쓰인다.

