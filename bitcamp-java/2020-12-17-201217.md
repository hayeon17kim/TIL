## 웹 프로젝트 폴더 생성

프로젝트 폴더 기본 구조

- `build.gradle`: gradle 빌드 도구 설정 파일

- `settings.gradle`: 빌드 대상 프로젝트를 설정하는 스크립트이다. 예를들어 프로젝트 하위에 여러 개의 프로젝트가 담겨있는 멀티 프로젝트 형태인 경우, build 대상이 되는 프로젝트를 지정하는 스크립트 파일이다. 

  ```groovy
  rootProject.name = 'bitcamp-spring-webmvc'
  ```

- `gradlew`: gradle 빌드 도구를 실행시키는 스크립트 파일(unix)

- `gradlew.bat`: gradle 빌드 도구를 실행시키는 스크립트 파일(windows)

- `.gradle/`: gradle이 실행 중에 사용하는 내부 폴더

- `gradle/`: grlade 빌드 도구를 다운로드 받는 자바 프로그램이 들어있는 폴더. `gradlew`와 `gradlew.bat` 스크립트를 실행할 때 사용한다.



그레이들 실행할 때마다 `.gradle`과 `gradle/`은 자동 생성된다. 단 `build.gradle`, `settings.gradle`은 삭제해서는 안 된다. `gradlew`만 실행하면 되다. 

gradle init 를 하면 

```
src/
	main/
		java/
		resources/
	test/
		java/
		resources/
```

폴더가 생긴다.

웹 리소스 파일을 저장할 폴더를 준비한다.

```
src/main/webapp <- 폴더 생성
```

이클립스 IDE 용 웹 프로젝트로 만들기 위해 `build.gradle` 파일을 편집한다.

```groovy
plugins {
	id 'java'
	//id 'application'
	id 'eclipse-wtp'
	id 'war'
}
```

- `application`: 일반 자바 애플리케이션이 아니기 때문에 **삭제한다.**
- `eclipse-wtp`: **이클립스 IDE용 웹 프로젝트 관련 파일을 생성**해주는 플러그인
- `war`: **웹 애플리케이션 배포 파일(`.war`)**을 만들어주는 플러그인

애플리케이션 플러그인을 사용하지 않기 때문에 다음 코드는 삭제한다.

```groovy
application {
  mainClassName = 'com.eomcs.App'
}
```

gradle을 실행하여 이클립스 IDE용 웹 프로젝트 관련 파일을 생성한다.

```
프로젝트폴더$ gradle eclipse
```



**web.xml**

루트로 접근했을 때 우선 index.html로 접근한다.

```xml
<welcome-file-list>
  <welcome-file>index.html</welcome-file>
  <welcome-file>index.htm</welcome-file>
  <welcome-file>default.htm</welcome-file>
</welcome-file-list>
```



### 서블릿 프로그래밍 적용

`servlet-api` 라이브러리를 프로젝트에 등록한다.

`build.gradle` 변경

```groovy
dependencies {
    // compileOnly?
    // - 프로그래밍 하는 동안에만 사용하고 배치할 때는 제외하는 라이브러리를 가리킨다.
    // - 프로그램이 배치되는 런타입 서버(예: 실행 중인 톰캣 서버)에서 
    //   라이브러리를 제공하는 경우 이 옵션으로 프로젝트에 추가한다.
    // => Servlet API 라이브러리
    compileOnly group: 'javax.servlet', name: 'javax.servlet-api', version: '4.0.1'

    // implementation?
    // - 배치할 때도 함께 배치된다.
    // => JSTL 명세를 구현한 라이브러리
    implementation group: 'javax.servlet', name: 'jstl', version: '1.2'

    implementation 'com.google.guava:guava:28.2-jre'

    // testImplementation?
    // - 단위 테스트를 수행할 때만 사용한다. 배치에 포함되지 않는다.
    testImplementation 'junit:junit:4.12'
}
```

group, name, version을 따로 작성해도 되고, `:`로 합쳐도 된다.

- 따로 작성: `implementation group: 'javax.servlet', name: 'jstl', version: '1.2'`
- 합쳐서 작성:`implementation 'javax.servlet:jstl:1.2'`

#### 의존성 옵션

왜 배포파일에는 모든 라이브러리가 놓이지 않을까? `test`, `compileOnly` 등 옵션을 준 라이브러리는 배포 파일에 포함하지 않는다. `compileOnly`는 프로그래밍(컴파일)하는 동안에만 사용한다. 배포 파일(`.jar`, `.war`, `ear`)에는 포함하지 않는다. 프로그램이 배치되는 런타임 서버(예: 실행 중인 톰캣 서버)에서 라이브러리를 제공하는 경우 굳이 배포할 필요가 없기 때문에 이 옵션으로 프로젝트에 추가한다. Servlet 

- `providedCompile`: 마음대로 쓰는 게 아니다.  compileOnly처럼 컴파일할 때만 사용한다. 배포 파일에는 포함하지 않는다. 단 이 옵션은 `war` 플러그인을 사용할 때만 설정할 수 있다.
- `implementation`
  - 컴파일할 때 사용한다.
  - 배포 파일에도 포함한다. 

- `testImplementation`
  - 단위 테스트를 수행할 때만 사용한다.



### 스프링 WebMVC

Spring Web MVC의 프론트 컨트롤러 역할을 수행할 서블릿을 지정한다.

### DispatcherServlet 배치1: 

- DispatcherServlet은 자체적으로 IoC 컨테이너를 보유하고 있다.
- 파라미터를 사용하여 IoC 컨테이너의 설정 파일을 지정한다.
  - 초기화 파라미터명: contextConfigLocation
  - 초기화 파라미터값: 예) /WEB-INF/app-context.xml
- 설정하고 싶지 않다면 init-value를 비워둬라.
- 서블릿을 요청하지 않아도 웹 애플리케이션을 시작시킬 때 자동 생성되어 IoC 컨테이너를 준비하는 초기화 작업을 수행할 수 있도록 `load-on-startup` 옵션을 붙인다.

```xml
  <description>
    스프링 Web MVC 프레임워크 예제 테스트
  </description>

  <display-name>java-spring-webmvc</display-name>

  <servlet>
    <servlet-name>app</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <init-param>
      <param-name>contextConfigLocation</param-name>
      <param-value>/WEB-INF/app-context.xml</param-value>
    </init-param>
    <load-on-startup>1</load-on-startup>
  </servlet>
  <servlet-mapping>
    <servlet-name>app</servlet-name>
    <url-pattern>/app/*</url-pattern>
  </servlet-mapping>
  
  <welcome-file-list>
    <welcome-file>index.html</welcome-file>
    <welcome-file>index.htm</welcome-file>
    <welcome-file>default.htm</welcome-file>
  </welcome-file-list>

</web-app>
```



**app-servlet**

```xml
<context:component-scan base-package="bitcamp"/>
```



**HelloController**

프론트 컨트롤러(DispatcherServlet)가 실행할 페이지 컨트롤러는 `@Controller` 애노테이션을 붙여야 한다. 클라이언트 요청이 들어왔을 때 호출될 메서드(`request handler`)를 표시하려면 다음과 같이 `@RequestMapping` 애노테이션을 붙여야 한다. 

- `RequestMapping("/hello")`
- `RequestMapping(value="/hello")`
- `@RequestMapping(path="/hello")`
- `@RequestMapping({"/hello", "/hello2", "/okok"})`

`@Responsebody`

- **리턴하는 String 값이 뷰 컴포넌트(예: JSP)의 URL이 아닌 경우 애노테이션으로 표시**한다.

- 리턴하는 문자열이 클라이언트에게 보낼 콘텐트임을 표시한다.
- 이 애노테이션이 붙어 있으면 프론트 컨트롤러는 리턴 값을 그대로 클라이언트에게 전송한다.

```java
@Controller
public class HelloController {

  @RequestMapping({"/hello", "/hello2", "/okok"})

  @ResponseBody
  public String hello() throws Exception {
    return "<html><body><h1>Hello!</h1></body></html>";
  }
}

```



### IoC 설정 파일의 위치

DispatcherServlet 배치하기 : 방법2

![클라이언트에서 접근할 수 있다](https://user-images.githubusercontent.com/50407047/102437934-b2744580-405e-11eb-9c09-d4af1ff1d5d0.png)

- /config/app-context.xml 로 위치 이동
  - 클라이언트가 자원을 가져갈 수 있는 경로에는 설정 파일을 두면 안된다.
  - 일반 웹 디렉토리는 클라이언트에서 접근할 수 있기 때문에 설정 정보가 노출될 위험이 있다.  절대로 일반 웹 디렉토리에 두지 말라!
  - `http://localhost:9999/bitcamp-spring-webmvc/config/app-servlet.xml`으로 접근할 수 있다.
- 즉 /config 폴더 같은 위치에는 설정파일을 두지 말라.
  - /WEB-INF/web.xml 변경



## src-04 : IoC 설정 파일의 위치 

- /WEB-INF/app-servlet.xml 로 위치 이동 및 이름 변경
- /WEB-INF/web.xml 변경
  - `contextConfigLocation` 초기화 파라미터 **삭제**
  - `/WEB-INF/서블릿이름-servlet.xml` 파일을 기본으로 찾는다.
  - 없으면 예외가 발생한다.
- DispatcherServlet에서 IoC 컨테이너를 설정하기 싫다면,
  - `contextConfigLocation`의 값을 빈채로 두어라.
  - `contextConfigLocation` 파라미터가 없다면 예외가 발생한다.

**webapp/WEB-INF/app-servlet.xml**



**webapp/WEB-INF/web.xml**

DispatcherServlet 배치하기 : 방법3

- **contextConfigLocation 초기화 변수(`<init-param>`)가 없으면**(web.xml에 `init-param`을 등록하지 않으면) 규칙(`/WEB-INF/서블릿이름-servlet.xml)`에 따라 작성된 IoC 설정 파일을 **자동으로 찾는다**.  해당 파일을 찾지 못하면 예외가 발생한다.

  ```console
  java.io.FileNotFoundException: Could not open ServletContext resource [/WEB-INF/app-servlet.xml]
  ```

  - 실무의 경우 `<init-param>`이 없고 `/WEB-INF/app-servlet.xml`이 있을 것이다. 

- contextConfigLocation **초기화 변수가 있다면,**
     - 지정한 설정 파일을 로딩하여 객체를 준비한다.
     - **(`<param-value>`)변수의 값이 비어 있다면, 아무런 객체를 생성하지 않는다.** 
     - **변수가 없을 때와 달리 예외가 발생하지 않는다.**

- 즉 contextConfigLocation **변수를 생략하는 것과 변수의 값을 비워두는 것은 다르다.**



## src-05 : ContextLoaderListener와 DispatcherServlet의 IoC 컨테이너

> 컨텍스트 로더 서블릿을 사용하는 방법

- /WEB-INF/config/app-context.xml 로 위치 이동 및 이름 변경
  - <mvc:annotation-driven/> 태그 추가 
  - ContextLoaderListener는 WebMVC 관련 애노테이션을 처리할 객체가 없기 때문에
    <mvc:annotation-driven/> 태그를 사용하여 별도로 등록해야 한다.
- /WEB-INF/web.xml 변경
  - ContextLoaderListener 추가
  - ContextLoaderListener가 사용할 contextConfigLocation 파라미터 설정
  - DispatcherServlet에 contextConfigLocation 초기화 파라미터 추가. 
    값은 빈채로 된다.

### ContextLoaderListener

- DispatcherServlet 클래스와 달리, ContextLoaderListener의 IoC 컨테이너는 웹 관련 애노테이션을 처리하지 못한다. 

- 따라서 `@Component`, `@Controller`, `@Service` 등의 애노테이션 붙은 클래스에 대해 **객체를 생성해 주지만**, `@RequestMapping`, `@ResponseBody` 등과 같은 **웹 관련 애노테이션은 인식하지 못한다**. 따라서 **페이지 컨트롤러의 요청 핸들러를 관리하는 일을 하지 못한다.** 

- 해결책? 

  - **웹관련 애노테이션을 처리할 도우미 객체를 따로 등록**해야 한다. 

  - 즉 다음과 같이 WebMVC 관련 애노테이션을 처리할 도우미 객체를 등록하라.

  - **DispatcherServlet의 IoC 컨테이너**는 이런 일을 기본으로 하기 때문에 다음과 같은 태그를 선언하지 않아도 페이지 컨트롤러를 처리한다.

  - `app-servlet.xml`

  - ```xml
    <beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:context="http://www.springframework.org/schema/context"
        xmlns:mvc="http://www.springframework.org/schema/mvc"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.springframework.org/schema/beans
            https://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context
            https://www.springframework.org/schema/context/spring-context.xsd
            http://www.springframework.org/schema/mvc
            https://www.springframework.org/schema/mvc/spring-mvc.xsd">
            
    	<context:component-scan base-package="bitcamp"/>
    	<mvc:annotation-driven/> <!-- 도우미 객체 등록 -->
    	
    </beans>
    ```

 ```xml
  <!-- 글로벌 Spring IoC 컨테이너 준비 -->
  <listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
  </listener>  
  
  <!-- ContextLoaderListener가 사용할 IoC 컨테이너 설정 파일 정보 -->
  <context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>/WEB-INF/config/app-context.xml</param-value>
  </context-param>

  <servlet>
    <servlet-name>app</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <init-param>
      <param-name>contextConfigLocation</param-name>
      <param-value></param-value>
    </init-param>
    <load-on-startup>1</load-on-startup>
  </servlet>
  <servlet-mapping>
    <servlet-name>app</servlet-name>
    <url-pattern>/app/*</url-pattern>
  </servlet-mapping>
 ```

DispatcherServlet에서 `contextConfigLocation`이 비어져 있다. 따라서 pageController가 없다. 이때 `context-param`에 `contextConfigLocation`이 있다. `app-context.xml`를 보면

```xml
<context:component-scan base-package="bitcamp"/>
```

컴포넌트를 스캔한다. 



## src-06 : ContextLoaderListener와 DispatcherServlet의 관계

- ContextLoaderListener의 IoC 컨테이너
  - 모든 프론트 컨트롤러 및 페이지 컨트롤러가 공유할 객체를 보관한다.
  - /WEB-INF/config/app-context.xml 변경
  
  
  
- DispatcherServlet의 IoC 컨테이너
  - 페이지 컨트롤러, 인터셉터 등 웹 관련 객체를 보관한다.

  - /WEB-INF/app-servlet.xml 변경

    - config 밑에 두면 안된다.
    - ContextLoaderListener의 IoC 컨테이너가 관리할 객체가 들어 있는 패키지를 지정한다. 
    - 보통 Service, DAO, 트랜잭션 관련 객체 등을 관리한다.

    ```xml
      <context:component-scan base-package="bitcamp.web">
        <context:exclude-filter type="regex" expression="bitcamp.web.admin.*"/>
      </context:component-scan>
    ```

  - /WEB-INF/admin-servlet.xml 추가

    ```xml
      <context:component-scan base-package="bitcamp.web">
        <context:exclude-filter type="regex" expression="bitcamp.web.app.*"/>
      </context:component-scan>
    ```

- /WEB-INF/web.xml 변경

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
  version="4.0" metadata-complete="false">

  <description>
    스프링 Web MVC 프레임워크 예제 테스트
  </description>

  <display-name>java-spring-webmvc</display-name>

  <!-- 글로벌 Spring IoC 컨테이너 준비 -->
  <listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
  </listener>  
  
  <!-- ContextLoaderListener가 사용할 IoC 컨테이너 설정 파일 정보 -->
  <context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>/WEB-INF/config/app-context.xml</param-value>
  </context-param>
  
  <!-- Spring WebMVC의 프론트 컨트롤러 역할을 수행할 서블릿 지정 -->
  <servlet>
    <servlet-name>app</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <!-- 다음 설정은 생략해도 된다. 
    왜? Spring IoC 컨테이너의 설정 파일 이름을 규칙에 따라 작성했기 때문이다. -->
    <!--  
    <init-param>
      <param-name>contextConfigLocation</param-name>
      <param-value>/WEB-INF/app-servlet.xml</param-value>
    </init-param>
    -->
    <load-on-startup>1</load-on-startup>
  </servlet>
  <servlet-mapping>
    <servlet-name>app</servlet-name>
    <url-pattern>/app/*</url-pattern>
  </servlet-mapping>
  
  <servlet>
    <servlet-name>admin</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <load-on-startup>1</load-on-startup>
  </servlet>
  <servlet-mapping>
    <servlet-name>admin</servlet-name>
    <url-pattern>/admin/*</url-pattern>
  </servlet-mapping>
  
  <welcome-file-list>
    <welcome-file>index.html</welcome-file>
    <welcome-file>index.htm</welcome-file>
    <welcome-file>default.htm</welcome-file>
  </welcome-file-list>

</web-app>
```



> 목업객체: 테스트를 위해 임시로 만든 객체

DispatcherServlet은 여러개일 수 있다. 



## src-07 : Java Config로 DispatcherServlet의 IoC 컨테이너 설정하기

- bitcamp.AppConfig 클래스 생성
- /WEB-INF/web.xml 변경

Java Config로 IoC 컨테이너를 지정할 때는 **기본 IoC 컨테이너를 교체**해야 한다. 다음과 같이 **초기화 파라미터**를 통해 **DispatcherServlet이 사용할 IoC 컨테이너 클래스**와 **Java Config 클래스**를 설정한다.

```xml
<servlet>
  <servlet-name>app</servlet-name>
  <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
  <!-- Java Config로 IoC 컨테이너를 지정할 때는 기본 IoC 컨테이너를 교체해야 한다. 
         다음과 같이 초기화 파라미터를 통해 DispatcherServlet이 사용할 
         IoC 컨테이너 클래스와 Java Config 클래스를 설정한다.-->
  <init-param>
    <param-name>contextClass</param-name>
    <param-value>org.springframework.web.context.support.AnnotationConfigWebApplicationContext</param-value>
  </init-param>
  <init-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>bitcamp.AppConfig</param-value>
  </init-param>
  <load-on-startup>1</load-on-startup>
</servlet>
<servlet-mapping>
  <servlet-name>app</servlet-name>
  <url-pattern>/app/*</url-pattern>
</servlet-mapping>
```



**AppConfig**

```java
@ComponentScan("bitcamp")
public class AppConfig {

}
```

XML 설정 파일에서 다음 설정과 같다.

```xml
<context:component-scan base-package="bitcamp"/>
```



gradle을 통해 자동으로 다운로드 받은 라이브러리가 아니라, 별도로(별도폴더에) 다운로드 받은 라이브러리 파일을 프로젝트에 포함(.classpath에 등록)시키는 방법

- `implementation fileTree(dir: '현재 프로젝트 폴더를 기준으로 상대 경로 또는 절대 경로')`

```groovy
implemenation fileTree(
  dir: '현재 프로젝트 폴더를 기준으로 한 상대 경로 또는 절대 경로'
  include: '프로젝트에 포함한 라이브러리 파일들'
)
```





```groovy
implementation fileTree(dir: 'lib', include: '*.jar')
```



```java
public class MyWebInitializerImpl implements MyWebInitializer {
  @Override
  public void start(ServletContext ctx) {
    System.out.println("MyWebInitializerImpl.. ok!");

    AnnotationConfigWebApplicationContext ac = new AnnotationConfigWebApplicationContext();
    ac.register(AppConfig.class);
    ac.refresh();

    DispatcherServlet servlet = new DispatcherServlet(ac);
    Dynamic registration = ctx.addServlet("app", servlet);
    registration.setLoadOnStartup(1);
    registration.addMapping("/app/*");
  }
}

```

Dynamic 객체는 서블릿에 대한 URL을 지정하는 용도로 사용한다. `/app/*`이라는 요청이 들어오면 이 서블릿을 실행하라.

Dynamic 객체에 대해 loadOnStartup을 지정한다.

`MyWebInitializer`은 우리가 만들었는데 어떻게 이게 호출되었을까?

공식문서

```java
public class MyWebApplicationInitializer implements WebApplicationInitializer {

    @Override
    public void onStartup(ServletContext servletCxt) {

        // Load Spring web application configuration
        AnnotationConfigWebApplicationContext ac = new AnnotationConfigWebApplicationContext();
        ac.register(AppConfig.class);
        ac.refresh();

        // Create and register the DispatcherServlet
        DispatcherServlet servlet = new DispatcherServlet(ac);
        ServletRegistration.Dynamic registration = servletCxt.addServlet("app", servlet);
        registration.setLoadOnStartup(1);
        registration.addMapping("/app/*");
    }
}
```



**ServletContextListener**

```java

```



### 서블릿, 필터을 등록하는 두 가지 방법

선언적 방식과 프로그램적 방식이 있다. 

#### 선언적(declaration) 방식

**`web.xml`**, **애노테이션**(`controller`  등) 적어놓은 대로 서블릿 컨테이너가 선언된 것을 읽어서 객체를 만들고 등록할 것이다. 이런 방식의 프로그래밍을 **선언적 방식**이라고 한다. (**declaration**)

#### 프로그램적(programatic) 방식

- 개발자가 직접 서블릿 객체를 만들어서 그 서블릿을 등록한다. 
- 프로그램적으로 등록한다.
- ServletContainerInitializer 인터페이스를 구현한다.
- 

web.xml 이나 애노테이션이 아닌 다른 방법으로 서블릿을 등록하기
// => Servlet API의 표준 기술 활용!



서블릿 컨테이너가 

 서블릿 컨테이너가 시작될 때 보고 받는 객체
 구동 순서:
 1) 서블릿 컨테이너를 시작한다.
 2) 서블릿 컨테이너는 /WEB-INF/lib/*.jar 파일을 뒤진다.
 3) /META-INF/services/javax.servlet.SerlvetContainerInitializer 파일을 찾는다. 
 4) 그 파일에서 선언된 ServletContainerInitializer 구현체를 알아낸다. (fully qualified name)
 5) 해당 구현체의 인스턴스를 생성한 후 onStartup()을 호출한다.
 6) 만약 그 구현체가 보고 받고자 하는 타입이 있다면 해당 클래스를 찾아
 onStartup()을 호출할 때 파라미터로 넘겨준다. (`HandlesTypes()` 애노테이션 안에 있다.)

 WebApplicationInitializer 호출 과정
 1) 서블릿 컨테이너(예: 톰캣 서버)를 시작한다.
 2) spring-web-x.x.x.RELEASE.jar 파일에서
 /META-INF/service/javax.servlet.SerlvetContainerInitializer 파일을 읽는다.
 3) 이 파일에 등록된 클래스의 인스턴스를 생성한다.
 => SpringServletContainerInitializer 인스턴스 생성
 4) SpringServletContainerInitializer 객체에 대해 onStartup()을 호출한다.
 => 호출할 때 WebApplicationInitializer를 구현한 클래스 목록을 넘겨준다.
 5) SpringServletContainerInitializer는
 WebApplicationInitializer 구현체의 인스턴스를 만들고,
 onStartup()을 호출한다.



서블릿 컨테이너가 시작될 때 보고를 받고 싶으면, `ServletContainerInitializer` 규칙에 따라 작성해야 한다. 이 클래스의 전체 이름(패키지명을 포함한 클래스명)을 다음 경로의 파일에 등록해야 한다.

 `/META-INF/services/javax.servlet.ServletContainerInitializer`

서블릿 컨테이너가 시작할 때 실행 과정

- 모든 `*.jar` 파일에서 `META-INF/services/javax.servlet.ServletContainerInitializer` 파일이 있는지 찾는다.
- `javax.servlet.ServletContainerInitializer` 파일 안에 등록된 클래스의 인스턴스를 생성한다.
- `ServletContainerInitializer` 구현 객체에 대해 `onStartup()` 메서드를 호출한다. 
  - `onStartup()` 메서드를 호출할 때 파라미터 값 중에서 `types` 목록 값은 `ServletContainerInitializer` 구현 클래스의 `@HandlesTypes`에 선언된 해당 클래스를 찾아 상속받거나 구현한 모든 클래스들의 목록이다.

- 웹 애플리케이션을 시작한다.
  - `ServletContextListener`의 `contextInitialized()` 메서드를 호출한다.



### web.xml 이나 애노테이션이 아닌 다른 방법으로 서블릿을 등록하기

Servlet API의 표준 기술 활용!

**WebApplicationInitializer**:  **서블릿 컨테이너가 시작될 때 보고 받는** 객체
 구동 순서:

- 서블릿 컨테이너를 시작한다.
- 서블릿 컨테이너는 /WEB-INF/lib/*.jar 파일을 뒤진다.
- /META-INF/services/javax.servlet.SerlvetContainerInitializer 파일을 찾는다
- 그 파일에서 ServletContainerInitializer 구현체를 알아낸다.
- 해당 구현체의 인스턴스를 생성한 후 onStartup()을 호출한다.
- 만약 그 **구현체가 보고 받고자 하는 타입이 있다면 해당 클래스를 찾아 onStartup()을 호출할 때 파라미터로 넘겨준다. **
- 이건 Servlet API 규칙이 아니라 Spring의 규칙이다. 

```java
public class WebApplicationInitializerImpl implements WebApplicationInitializer {

  @Override
  public void onStartup(ServletContext servletContext) throws ServletException {
    System.out.println("WebApplicationInitializerImpl.onStartup()...호출됨!");

    // DispatcherServlet 에서 사용할 스프링 IoC 컨테이너를 준비한다.
    AnnotationConfigWebApplicationContext iocContainer = //
        new AnnotationConfigWebApplicationContext();

    // => IoC 컨테이너의 설정 정보를 갖고 있는 Java Config 클래스를 직접 지정하기
    // iocContainer.register(AppConfig.class);

    // => Java Config 클래스가 있는 패키지를 지정하기
    //    단 이럴 경우 Java Config 클래스에는 @Configuration 애노테이션이나 @ComponentScan("bitcamp") 선언되어 있어야 한다.
    iocContainer.scan("bitcamp");

    iocContainer.refresh();

    // DispatcherServlet 인스턴스를 생성한다.
    DispatcherServlet servlet = new DispatcherServlet(iocContainer);

    // 웹 애플리케이션에 DispatcherServlet을 등록한다.
    Dynamic registration = servletContext.addServlet("app", servlet);

    // 웹 애플리케이션에 등록된 DispatcherServlet을 설정한다.
    registration.setLoadOnStartup(1);

    // DispatcherServlet에 URL 패턴을 지정한다.
    registration.addMapping("/app/*");
  }

}
```





- 

 **WebApplicationInitializer** 호출 과정
 1) 서블릿 컨테이너(예: 톰캣 서버)를 시작한다.
 2) spring-web-x.x.x.RELEASE.jar 파일에서
 /META-INF/service/javax.servlet.SerlvetContainerInitializer 파일을 읽는다.
 3) 이 파일에 등록된 클래스의 인스턴스를 생성한다.
 => SpringServletContainerInitializer 인스턴스 생성
 4) SpringServletContainerInitializer 객체에 대해 onStartup()을 호출한다.
 => 호출할 때 WebApplicationInitializer를 구현한 클래스 목록을 넘겨준다.
 5) SpringServletContainerInitializer는
 WebApplicationInitializer 구현체의 인스턴스를 만들고,
 onStartup()을 호출한다.



`@Configuration`뿐만 아니라 `@ComponenetScan("bitcamp")`은 인식한다.





### WebApplicationInitializer 구현체를 통해 DispatcherServlet을 등록하는 두 번째 방법
 => 인터페이스를 직접 구현하는 대신에 그 인터페이스를 구현한
 AbstractAnnotationConfigDispatcherServletInitializer 클래스를 상속 받기

 - 이 클래스는 미리 AnnotationConfigWebApplicationContext IoC 컨테이너를 준비했다.
 - 따라서 IoC 컨테이너를 따로 설정할 필요가 없다.
 - 또한 DispatcherServlet을 등록하는 코드가 이미 작성되어 있기 때문에
 따로 등록할 필요가 없다.
 - 즉 인터페이스를 직접 구현하는 것 보다 편하다.





## 질문

- 맵퍼에서 





**강사님께 한 질문**

- `web.admin.*`, `web.app.*`로 분리할 때 JSP 파일을 찾지 못하는 문제: `webapp`폴더에서 JSP 파일을 보관할 때 



## 

초보자에게는 직접 구현체를 만들어서 하는 것이 직관적일 것이다.



```java

// WebApplicationInitializer 구현체를 통해 DispatcherServlet을 등록하는 두 번째 방법
// => 인터페이스를 직접 구현하는 대신에 그 인터페이스를 구현한
// AbstractAnnotationConfigDispatcherServletInitializer 클래스를 상속 받기
// - 이 클래스는 미리 AnnotationConfigWebApplicationContext IoC 컨테이너를 준비했다.
// - 따라서 IoC 컨테이너를 따로 설정할 필요가 없다.
// - 또한 DispatcherServlet을 등록하는 코드가 이미 작성되어 있기 때문에
// 따로 등록할 필요가 없다.
// - 즉 인터페이스를 직접 구현하는 것 보다 편하다.
//
public class WebApplicationInitializerImpl
    extends AbstractAnnotationConfigDispatcherServletInitializer {

  @Override
  protected Class<?>[] getRootConfigClasses() {
    System.out.println("==> getRootConfigClasses()");
    return null;
  }

  @Override
  protected Class<?>[] getServletConfigClasses() {
    System.out.println("==> getServletConfigClasses()");
    // 스프링 WebMVC 프레임워크에서 DispatcherServlet이 사용할
    // IoC 컨테이너를 준비할 때
    // 이 메서드를 호출한다.
    // 이 메서드가 리턴한 Java config 클래스를 이용하여
    // IoC 컨테이너를 설정할 것이다.
    return new Class<?>[] {AppConfig.class};
  }

  @Override
  protected String[] getServletMappings() {
    System.out.println("==> getServletMappings()");
    // 스프링 프레임워크에서 DispatcherServlet을 등록할 때 이 메서드를 호출한다.
    // 이 메서드의 리턴 값이 리턴 값이 URL 패턴으로 사용된다.
    return new String[] {"/app/*"};
  }

  @Override
  protected String getServletName() {
    System.out.println("==> getServletName()");
    // 스프링 Web MVC 프레임워크는
    // 웹 애플리케이션에 DispatcherServlet을 등록할 때 이 메서드를 호출한다.
    // 이 메서드의 리턴 값이 서블릿의 이름으로 사용된다.
    // 이 메서드를 오버라이딩 하지 않으면 기본 이름("dispatcher")이 사용된다.
    // => 한 개만 등록할 것이라면 오버라이딩 하지 않아도 되지만,
    // 여러 개의 DispatcherServlet을 등록할 것이라면 오버라이딩 하여
    // 이름을 다르게 해야 한다.
    return "app";
  }

  @Override
  public void onStartup(ServletContext servletContext) throws ServletException {
    // 이 메서드가 호출될 때 간단한 메시지를 출력하기 위해 오버라이딩 하였다.
    // 따라서 원래의 메서드를 반드시 호출해줘야 한다.
    System.out.println("WebApplicationInitializerImpl.onStartup()...호출됨2!");
    super.onStartup(servletContext);
  }
}
```







## src-10 : WebApplicationInitializer 구현체를 통해 DispatcherServlet 등록하기 II

- WebApplicationInitializerImpl 변경
  - 직접 인터페이스를 구현하는 대신에 추상 클래스를 상속 받아 적절한 메서드를 오버라이딩 한다.
  - AbstractAnnotationConfigDispatcherServletInitializer 클래스 상속 받기

```java
// WebApplicationInitializer 구현체를 통해 DispatcherServlet을 등록하는 세 번째 방법
// => 인터페이스를 직접 구현하는 대신에 그 인터페이스를 구현한 
//    AbstractDispatcherServletInitializer 클래스를 상속 받기
// 
//
public class WebApplicationInitializerImpl 
extends AbstractDispatcherServletInitializer {

  @Override
  protected WebApplicationContext createRootApplicationContext() {
    return null;
  }

  @Override
  protected WebApplicationContext createServletApplicationContext() {
    // DispatcherServlet이 사용할 IoC 컨테이너를 리턴한다.
    // 스프링 Web MVC 프레임워크는 DispatcherServlet을 만들 때
    // 이 메서드가 리턴한 IoC 컨테이너를 DispatcherSerlvet에 주입할 것이다.
    
    //1) XML 기반 IoC 컨테이너를 사용할 경우,
//    XmlWebApplicationContext iocContainer = new XmlWebApplicationContext();
//    iocContainer.setConfigLocation("/WEB-INF/app-servlet.xml");
    
    //2) Java Config 기반 IoC 컨테이너를 사용할 경우, 
    AnnotationConfigWebApplicationContext iocContainer = 
        new AnnotationConfigWebApplicationContext();
    iocContainer.register(AppConfig.class);
    return iocContainer;
  }
  
  @Override
  protected String[] getServletMappings() {
    return new String[] {"/app/*"};
  }
  
  @Override
  protected String getServletName() {
    return "app";
  }

  @Override
  public void onStartup(ServletContext servletContext) throws ServletException {
    // 이 메서드가 호출될 때 간단한 메시지를 출력하기 위해 오버라이딩 하였다.
    // 따라서 원래의 메서드를 반드시 호출해줘야 한다.
    System.out.println("WebApplicationInitializerImpl.onStartup()...호출됨!");
    super.onStartup(servletContext);
  }
}

```

## src-12 : WebApplicationInitializer 구현체를 통해 DispatcherServlet 등록하기 응용 - XML 설정

- AppDispatcherServletInitializer 생성
  - ContextLoaderListener가 사용할 IoC 컨테이너 준비
  - DispatcherServlet이 사용할 IoC 컨테이너 준비
  - `/app/*` URL 매핑
  - 서블릿 이름은 `app` 으로 설정
- AdminDispatcherServletInitializer 생성
  - ContextLoaderListener가 사용할 IoC 컨테이너 준비하지 않는다.
    - 다른 서블릿이 이미 준비했기 때문이다.
  - DispatcherServlet이 사용할 IoC 컨테이너 준비
  - `/admin/*` URL 매핑
  - 서블릿 이름은 `admin` 으로 설정

## WebApplicationInitializer 구현체를 통해 DispatcherServlet 등록하기

```java
public class AppDispatcherServletInitializer extends AbstractDispatcherServletInitializer {

  @Override
  protected WebApplicationContext createRootApplicationContext() {
    XmlWebApplicationContext iocContainer = new XmlWebApplicationContext();
    iocContainer.setConfigLocation("/WEB-INF/config/app-context.xml");
    return iocContainer;
  }

  @Override
  protected WebApplicationContext createServletApplicationContext() {
    XmlWebApplicationContext iocContainer = new XmlWebApplicationContext();
    iocContainer.setConfigLocation("/WEB-INF/app-servlet.xml");
    return iocContainer;
  }
  
  @Override
  protected String[] getServletMappings() {
    return new String[] {"/app/*"};
  }
  
  @Override
  protected String getServletName() {
    return "app";
  }

}
```

이 메서드가 iocContainer를 리턴하는 메서드이다.

## src-13 : WebApplicationInitializer 구현체를 통해 DispatcherServlet 등록하기 응용 - Java Config 설정

- RootConfig 생성
  - ContextLoaderListener의 IoC 컨테이너가 사용할 Java Config 클래스
- AppServletConfig 생성
  - `app` DispatcherServlet의 IoC 컨테이너가 사용할 Java Config 클래스
- AdminServletConfig 생성
  - `admin` DispatcherServlet의 IoC 컨테이너가 사용할 Java Config 클래스
- AppDispatcherServletInitializer 생성
  - 단, JavaConfig를 사용할 거면 `AbstractDispatcherServletInitializer`를 사용하지 말라.
  - AbstractAnnotationConfigDispatcherServletInitializer를 상속받는다.



이전

```java
public class AppDispatcherServletInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {

  @Override
  protected WebApplicationContext createRootApplicationContext() {
    AnnotationConfigWebApplicationContext iocContainer = new AnnotationConfigWebApplicationContext();
    iocContainer.register(RootConfig.class);
    return iocContainer;
  }

  @Override
  protected WebApplicationContext createServletApplicationContext() {
    AnnotationConfigWebApplicationContext iocContainer = new AnnotationConfigWebApplicationContext();
    iocContainer.register(AppConfig.class);
    return iocContainer;
  }
  
  @Override
  protected String[] getServletMappings() {
    return new String[] {"/app/*"};
  }
  
  @Override
  protected String getServletName() {
    return "app";
  }
}
```

지금

```java
@Override
protected Class<?>[] getRootConfigClasses() {
  // ContextLoaderListener 의 IoC 컨테이너가 사용할 Java Config 클래스를 리턴한다.
  return new Class<?>[] {RootConfig.class};
}
```



## 페이지 컨트롤러를 다루는 다양한 방법

### 페이지 컨트롤러를 만드는 방법

- `RequestMapping("c01_1")` : `value="c01_1"`, `path="c01_1"`와  같다.
- 호출될 메서드란 의미에서 `@RequestMapping`을 붙인다.

```java
@Controller // 이 애노테이션을 붙인다.
@RequestMapping("/c01_1") // 컨트롤러에 URL을 매핑한다.
public class Controller01_1 {

  @RequestMapping // 이 애노테이션을 붙여서 요청이 들어왔을 때 호출될 메서드임을 표시한다.
  @ResponseBody // 메서드의 리턴 값이 클라이언트에게 출력할 내용임을 표시한다.
  public String handler() {
    return "c01_1 -> handler()";
  }

  // URL 한 개 당 한 개의 핸들러만 연결할 수 있다.
  // 같은 URL에 대해 다른 메서드를 또 정의하면 실행 오류가 발생한다.
  @RequestMapping
  @ResponseBody
  public String handler2() {
    return "c01_1 -> handler2()";
  }
}
```



`@Component`, `@Service`, `@Repository`도 객체를 생성하라는 선언인데, 그 중 pageController인 경우 `@Controller`로 객체를 생성하라는 선언을 한다.



#### 한 개의 페이지 컨트롤러에 여러 개의 요청 핸들러 두기

**요청이 들어왔을 때 호출되는 메서드**를 **`request handler`**라 부른다.

```java
@Controller 
public class Controller01_2 {

  @RequestMapping("/c01_2_h1") // 핸들러에서 URL을 지정한다.
  @ResponseBody
  public String handler() {
    return "c01_2_h1";
  }
  
  @RequestMapping("/c01_2_h2") // 핸들러에서 URL을 지정한다.
  @ResponseBody 
  public String handler2() {
    return "c01_2_h2";
  }
  
  @RequestMapping("/c01_2/h3") // URL을 지정할 때 디렉토리 형식으로 지정할 수 있다.
  @ResponseBody 
  public String handler3() {
    return "/c01_2/h3";
  }
  
  @RequestMapping("/c01_2/h4") // URL을 지정할 때 디렉토리 형식으로 지정할 수 있다.
  @ResponseBody 
  public String handler4() {
    return "/c01_2/h4";
  }
}
```



서블릿 컨테이너에서 요청을 처리하는 중에 오류가 발생했을 때 오류 내용을 출력하는 기본 페이지 교체

- 오류가 발생했을 때 직접 JSP 실행

  ```
    <error-page>
      <location>/WEB-INF/jsp2/error1.jsp</location>
    </error-page>
  ```

  

- 오류가 발생했을 때 페이지 컨트롤러를 경유하여 JSP 실행

  ```
    <error-page>
      <location>/app2/error</location>
    </error-page>
  ```



### GET, POST 구분하기

```java
@Controller
@RequestMapping("/c02_1")
public class Controller02_1 {

  // 테스트 방법:
  // => http://localhost:9999/eomcs-spring-webmvc/html/app1/c02_1.html

  @RequestMapping(method = RequestMethod.GET) // GET 요청일 때만 호출된다.
  @ResponseBody
  public String handler1() {
    return "get";
  }

  @RequestMapping(method = RequestMethod.POST) // POST 요청일 때만 호출된다.
  @ResponseBody
  public String handler2() {
    return "post";
  }
}
```

URL은 같아도 get 요청인지, post 요청인지를 구분한다. 



spring 4.3버전 이후에서만 `@GetMapping`, `@PostMapping`을 사용할 수 있다.

```java
@Controller 
@RequestMapping("/c02_2")
public class Controller02_2 {

  // 테스트 방법:
  // => http://localhost:8080/java-spring-webmvc/html/app1/c02_2.html
  
  @GetMapping // GET 요청일 때만 호출된다. 
  @ResponseBody 
  public String handler1() {
    return "get";
  }
  
  @PostMapping // POST 요청일 때만 호출된다. 
  @ResponseBody 
  public String handler2() {
    return "post";
  }
}
```



### request handler를 구분하는 방법

#### 파라미터 이름으로 구분하기

디테일하게 요청을 구분해서 호출하는 메서드를 다루는 방법

```java
@Controller
@RequestMapping("/c03_1")
public class Controller03_1 {

  // 테스트 방법:
  // => http://localhost:9999/eomcs-spring-webmvc/app1/c03_1?name=kim
  @GetMapping(params = "name")
  @ResponseBody
  public String handler1() {
    return "handler1";
  }

  // 테스트 방법:
  // => http://localhost:9999/eomcs-spring-webmvc/app1/c03_1?age=20
  @GetMapping(params = "age")
  @ResponseBody
  public String handler2() {
    return "handler2";
  }

  // 테스트 방법:
  // => http://localhost:9999/eomcs-spring-webmvc/app1/c03_1?name=kim&age=20
  @GetMapping(params = {"age", "name"})
  @ResponseBody
  public String handler3() {
    return "handler3";
  }

  // 테스트 방법:
  // => http://localhost:9999/eomcs-spring-webmvc/app1/c03_1
  @GetMapping
  @ResponseBody
  public String handler4() {
    return "handler4";
  }
}

```

조건이 없으면 handler4가 호출된다.



#### 요청 헤더 이름으로 구분한다.

```java
@Controller
@RequestMapping("/c03_2")
public class Controller03_2 {

  // @GetMapping(headers="name")
  @RequestMapping(method = RequestMethod.GET, headers = "name")
  @ResponseBody
  public String handler1() {
    return "handler1";
  }

  // @GetMapping(headers="age")
  @RequestMapping(method = RequestMethod.GET, headers = "age")
  @ResponseBody
  public String handler2() {
    return "handler2";
  }

  @GetMapping(headers = {"age", "name"})
  @ResponseBody
  public String handler3() {
    return "handler3";
  }

  @GetMapping
  @ResponseBody
  public String handler4() {
    return "handler4";
  }
}
```

- 요청 헤더 중에서 특정 이름을 갖는 헤더가 있을 때 호출될 메서드를 지정할 수 있다.
- 웹 페이지에서 링크를 클릭하거나 입력 폼에 값을 넣고 등록 버튼을 누르는 일반적인 상황에서는 요청헤더에 임의의 헤더를 추가할 수 없다.
- 자바스크립트 등의 프로그래밍으로 임의의 HTTP 요청을 할 때 HTTP 프로토콜에 표준이 아닌 헤더가 추가될 수 있다. 그 헤더를 처리하는 메서드를 정의할 때 사용한다.
- 보통 Open API를 개발하는 서비스 회사에서 많이 사용한다.

#### Accept 요청 헤더의 값에 따라 구분하기

- 요청 헤더 중에서 Accept의 값에 따라 구분할 때 사용한다.
- **Accept헤더**: HTTP 클라이언트(웹 브라우저)에서 서버에 요청할 때 받고자 하는 **콘텐트의 타입**을 알려준다. 
- `produces` 값이 없다면 기본은 `text/html`이다. 

```java
@Controller
@RequestMapping("/c03_3")
public class Controller03_3 {
  
  @GetMapping(produces = "text/plain")
  @ResponseBody
  public String handler1() {
    return "handler1";
  }

  @GetMapping(produces = "text/html")
  @ResponseBody
  public String handler2() {
    return "handler2";
  }

  @GetMapping(produces = "application/json")
  @ResponseBody
  public String handler3() {
    return "handler3";
  }

  @GetMapping
  @ResponseBody
  public String handler4() {
    return "handler4";
  }
}
```

#### Content-Type 헤더의 값에 따라 구분하기

클라이언트가 서버에 요청을 보낼 때,

- HTTP 클라이언트가 보내는 데이터의 콘텐트 타입이다.
-  프론트 컨트롤러는 보내는 데이터의 타입에 따라 처리를 분리할 수 있다.

- `consumes`: 서버 입장에서는 클라이언트가 보낸 데이터를 소비하는 (consumes)하기 때문에 consumes라는 말을 쓴다.

GET요청은 Content-Type이라는 헤더값이 없다. POST 요청만 있다. 

- 클라이언트가 POST 요청으로 데이터를 보낼 때 기본 형식은 `application/x-www-form-urlencode`이다.  이것은 변수=값&변수=값&변수=값 이란는 형식을 의미한다.
- `<form>` 태그에서 enctype 속성에 "mulpart/form-data"를 지정하면 해당 형식으로 서버에 값을 보낸다.
- 자바스크립트를 사용하여 개발자가 임의의 형식으로 값을 보낼 수 있다.
- 클라이언트가 POST로 요청할 때 보내는 데이터의 유형에 따라 호출될 메서드를 구분할 때 사용한다.
- 다음 메서드는 `application/x-www-form-urlencoded` 형식의 데이터를 소비한다. 즉 클라이언트의 HTTP 요청에서 Content-Type 헤더의 값이 위와 같을 때 이 메서드를 호출하라는 의미다. => `@PostMapping(consumes = "application/x-www-form-urlencoded")`



```java
@Controller
@RequestMapping("/c03_4")
public class Controller03_4 {

  @PostMapping(consumes = "application/x-www-form-urlencoded")
  @ResponseBody
  public String handler1() {
    return "handler1";
  }

  // 다음 메서드는 multipart/form-data 형식의 데이터를 소비한다.
  @PostMapping(consumes = "multipart/form-data")
  @ResponseBody
  public String handler2() {
    return "handler2";
  }

  // 다음 메서드는 text/csv 형식의 데이터를 소비한다.
  @PostMapping(consumes = "text/csv")
  @ResponseBody
  public String handler3() {
    return "handler3";
  }

  // 다음 메서드는 application/json 형식의 데이터를 소비한다.
  @PostMapping(consumes = "application/json")
  @ResponseBody
  public String handler4() {
    return "handler4";
  }

  // 다음 메서드는 Content-Type 헤더가 없을 때 호출된다.
  @RequestMapping
  @ResponseBody
  public String handler5() {
    return "handler5";
  }
}
```



### Request Handler의 아규먼트 

#### 프론트 컨트롤러로부터 받을 수 있는 파라미터 값

프론트 컨트롤러(DispatcherServlet)로부터 받고 싶은 값이 있다면 요청 핸들러를 정의할 때 받고 싶은 타입의 파라미터를 선언하라! 그러면 프론트 컨트롤러가 메서드를 호출할 때 해당 타입의 값을 넘겨줄 것이다.

```java
@Controller
@RequestMapping("/c04_1")
public class Controller04_1 {

  // ServletContext는 의존 객체로 주입 받아야 한다.
  // 요청 핸들러에서 아규먼트로 받을 수 없다.
  @Autowired
  ServletContext sc;

  // 요청 핸들러에서 받을 수 있는 타입의 아규먼트를 선언해 보자!
  @GetMapping("h1")
  @ResponseBody
  public void handler1(//
    // ServletContext sc, //
    // ServletContext는 파라미터로 받을 수 없다. 예외 발생!
    // 의존 객체로 주입 받아야 한다.
    ServletRequest request, //
    ServletResponse response, //
    HttpServletRequest request2, //
    HttpServletResponse response2, //
    HttpSession session, //
    Map<String, Object> map, // JSP에 전달할 값을 담는 임시 보관소
    Model model, // Map과 같다. 둘 중 한 개만 받으면 된다.
    PrintWriter out // 클라이언트에게 콘텐트를 보낼 때 사용할 출력 스트림
  ) {

    out.printf("ServletContext: %b\n", sc != null);
    out.printf("ServletRequest: %b\n", request != null);
    out.printf("ServletResponse: %b\n", response != null);
    out.printf("HttpServletRequest: %b\n", request2 != null);
    out.printf("HttpServletResponse: %b\n", response2 != null);
    out.printf("HttpSession: %b\n", session != null);
    out.printf("Map: %b\n", map != null);
    out.printf("Model: %b\n", model != null);
    out.printf("ServletRequest == HttpServletRequest : %b\n", request == request2);
    out.printf("ServletResponse == HttpServletResponse : %b\n", response == response2);
  }
}
```



인터페이스를 구현한다고 하면 인터페이스에 써져 있는 규칙대로 구현해야 한다. 그러나 여기서는 파라미터 이름 마음대로, 메서드 이름 마음대로 할 수 있다는 것이다. 우리가 선택할 수 있는 범위가 있는데, 컨트롤러 메서드 아규먼트로서 지원될 수 있는 범위가 있다. 

메서드 아규먼트의 범위 



`@RequestMapping`은 시그너처가 유연하다는 것은 파

`@RequestMapping` handler methods have a flexible signature(메서드 시그너처에서의 시그너처: 리턴타입, 메서드 이름, 파라미터 타입 및 개수) and can choose from a range of supported controller method arguments and return values.





#### `@RequestParam`

클라이언트가 보낸 파라미터 값을 바로 받을 수 있다.

요청 핸들러의 파라미터로 선언하면 된다. 단 파라미터 앞에 @RequestParam 애노테이션을 붙인다. 그리고 클라이언트가 보낸 파라미터 이름을 지정한다.

```java
@Controller
@RequestMapping("/c04_2")
public class Controller04_2 {


  @GetMapping("h1")
  @ResponseBody
  public void handler1(//
      PrintWriter out, //
      ServletRequest request, //
      @RequestParam(value = "name") String name1, //
      @RequestParam(name = "name") String name2, // value와 name은 같은 일을 한다.
      @RequestParam("name") String name3, // value 이름을 생략할 수 있다.
      String name // 요청 파라미터 이름과 메서드 파라미터(아규먼트)의 이름이 같다면
                  // 애노테이션을 생략해도 된다.
  ) {

    out.printf("name=%s\n", request.getParameter("name"));
    out.printf("name=%s\n", name1);
    out.printf("name=%s\n", name2);
    out.printf("name=%s\n", name3);
    out.printf("name=%s\n", name);
  }
}

```





애노테이션을 붙이면 필수 항목으로 간주한다. 따라서 파라미터 값이 없으면 예외가 발생한다. 애노테이션을 붙이지 않으면 선택 항목으로 인지한다. 따라서 파라미터 값이 없으면 null을 받는다. `required` 프로퍼티를 `false`로 설정하면 선택 항목으로 인지한다. 기본 값을 지정하면 파라미터 값이 없어도 된다.

```java
  // 테스트:
  // http://.../app1/c04_2/h2?name1=kim&name2=park
  @GetMapping("h2")
  @ResponseBody
  public void handler2(//
      PrintWriter out, //
      @RequestParam("name1") String name1, 
      String name2,
      @RequestParam(value = "name3", required = false) String name3, 
      @RequestParam(value = "name4", defaultValue = "ohora") String name4
  ) {
    out.printf("name1=%s\n", name1);
    out.printf("name2=%s\n", name2);
    out.printf("name3=%s\n", name3);
    out.printf("name4=%s\n", name4);
  }
```

- http://localhost:8080/bitcamp-spring-webmvc/app1/c04_2/h2

  - Required String parameter 'name1' is not present

- http://localhost:8080/bitcamp-spring-webmvc/app1/c04_2/h2?name1=aaaa

  ```
  name1=aaaa
  name2=null
  name3=null
  name4=ohora
  ```



#### 도메인 객체(값 객체; Value Object)로 요청 파라미터 값 받기



객체 안에 객체 값을 설정하기 위해서는 ognl 방식을 사용한다.ㄴ



#### 프로퍼티 에디터 사용하기

클라이언트가 보낸 요청 파라미터 값(String 타입)을 request handler의 아규먼트 타입(String, int, boolean 등)의 값으로 바꿀 때 primitive type에 대해서만 자동으로 변환해준다. 그 외의 타입에 대해서는 프로퍼티 에디터(타입 변환기)가 없으면 예외를 발생시킨다.

```java
@Controller
@RequestMapping("/c04_4")
public class Controller04_4 {

  @GetMapping("h1")
  @ResponseBody
  public void handler1(//
      PrintWriter out, //
      String model, //
      @RequestParam(defaultValue = "0") int capacity, // String ===> int : Integer.parseInt(String)
      boolean auto, // String ===> boolean : Boolean.parseBoolean(String)
      Date createdDate // 프로퍼티 에디터를 설정하지 않으면 변환 오류 발생
  ) {

    out.printf("model=%s\n", model);
    out.printf("capacity=%s\n", capacity);
    out.printf("auto=%s\n", auto);
    out.printf("createdDate=%s\n", createdDate);
  }

  // 테스트:
  // http://.../c04_4/h2?car=sonata,5,true,2019-4-19
  @GetMapping("h2")
  @ResponseBody
  public void handler2(PrintWriter out,
      // 콤마(,)로 구분된 문자열을 Car 객체로 변환하기?
      // => String ===> Car 프로퍼티 에디터를 등록하면 된다.
      @RequestParam("car") Car car) {

    out.println(car);
  }

  // 테스트:
  // http://.../c04_4/h3?engine=bitengine,3500,16
  @GetMapping("h3")
  @ResponseBody
  public void handler3(PrintWriter out,
      // 콤마(,)로 구분된 문자열을 Engine 객체로 변환하기?
      // => String ===> Engine 프로퍼티 에디터를 등록하면 된다.
      @RequestParam("engine") Engine engine) {

    out.println(engine);
  }



  // 프로퍼티 에디터를 프론트 컨트롤러에게 적용하기
  // => 프론트 컨트롤러는 request handler를 호출하기 전에
  // 넘겨줄 아규먼트 값을 준비해야 한다.
  // 각 아규먼트 값을 준비할 때
  // @InitBinder가 표시된 메서드(request handler를 실행할 때 사용할 도구를 준비하는 메서드)
  // 를 호출하여 프로퍼티 에디터(변환기)를 준비시킨다.
  // 그리고 이 준비된 값 변환기(프로퍼티 에디터)를 이용하여 파라미터 값을
  // request handler의 아규먼트가 원하는 타입의 값을 바꾼다.
  // request handler의 아규먼트 개수 만큼 이 메서드를 호출한다.
  // => 따라서 프로퍼티 에디터를 적용하기에
  // @InitBinder가 표시된 메서드가 적절한 지점이다.
  // 즉 이 메서드에 프로퍼티 에디터를 등록하는 코드를 둔다.
  //
  //@InitBinder
  public void initBinder(WebDataBinder binder) {
    System.out.println("Controller04_4.initBinder()...");
    // 프로퍼티 에디터를 등록하려면 그 일을 수행할 객체(WebDataBinder)가 필요하다.
    // request handler 처럼 아규먼트를 선언하여
    // 프론트 컨트롤러에게 달라고 요청하라.

    // String ===> Date 프로퍼티 에디터 준비
    DatePropertyEditor propEditor = new DatePropertyEditor();

    // WebDataBinder에 프로퍼티 에디터 등록하기
    binder.registerCustomEditor(java.util.Date.class, // String을 Date 타입으로 바꾸는 에디터임을 지정한다.
        propEditor // 바꿔주는 일을 하는 프로퍼티 에디터를 등록한다.
    );

    // WebDataBinder에 프로퍼티 에디터 등록하기
    binder.registerCustomEditor(Car.class, // String을 Car 타입으로 바꾸는 에디터임을 지정한다.
        new CarPropertyEditor() // 바꿔주는 일을 하는 프로퍼티 에디터를 등록한다.
    );

    // WebDataBinder에 프로퍼티 에디터 등록하기
    binder.registerCustomEditor(Engine.class, // String을 Engine 타입으로 바꾸는 에디터임을 지정한다.
        new EnginePropertyEditor() // 바꿔주는 일을 하는 프로퍼티 에디터를 등록한다.
    );
  }

  // PropertyEditor 만들기
  // => 문자열을 특정 타입의 프로퍼터의 값으로 변환시킬 때 사용하는 에디터이다.
  // => java.beans.PropertyEditor 인터페이스를 구현해야 한다.
  // => PropertyEditor를 직접 구현하면 너무 많은 메서드를 오버라이딩 해야 하기 때문에
  // 자바에서는 도우미 클래스인 PropertyEditorSupport 클래스를 제공한다.
  // 이 클래스는 PropertyEditor를 미리 구현하였다.
  // 따라서 이 클래스를 상속 받은 것 더 낫다.
  class DatePropertyEditor extends PropertyEditorSupport {

    @Override
    public void setAsText(String text) throws IllegalArgumentException {
      System.out.println("DatePropertyEditor.setAsText()");
      // 프로퍼티 에디터를 사용하는 측(예: 프론트 컨트롤러)에서
      // 문자열을 Date 객체로 바꾸기 위해 이 메서드를 호출할 것이다.
      // 그러면 이 메서드에서 문자열을 프로퍼티가 원하는 타입으로 변환한 후 저장하면 된다.
      try {

        // 1) String ==> java.util.Date
        // SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd");
        // Date date = format.parse(text); // String ===> java.util.Date
        // setValue(date); // 내부에 저장

        // 2) String ==> java.sql.Date
        setValue(java.sql.Date.valueOf(text));

      } catch (Exception e) {
        throw new IllegalArgumentException(e);
      }
    }

    @Override
    public Object getValue() {
      System.out.println("DatePropertyEditor.getValue()");
      // 이 메서드는 프로퍼티 에디터를 사용하는 측(예: 프론트 컨트롤러)에서
      // 변환된 값을 꺼낼 때 호출된다.
      // 이 메서드를 오버라이딩 하는 이유는 이 메서드가 호출된 것을
      // 확인하기 위함이다. 원래는 오버라이딩 해야 할 이유가 없다.
      return super.getValue();
    }
  }

  // String ===> Car 프로퍼티 에디터 만들기
  class CarPropertyEditor extends PropertyEditorSupport {
    @Override
    public void setAsText(String text) throws IllegalArgumentException {
      String[] values = text.split(",");

      Car car = new Car();
      car.setModel(values[0]);
      car.setCapacity(Integer.parseInt(values[1]));
      car.setAuto(Boolean.parseBoolean(values[2]));
      car.setCreatedDate(java.sql.Date.valueOf(values[3]));

      setValue(car);
    }
  }

  class EnginePropertyEditor extends PropertyEditorSupport {
    @Override
    public void setAsText(String text) throws IllegalArgumentException {
      String[] values = text.split(",");

      Engine engine = new Engine();
      engine.setModel(values[0]);
      engine.setCc(Integer.parseInt(values[1]));
      engine.setValve(Integer.parseInt(values[2]));

      setValue(engine);
    }
  }
}
```





## ENUM

각각의 상수값이 무엇인지 상관 없이 상수로서 다루고 싶으면, 클래스로 다루지 말고 

```java

```

상수에 해당되는 것을 나열한다.

```java
public enum RequestMethod {
	GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS, TRACE
}
```

