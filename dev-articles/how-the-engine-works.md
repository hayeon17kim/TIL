원글 출처: https://www.freecodecamp.org/news/javascript-essentials-why-you-should-know-how-the-engine-works-c2cc0d321553/

번역글 출처: https://devtimothy.tistory.com/m/94

# 엔진 동작을 알아야 하는 이유

## 인터프리터와 컴파일러의 연합

- 엔진: **소스 코드를 읽고 실행**하는 부분
- Google 크롬은 Node.js의 엔진이기도 한 V8을 사용한다.
- V8의 등장은 엔진 역사에서 매우 중요한 순간이었다. 자바스크립트의 상대적으로 느린 브라우저 인터프리팅을 대체했다.
- 인터프리터는 소스코드를 거의 즉시 실행한다.
- 컴파일러는 사용자의 시스템에서 직접 실행하는 기계 코드를 생성한다.
  - 컴파일러는 **기계 코드 단**(on the machine code generation)에서 동작하므로, **최적화가 적용**된다. 컴파일 및 최적화 결과는 컴파일 단계에서 추가 시간이 필요함에도 불구하고 빠른 코드 실행을 가능하게 한다.
- 현대 엔진: 컴파일러와 인터프리터의 장점을 결합
  - 인터프리터의 빠른 애플리케이션 시작
    - 자주 실행되는 코드 부분을 *Hot path*로 플래그를 지정하고, 실행 중에 수집된  컨텍스트 정보와 함께 컴파일러에 전달한다. 이 프로세스를 통해 현재 컨텍스트에 맞게 코드를 조정하고 최적화한다.
  - 컴파일러의 빠른 실행
    - JIT(Just In Time)



## 런타임에서의 정적 타입: 인라인 캐싱

- 인터프리터는 오브젝트의 프로퍼티에 접근하기 전에 검색을 수행한다.
- 엔진은 각 객체를 런타임 중에 생성하는 **타입**에 할당한다.
- V8은 ECMAScript 표준, 숨겨진 클래스 또는 객체 형태의 일부가 아닌 이러한 타입을 호출한다.
- 두 객체가 동일한 객체 형태(shape)을 공유하려면 두 객체 모두 동일한 순서로 같은 프로퍼티를 가져야 한다.
  - `{firstname : "Han", lastname : "Solo"}` 오브젝트는 `{lastname : "Solo", firstname : "Han"}`와 다른 클래스에 할당된다.
- 오브젝트 형태의 도움으로 엔진은 각 프로퍼티의 메모리 위치를 알고 있다. 엔진은 해당 위치를 해당 프로퍼티에 액세스하는 함수에 하드코딩한다.
- 인라인 캐싱은 조회 작업을 없애 성능 향상을 가져온다.



## 오리 vs 다양한 유형

- 덕 타이핑: 좋은 코드 품질로 여러 유형을 처리할 수 있는 함수를 요구
- 인라인 캐싱: 



- 관리 시스템 특화된 것으로 주제 선정



- 페이스북의 이 기능만 특화시켜서 만들고 싶었다.
- 트위터 -> 
- 인사관리시스템 -> 너무 복잡했던 경험 -> 이걸 간략하게 처리하는 방법
- 클라우드 서비스로 제공하는 서비스



- 특화된 시스템: IoT, 머신러닝 등





\- 현황 -> 문제점  - 이런이런 상황이 있었는데 이런 문제점이 있었다. - 해결방안 =>  - 이런 시스템을 개발해서 이 문제를 해결할 것이다.  - 사용자에게 어떤 이점이 있는지 이야기할 수 있어야 한다. - 주요기능  - 주제 2개 선정

- 현황 -> 문제점
- 해결방안, 사용자가 갖는 이점
- 주요 기능









*[*오후 5:46*]*

유아이 프로토타입 발표(다음주) -> DB모델링(다다음주) -> 이때쯤 웹 프로그래밍 진도 들어가서 저녁부터 웹 프로젝트에 대한 작업을 수행하게 된다.