##  숫자형

- double precision floating poing number에 저장(64비트)
- BigInt: 임의의 길이를 가진 정수 

### e를 사용한 숫자 표현

0 이 많이 붙은 숫자는 `e `를 사용해 표현한다.

- 0의 개수를 `e` 뒤에 추가한다.
- `e` 다음에 음수가 오면, 음수의 절댓값만큼 10을 거듭제곱한 숫자로 주어진 숫자를 나눈다. 

### 진법 

- 자바스크립트에서는 특별한 변환 없이 16진수(`0x`), 8진수(`0o`), 2진수(`0b`)를 바로 사용할 수 있게 지원한다. 
- `parseInt(str, base)`를 사용하면 `str`를 `base` 진수로 바꿔준다. (`2 ≤ base ≤ 36`)
- `num.toString(base)`는 숫자를 `base` 진수로 바꾸고, 이를 문자열 형태로 변환한다.



### 점 두개와 메서드 호출

- 숫자를 대상으로 메서드 `toString`을 직접 호출하고 싶다면 숫자 다음에 점 두 개 `..`를 붙여야 한다.
- `123456.toString(36)`처럼 점을 한 개만 사용하면, 첫번째 점 이후는 소수부로 인식되어 에러가 발생할 수 있다. `123456..toString(36)`처럼 점을 하나 더 추가하면 자바스크립트는 소수부가 없다고 판단하고 함수를 호출한다. `(123456).toString(36)`도 가능하다.

### 약한 형변환

- `12pt`나 `100px` 같은 값을 숫자로 변환하는 것도 가능하다 .
- `parseInt`나 `parseFloat`을 사용하면 문자열에서 숫자만 읽고, 읽은 숫자를 에러가 발생하기 전에 반환해주는 *약한* 형변환을 사용할 수 있다.

### 소수를 처리하는 데 쓰는 메서드

정밀도 손실에 주의한다.

- `Math.floor`
- `Math.ceil`
- `Math.trunc`: 소수부를 무시 (Internet Explorer에서는 지원하지 않는다)
- `Math.round`
- `num.toFixed(precision)`



### 부정확한 계산

- 숫자가 너무 커지면 64비트 공간이 넘쳐서 Infinity로 처리한다.
  - `alert(1e500)` -> Infinity
- 숫자는 0과 1로 이루어진 이진수로 변환되어 연속된 메모리 공간에 저장된다. 그러나 10진법을 사용하면 쉽게 표현될 수 있는 `0.1`, `0.2`와 같은 분수는 이진법으로 표현하면 무한소수가 된다.
- 10의 거듭제곱으로 나눈 값은 10진법에서는 잘 동작하지만 3으로 나누게되면 10진법에서 제대로 동작하지 않는다(1/3은 무한소수 0.33333). 같은 이유로 2진법 체계에서 2의 거듭제곱으로 나눈 값은 잘 동작하지만 `1/10`과 같이 2의 거듭제곱이 아닌 수로 나누게 되면 무한 소수가 되어버린다. 10진법에서 1/3을 정확히 나타낼 수 없듯이, 2진법을 사용해 0.1 또는 0.2를 **정확하게** 저장하는 방법은 없다. 이 문제는 자바스크립트만의 문제가 아니다.
- 이 문제를 해결하기 위해서는 ` toFixed(n)` 메서드를 사용해 어림수를 만드는 것이가장 신뢰할 만하다. 이 메서드는 소숫점 아래 2자리의 문자열을 리턴한다. 



### 두 종류의 0

- 자바스크립트에선 **숫자의 부호가 단일 비트에 저장**되는데 0을 포함한 모든 숫자에 부호를 설정할 수도, 설정하지 않을 수도 있다. 
- 0과 -0이라는 두 개의 0이 존재한다.



### `isNaN`과 `isFinite`

- `Infinity`와 `-Infinity`: 그 어떤 숫자보다 큰 혹은 작은 특수 숫자 값
- `NaN`: 에러를 나타내는 값

두 특수문자는 숫자형에 속하지만 정상적인 숫자는 아니기에, 정상적인 숫자와 구분하기 위한 특별한 함수가 존재한다.

- `isNaN(value)`: 인수를 숫자로 변환한 다음 `NaN`인지 테스트함
  - `NaN`은 `NaN` 자기 자신을 포함하여 그 어떤 값과도 같지 않기에 이 메서드는 필요하다. 
  - `isNaN("str")`, `isNaN(NaN)`의 값은 true이다.
- `isFinite(value)`: 인수를 숫자로 변환하고 변환한 숫자가 `NaN/Infinity/-Infinity`가 아닌 일반 숫자일 경우 `true`를 반환
  - 문자열이 일반 숫자인지 검증하는 데 사용된다.
  - 단, 빈 문자열이나 공백만 있는 문자열은 `isFinite`를 ㅓ포함한 모든 숫자 관련 내장 함수에서 `0`으로 취급된다.



### `Object.is`와 비교

- `Object.is`는 `===`처럼 값을 비교할 때 사용하는 내장 메서드
- 두 가지 edge case에서는 `===`보다 좀 더 신뢰할만한 결과를 보여준다.
  - `Object.is(NaN, NaN) == true`
  - `Object.is(0, -0) == false`
- 이 외에 `Object.is(a,b)`와 `a === b`의 결과는 같다.



### parseInt와 parseFloat

- 단항 덧셈 연산자(`+`) 또는 `Number()`를 사용하여 숫자형으로 적용되는 규칙은 엄격하다. 예를 들어, `+"100px"`는 NaN이다.
- 반면 `parseInt`와 `parseFloat`는 불가능할 때까지 문자열에서 숫자를 읽는다. 숫자를 읽는 중 오류가 발생하면 이미 숫자를 반환한다. 예를 들어, `parseInt('100px')`은 100이고, `parseFloat(12.5em)`은 12.5이다. 한편, `parseInt('a123')`과 같이 읽을 수 있는 숫자가 없을 때는 `NaN`을 반환한다.
- `parseInt(str, radix)`의 두 번째 매개변수는 선택적으로 사용할 수 있다. `radix`는 원하는 진수를 지정해줄 때 사용한다.