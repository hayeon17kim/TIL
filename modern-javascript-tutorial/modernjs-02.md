## 2.1. Hello, world!

Node.js와 같은 서버 사이드 환경에서 스크립트를 실행하고 싶다면 `node my.js`와 같은 명령어를 사용하면 된다.

### `script` 태그

`script` 태그를 이용하면 자바스크립트 프로그램을 HTML 문서 어느 곳에나 삽입할 수 있다. 브라우저는 이 태그를 만나면 안의 코드를 자동으로 처리한다. 

### 모던 마크업

`script` 태그에는 요즘엔 잘 사용하지 않는 필수가 아닌 몇 가지 속성이 있다.

**`type` 속성**

HTML4와 달리 이젠 타입 명시가 필수가 아니다. 이제 이 속성은 **자바스크립트 모듈**에 사용할 수 있다.

**`language` 속성**

현재 사용하고 있는 스크립트 언어를 나타내지만, 지금은 자바스크립트가 기본 언어이므로 사용할 필요가 없다.

### 외부 스크립트

자바스크립트 코드의 양이 많다면 파일로 소분하여 저장할 수 있다 `<script src="/path/to/script.js">`에서 경로는 **사이트의 루트에서부터 파일이 위치한 절대 경로**를 나타낸다. 현재 페이지에서의 상대 경로를 사용하는 것도 가능하다. URL 전체를 속성으로 사용할 수도 있다.

**외부스크립트의 이점**

HTML 안에 직접 스크립트를 작성하는 방식은 대개 스크립트가 아주 간단할 때만 사용하고, 길다면 파일로 분리하는 것이 좋다. **스크립트를 별도의 파일에 작성하면 브라우저가 스크립트를 다운받아 캐시(cache)에 저장하기 때문에 성능상의 이점**이 있다. 여러 페이지에서 동일한 스크립트를 사용하는 경우 페이지가 바뀔 때마다 스크립트를 새로 다운받는 게 아니라 한 번만 다운받으면 되기 때문이다. 

**`src` 속성이 있으면 태그 내부의 코드는 무시된다.**

`script` 태그는 src 속성과 내부 코드를 동시에 가지지 못한다.



## 2.2. 코드 구조

### statement

문(statement)은 어떤 작업을 수행하는 문법 구조(syntax structure)와 명령어(command)를 의미한다.

### 세미콜론

줄바꿈이 있다면 세미콜론을 생랴가할 수 있다. 자바스크립트는 **줄바꿈이 있으면 이를 '암시적' 세미콜론으로 해석**한다. 이런 동작 방식을 **세미콜론 자동 삽입**이라고 부른다. **세미콜론이 정말로 필요하지만 자바스크립트가 이를 추정하지 못하는 상황도 존재한다.** 다음과 같다.

```js
alert("에러가 발생합니다.")
[1, 2].forEach(alert)
```

이를 실행해보면 alert만 출력되고 에러가 발생한다. 자바스크립트가 대괄호 `[...]` 앞에는 세미콜론이 있다고 가정하지 않기 때문이다. 따라서 자바스크립트 엔진은 `alert("에러가 발생합니다.")[1,2].forEach(alert)`이라는 단일문을 보고 에러를 발생시키는 것이다.

이러한 문제들 때문에 줄바꿈으로 문을 나눠 놨다 하더라도 문 사이에는 세미콜론을 넣는 것이 권장된다. 

### 주석

자바스크립트 엔진은 주석을 무시하기 때문에 주석의 위치는 실행에 영향을 주지 않는다. 대부분의 에디터에서 `Ctrl + / `는 한줄 주석, `Ctrl + Shift + /`는 여러줄 주석을 만든다. 

**중첩 주석은 지원하지 않는다.** `/* ... */` 안에 또 다른 `/* ... */`가 있을 수 없다. **주석을 중첩해 쓰면 에러가 발생**한다. 

주석을 다면 코드 전체 길이는 길어지지만 프로덕션 서버에 배포하기 전에 코드를 압축해주는 도구가 많이 있고, 이 도구는 주석을 삭제한다. 즉 실행 중인 스크립트엔 주석이 들어가지 않으므로 최종으로 배포되는 코드에 부정적인 영향을 끼치지 않는다.

## 2.3. 엄격 모드

ECMAScript5(ES5)가 등장하기 전인 2009년까지는 **기존 기능 변경 없이 새로운 기능이 추가**되었다. 새롭게 정의된 ES5에서는 **새로운 기능이 추가되고 기존 기능 중 일부가 변경**되었다. 기존 기능을 변경하였기 때문에 하위 호환성 문제가 생길 수 있으므로 변경사항이 ES5 기본 모드에서는 활성화되지 않도록 설계되었다. 대신 **`use strict`라는 특별한 지시자**를 사용해 **엄격모드를 활성화**했을 때만 이 변경사항이 활성화되게 해 놓았다.

### `use strict`

지시자가 **스크립트 최상단**에 오면 스크립트 전체가 "모던한" 방식으로 동작한다. 한편 함수 본문 맨 앞에 위치할 수도 있는데, 이렇게 하면 **오직 해당 함수만 엄격 모드로 실행**된다.

```js
alert("some code");
// 하단에 위치한 "use strict"는 스크립트 상단에 위치하지 않으므로 무시된다.
"use strict";
```

### 브라우저 콘솔

브라우저 콘솔은 기본적으로 `use strict`가 적용되어 있지 않는다. 따라서 `'use strict'` 입력 후 `Shift+Enter`를 눌러 줄바꿈해 원하는 스크립트를 입력한다. 브라우저가 오래되어 입력이 불가능하다면 다음과 같이 코드를 래퍼로 감싼다.

```js
(function() {
  'use strict';
  // 테스틀하려는 코드
})()
```

### `use strict` 필요성

**코드를 클래스와 모듈을 사용해 구성한다면 `"use strict"`를 생략해도 된다. **클래스와 모듈을 사용하면 **`use strict`가 자동으로 적용되기 때문**이다.



## 2.4. 변수와 상수

대다수 자바스크립트 애플리케이션은 **사용자나 서버로부터 입력받은 정보를 처리**하는 방식으로 동작한다. **변수는 이러한 정보를 저장**하는 용도로 사용된다.

### 변수(variable)

데이터를 저장할 때 쓰이는 '**이름이 붙은 저장소**'이다.

```js
let message; // 'message' 이름을 가진 변수 생성(선언)
message = 'Hello'; // 할당연산자 =를 사용해 변수 안에 데이터 저장
// 문자열이 변수와 연결된 메모리 영역에 저장
alert(message); // 변수명을 이용해 문자열에 접근
```

변수 `message`는 `message`라는 이름표가 붙어있는 상자에 `"Hello"`라는 값을 저장한 것이다. 상자 안에는 어떤 값이든지 넣을 수 있고, 변경할 수 있다. 

```js
message = "World!";
alert(message);
```

값이 변경되면, 이전 데이터는 변수에서 제거된다. 변수 두 개를 선언하고, **한 변수의 데이터를 다른 변수에 복사**할 수도 있다.

변수를 두 번 선언하면 에러가 발생한다. 변수는 딱 한 번만 선언하고, 선언한 변수를 참소할 때는 `let` 없이 변수명만 사용해 참조해야 한다.

### 함수형 언어

함수형 프로그래밍 언어는 변숫값 변경을 금지한다. *스칼라(Scala)*와 *얼랭(Erlang)*은 대표적인 함수형 언어이다. 상자 속에 값이 일단 저장되면 그 값을 영원히 유지하고 다른 값을 저장하고 싶다면 새로운 상자를 만들어야 한다.

### 변수 명명 규칙

- 변수명에는 오직 문자와 숫자, 그리고 기호(`$`, `_`)만 올 수 있다.
- 첫 글자는 숫자가 될 수 없다.

여러 단어를 조합하여 변수명을 만들 땐 첫단어를 제외한 각 단어의 첫글자를 대문자로 작성하는 카멜 표기법(camelCase)가 흔히 사용된다. 하이픈은 변수명에 올 수 없다. 비라틴계 언어도 변수명에 사용될 수 있지만 권장하지 않는다. 

예약어(reserved name)는 자바스크립트 내부에서 이미 사용중이므로 변수명으로 사용될 수 없다. 

기본 모드에서는 단순 할당만으로 변수를 생성할 수 있다. 그러나 엄격 모드에서는 에러가 발생한다.

```js
"use strict";
num = 5; // error: num is not defined
```

### 상수(constant)

변화하지 않는 변수를 선언할 때 `const`를 사용한다. 상수는 재할당할 수 없으므로 변경하려고 하면 에러가 발생한다.

### 대문자 상수

기억하기 힘든 값을 변수에 할당해 별칭으로 사용하는 것은 널리 사용되는 관습이다. 이런 상수는 대문자와 밑줄로 구성된 이름으로 명명한다. 

```js
const COLOR_RED = "#F00";
const COLOR_GREEN = "#0F0";
const COLOR_BLUE = "#00F";
const COLOR_ORANGE = "#FF7F00";

// 색상을 고르고 싶을 때 별칭을 사용할 수 있게 되었습니다.
let color = COLOR_ORANGE;
alert(color); // #FF7F00
```

이렇게 하면 **기억하기 쉽고, 오타를 낼 확률이 낮으며, 유의미하므로 코드 가독성이 증가한다.**

이렇게 코드가 실행되기 전에 이미 그 값을 알고 있는 상수도 있고, 런타임 과정에서 *계산되지만*  최초 할당 이후 값이 변하지 않는 상수도 있다.

```js
const pageLoadTime = /* 웹 페이지를 로드하는 데 컬린 시간 */;
```

이 값은 페이지가 로드되기 전에는 정해지지 않기 때문에 일반적인 방식으로 변수명을 짓는다. 그러나 최초 할당 이후에 변경되지 않으므로 여전히 상수이다. 즉 **대문자 상수는 '하드코딩한' 값의 별칭을 만들 때 사용하면 된다**.

### 바람직한 변수명

**변수명은 변수가 담고 있는 것이 무엇인지 쉽게 알 수 있도록 지어져야 한다.**

- `userName`이나 `shoppingCart`처럼 **사람이 읽을 수 있는 이름**을 작성한다.
- 줄임말이나 짧은 이름은 피한다.
- 최대한 서술적이고 간결하게 명명한다. `data`, `value`는 아무것도 설명해주지 않기 때문에 나쁜 이름이다. 코드 문맥 상 변수가 가리키는 데이터나 값이 아주 명확할 때만 이런 이름을 사용한다.
- **자신만의 규칙**이나 **소속된 팀의 규칙**을 따른다. 

### 재사용 vs 새로 만들기

**변수를 재사용**하면 변수 선언에 쏟는 노력을 덜 수는 있지만, **디버깅에 열 배 더 많은 시간을 쏟아야 한다.** 모던 자바스크립트 압축기(minifier)와 브라우저는 코드 최적화를 잘 해주기 때문에 **변수를 추가한다고 해서 성능 이슈가 생기지 않는다**. 

### 과제

#### 변수 가지고 놀기

```js
let admin;
let name;
name = "John";
admin = name;
alert(admin);
```

#### 올바른 이름 선택하기

```js
let ourPlanetName = "Earth";
let currentUserName = "Hayeon";
```

#### 대문자 상수 올바로 사용하기

```js
const birthday = '18.04.1982';

const age = someCode(birthday);
```

위 변수를 대문자 상수로 바꿔도 괜찮을까? `birthday`의 경우 실행 전에 값을 이미 알고 있고, 코드에서 직접 그 값을 쓰기 때문에 (하드코딩되어 있기 때문에) 대문자 상수로 적합하다. 그러나 `age`의 경우 **런타임에 계산되기 때문에 대문자 상수에 적합하지 않다.**



## 2.5. 자료형

자바스크립트의 변수는 자료형에 관계없이 모든 데이터일 수 있다. 자바스크립트는 **자료의 타입은 있지만 변수에 저장되는 값의 타입은 언제든지 바뀔 수 있는 "동적 타입(dynamically typed) 언어"**이다.



### 숫자형(number type)

숫자형은 정수 및 부동소수점 숫자(floating point number)를 나타낸다. 일반적이 숫자 외에 `Infinity`, `-Infinity`, `NaN` 같은 **특수 숫자 값(special numeric value)**가 포함된다.

어느 숫자든 0으로 나누면 `Infinity`를 얻을 수 있고, **`Infinity`를 직접 참조할 수도 있다.** `NaN`은 **부정확하거나 정의되지 않은 수학 연산을 사용하면 계산 중에 에러가 발생하는데, 이때 반환**된다. `NaN`에는 어떤 추가 연산을 해도 결국 `NaN`이 반환된다. 즉 연산 과**정 어디선가 `NaN`이 반환되었다면 이는 모든 결과에 영향을 미친다**.

```js
"숫자가 아님" / 2; // NaN, 문자열을 숫자로 나누면 오류 발생
"숫자가 아님" / 2 + 5; // NaN
```

**자바스크립트에서 행해지는 수학 연산**은 **안전**하다. 0으로 나누거나 숫자가 아닌 문자열을 숫자로 취급하는 등 말이 안 되는 수학 연산을 하더라도 스크립트는 치명적인 에러를 내뿜으며 죽는 것이 아니라 **`NaN`을 반환하며 연산을 종료할 뿐**이다.

### BigInt

자바스크립트에서는 (2<sup>53</sup>-1) 보다 큰 값 혹은 -(2<sup>53</sup>-1) 보다 작은 정수는 '숫자형'을 사용해 나타낼 수 없다. 그러나 암호 관련 작업 등 아주 큰 숫자가 필요하거나 아주 높은 정밀도로 작업을 해야 할 때 이런 큰 숫자가 필요하다. BigInt 형은 표준으로 채택된 지 얼마 안 된 자료형으로, **길이에 상관없이 정수를 나타낼 수 있다**. BigInt 형 값은 **정수 리터럴 끝에 `n`을 붙이면 만들 수 있다.**

```js
const bigInt = 1234567890123456789012345678901234567890n;
```

### 문자형

따옴표에는 큰따옴표, 작은따옴표, 역 따옴표**(백틱)**가 있다. 큰따옴표와 작은따옴표는 기본적인 따옴표로 차이가 없다. **역따옴표로 변수나 표현식을 감싼 후 `${}`안에 넣어 주면 원하는 변수나 표현식을 문자열 중간에 손쉽게 넣을 수 잇다**. 이렇게 문자열 중간에 들어간 변수나 표현식은 **평가가 끝난 후 문자열의 일부가 된다.**

```js
let name = "John";
// 변수를 문자열 중간에 삽입
alert(`Hello, ${name}!`); // Hello John!
// 표현식을 문자열 중간에 삽입
alert(`the result is ${1 + 2}`); // the result is 3
```

자바의 `char`과 같은 *글자형*은 자바스크립트에 존재하지 않는다.

### 불린형

긍정이나 부정을 나타내는 값을 저장할 때 사용하고, 비교 결과를 저장할 때도 사용된다.

### `null` 값

`null` 값은 오로지 `null` 값만 포함하는 별도의 자료형을 만든다.

다른 언어에선 `null`을 **존재하지 않는 객체에 대한 참조** 나 **널 포인터(null pointer)**를 나타낼 때 사용한다. 하지만 자바스크립트에서는 `null`을 **존재하지 않는(nothing) 값, 비어있는(empty) 값, 알 수 없는(unknown) 값**을 나타내는 데 사용한다. 

즉 `let age = null;`은 나이(age)를 알 수 없거나 그 값이 비어있음을 보여준다.

### `undefined` 값

자신만의 자료형을 형성한다. `undefined`는 **값이 할당되지 않은 상태**를 나타낼 때 사용한다. 변수는 선언했지만, 값을 할당하지 않았다면 해당 변수에 `undefined`가 자동으로 할당된다. 변수에 명시적으로 `undefined`를 할당할 수도 있지만 이것은 권장되지 않는다. 변수가 '비어있거나' '알 수 없는' 상태임을 나타내려면 `null`을 사용하자. 

 ### 객체와 심볼

객체형을 제외한 다른 자료형은 **한 가지만 표현할 수 있기 때문에 원시(primitive) 자료형이라 부른다.** 반면 객체는 **데이터 컬렉션이나 복잡한 개체(entity)**를 표현할 수 있다. 

**심볼(symbol)형**은 객체의 고유한 식별자(unique identifier)를 만들 때 사용된다. 

### `typeof` 연산자

인수의 자료형을 반환하는 연산자이다. **자료형에 따라 처리 방식을 다르게 하고 싶거나 변수의 자료형을 알아내고자 할 때 유용하다.** 연산자 문법(`typeof x`), 함수 문법(`typeof (x)`) 모두 지원한다. 

```js
typeof undefined // "undefined"
typeof 0 // "number"
typeof 10n // "bigint"
typeof true // "boolean"
typeof "foo" // "string"
typeof Symbol("id") // "symbol"
typeof Math // "object"  (1)
typeof null // "object"  (2)
typeof alert // "function"  (3)
```

**`typeof null`의 결과는 `"object"`이다**. `null`은 별도의 고유한 자료형을 가지는 특수값으로 **객체가 아니지만, 하위 호환성을 위해 이런 오류를 수정하지 않고 남겨놓은 상황**이다.

`typeof 함수`의 결과는 `"function"`이다. 그러나 **함수형은 따로 없고 함수는 객체형에 속한다.** 하위 호환성 유지를 위해 남겨놓은 상태이다. 한편 **실무에서는 이런 특징이 매우 유용하게 사용되기도 한다.**

### 과제

#### 문자열 따옴표

```js
let name = "Ilya"; 

// 표현식은 숫자 1
alert(`hello ${1}`); // hello 1

// 표현식은 문자열 "name"
alert(`hello ${"name"}`); // hello name

// 표현식 안에 변수가 들어 있기 때문에 이 변수가 평가되어
// 전체 문자열이 반환된다.
alert(`hello ${name}`) // hello Ilya
```



## 2.6. `alert`, `prompt`, `confirm`을 이용한 상호작용

### `alert`

사용자가 확인 버튼을 누를 때까지 메시지를 보여주는 창이 떠있게 된다.

모달창(modal window): 메시지가 있는 작은 창으로, modal이라는 단어에는 페이지 나머지 부분과 상호작용이 불가능하다는 의미가 내포되어 있다. 확인 버튼을 누르기 전까지는 모달 창 바깥의 행동을 할 수 없다.

### `prompt`

```js
result = prompt(title, [default]);
```

- `title`: 사용자에게 보여줄 문자열

- `default`: 입력 필드의 초기값(선택값)

  IE는 default 매개변수가 없을 때 입력 필드에 `"undefined"`를 명시한다. 따라서 모든 사용자에게 깔끔한 프롬프트를 보여주려면 두 번째 매개변수가 필요없다 하더라도 `''`로 전달해주어야 한다.

  > 대괄호는 선택값을 의미한다.

확인을 누르면 prompt 함수는 사용자가 입력한 문자열을 반환하고, 취소 혹은 `Esc`를 누르면 `null`을 반환한다.

### `confirm`

```js
result = confirm(question);
```

매개변수로 받은 `question(질문)`과 확인 및 취소 버튼이 있는 모달 창을 보여준다. 사용자가 확인버튼을 누르면 true, 그 외의 경우에는 false를 반환한다.

```js
let isBoss = confirm("당신이 주인인가요?");
alert(isBoss); // 확인이라면 true, 그 외라면 false
```

세 함수 모두 모달창을 띄운다. 모달 창이 떠 있는 동안은 **스크립트의 실행이 일시 중단**된다. 사용자가 창을 닫기 전까진 나머지 페이지와 상호작용이 불가능하다. **모달창의 위치는 브라우저가 결정**하는데, 대개 **브라우저의 중앙**에 위치한다. 모달창의 모양은 브라우저마다 다르다. **개발자는 창의 모양을 수정할 수 없다**.

### 과제

#### 간단한 페이지 만들기

```js
let name = prompt("이름을 입력해 주세요.", "");
alert(name);
```



## 2.7. 형 변환

**함수와 연산자에 전달**되는 값은 대부분 적절한 자료형으로 자동 변환된다. 이러한 과정을 **형 변환(type conversion)**이라고 한다. **전달받은 값**을 **의도를 갖고 원하는 타입으로 변환(명시적 변환)**해 주는 경우도 형 변환이라고 할 수 있다.

### 문자형으로 변환

문자형으로 변환은 무언가를 출력할 때 주로 일어난다.  **`String(value)`**을 사용하면 문자형으로 명시적 변환이 가능하다. **문자형으로의 변환은 대부분 예측 가능한 방식으로 일어난다.**

### 숫자형으로 변환

수학 관련 연산시 주로 일어난다. **`Number(value)` 함수**로도 형 변환을 할 수 있다.

| **전달받은 값** | **형 변환 후**                                               |
| --------------- | ------------------------------------------------------------ |
| `undefined`     | `NaN`                                                        |
| `null`          | 0                                                            |
| true / false    | 1 / 0                                                        |
| string          | 전달받은 문자열을 "그대로" 읽되, 처음과 끝의 공백을 무시한다. 문자열이 비어있다면 0이 되고, 오류 발생 시  NaN이 된다. |

### 불린형으로 변환

논리 연산 시 발생한다. **`Boolean(value)`**으로 변환할 수 있다.

0, `null`, `undefined`, `NaN`, `""`은 형 변환 시 `false`가 되고, 그 외의 값은 `true`로 변환된다. 

- 숫자형으로 변환 시 `undefined`는 0이 아니라 `NaN`이 된다. 단 불린형으로 변환 시 false가 된다.
- 문자열 `"0"`과 `" "`와 같은 공백은 불링형으로 변환 시 true가 된다.



## 2.8. 기본 연산자와 수학

### 단항, 이항,. 피연산자

- 피연산자(operand; 인수(argument)): 연산자가 연산을 수행하는 대상.
- 단항(unary) 연산자: 피연산자를 하나만 받는 연산자
- 이항(binary) 연산자: 두 개의 피연산자를 받는 연산자 

### 거듭제곱 연산자 `**`

거듭제곱 연산자(exponentiation operator)를 사용한 `a ** b`를 평가하면 `a`를 `b`번 곱한 값이 반환된다. **정수가 아닌 숫자에 대해서도 동작**한다. `1/2`를 사용하면 제곱근을 구할 수 있다.

### 이항 연산자 '+'와 문자열 연결

이항 연산자 `+`의 **피연산자 중 어느 하나로 문자열이 전달**되면 덧셈 연산자는 **덧셈이 아닌 문자열을 병합(연결)**한다. 이때 순서는 중요하지 않다. 

```js
alert(2 + 2 + '1'); // '221'이 아니라 '41'이 출력된다. 
```

연산은 왼쪽에서 오른쪽으로 순차적으로 진행된다. 두 개의 숫자 뒤에 문자열이 오는 경우, 숫자가 먼저 더해지고, 그 후 더해진 숫자와 문자열과의 병합이 일어난다. 이처럼 다른 산술 연산자가 오직 숫자형의 피연산자만 다루고, 피연산자가 숫자형이 아닌 경우에 그 형을 숫자형으로 바꾸는 것과는 대조적이다.

### 단항 연산자 +와 숫자형으로의 변환

**숫자에 단항 덧셈 연산자를 붙이면 이 연산자는 아무런 동작도 하지 않는다.** 그러나 피연산자가 **숫자가 아닌 경우에는 `Number(value)`와 같이 숫자형으로의 변환이 일어난다. ** 

```js
let y = -2;
alert(+y); //-2

alert(+true); // 1
alert(+""); //0
```

> 개발을 하다 보면 문자열을 숫자로 변환해야 하는 경우가 자주 생긴다. HTML 폼(form) 필드에서 값을 가져왔는데 그 값이 문자형일 때가 그 예시다. 실제로 폼에서 가지고 온 값은 대개 문자열 형태이다.

이항 덧셈 연산자를 사용하면 아래와 같이 값이 문자열로 변해서 연결될 것이다.

```
let apples = "2";
let oranges = "3";

alert( apples + oranges ); // 23, 이항 덧셈 연산자는 문자열을 연결한다.
```

원하는 대로 값을 더해주려면, 단항 덧셈 연산자를 사용해 피연산자를 숫자형으로 변화시키면 된다.

```
let apples = "2";
let oranges = "3";

// 이항 덧셈 연산자가 적용되기 전에, 두 피연산자는 숫자형으로 변화한다.
alert( +apples + +oranges ); // 5

// `Number(...)`를 사용해서 같은 동작을 하는 코드를 작성할 수 있다.
// alert( Number(apples) + Number(oranges) ); // 5
```

### 연산자 우선순위

하나의 표현식에 둘 이상의 연산자가 있는 경우, 실행 순서는 연산자의 *우선순위(precedence)* 에 의해 결정된다. 한편 괄호는 모든 연산자보다 우선순위가 높기 때문에 우선순위를 변경하려면 괄호를 사용하면 된다. 우선순위가 같으면 왼쪽에서 오른쪽으로 연산이 수행된다. 동일한 기호의 단항 연산자는 이항 연산자보다 우선순위가 더 높다.

| 순위 | 연산자 이름 | 기호 |
| :--- | :---------- | :--- |
| …    | …           | …    |
| 17   | 단항 덧셈   | `+`  |
| 17   | 단항 부정   | `-`  |
| 16   | 지수        | `**` |
| 15   | 곱셈        | `*`  |
| 15   | 나눗셈      | `/`  |
| 13   | 덧셈        | `+`  |
| 13   | 뺄셈        | `-`  |
| …    | …           | …    |
| 3    | 할당        | `=`  |
| …    | …           | …    |

### 할당 연산자

무언가를 할당할 때 쓰이는 `=`는 할당(assignment) 연산자라고 불리는데, 우선순위는 `3`으로 아주 낮다.

#### 값을 반환하는 할당 연산자

자바스크립트에서 **대부분의 연산자들은 값을 반환**한다. `=`도 마찬가지이다. `x = value`을 호출하면 `value`가 `x`에 쓰여지고, 이에 더하여 `value`가 반환된다.

```js
let a = 1;
let b = 2;

let c = 3 - (a = b + 1);

alert( a ); // 3
alert( c ); // 0
```

위 예제에서 표현식 `(a = b + 1)`은 `a`에 값을 할당하고, 그 값인 `3`을 반환한다. 그리고 **반환 값은 이어지는 표현식에 사용된다**. 가독성이 떨어지기 때문에 사용하지 않는 것이 좋다.

### 할당 연산자 체이닝

할당 연산자는 아래와 같이 여러 개를 연결할 수도 있다.

```js
let a, b, c;

a = b = c = 2 + 2;

alert( a ); // 4
alert( b ); // 4
alert( c ); // 4
```

이렇게 할당 연산자를 여러 개 연결한 경우, 평가는 우측부터 진행된다. 먼저 가장 우측의 `2 + 2`가 평가되고, 그 결과가 좌측의 `c`, `b`, `a`에 순차적으로 할당된다. 그러나 가독성을 위해 연산자를 체이닝하지 말고 줄을 나눠 코드를 작성하자.

### 복합 할당 연산자

짧은 문법으로 **변수에 연산자를 적용하고 그 결과를 같은 변수에 저장**해야 할 때 사용한다.

```js
let n = 2;
n += 5; // n은 7이 됩니다(n = n + 5와 동일).
n *= 2; // n은 14가 됩니다(n = n * 2와 동일).

alert( n ); // 14
```

복합 할당 연산자의 **우선순위는 할당 연산자와 동일**하다. **대부분 다른 연산자가 실행된 후에 복합 할당 연산자가 실행**된다.

## 증가·감소 연산자

증가/감소 연산자는 변수에만 쓸 수 있다. 값에 사용하려고 하면 에러가 발생한다.

### 전위형과 후위형

- 후위형 증가/감소 연산자(postfix form): 증가/감소 **후의 새로운 값을 반환**한다.
- 전위형 증가/감소 연산자(prefix form): 증가/감소 **전의 기존 값을 반환**한다.

> **모든 연산자는 값을 반환**한다.

- 1) 반환 값을 사용하지 않는 경우라면, 전위형과 후위형엔 차이가 없다.

  ```js
  let counter = 0;
  counter++;
  ++counter;
  alert( counter ); // 2, 위 두 라인은 동일한 연산을 수행한다.
  ```

- 2) 값을 증가시키고 난 후, **증가한 값을 바로 사용**하려면 **전위형** 증가 연산자를 사용하면 된다.

  ```js
  let counter = 0;
  alert( ++counter ); // 1
  ```

- 3) 값을 증가시키지만, **증가 전의 기존값을 사용**하려면 **후위형** 증가 연산자를 사용하면 된다.

  ```js
  let counter = 0;
  alert( counter++ ); // 0
  ```

**다른 연산자 사이의 증가/감소 연산자**

`++/--` 연산자를 표현식 중간에 사용하는 것도 가능하다. 이때, 증가/감소 연산자의 우선순위는 다른 대부분의 산술 연산자보다 높기 때문에, 평가가 먼저 이뤄진다.

```js
let counter = 1;
// 전위
alert( 2 * ++counter ); // 4

// 후위
counter = 1;
alert( 2 * counter++ ); // counter++는 '기존'값을 반환하기 때문에 2가 출력된다.
```

> 위 코드는 한 줄에서 여러 가지 일을 동시에 하고 있기 때문에 코드의 가독성이 떨어진다. 코드를 읽을 때 눈을 ‘수직으로’ 빠르게 움직이다 보면 `counter++`와 같은 것을 놓치기 쉽다. 변수가 증가했다는 것을 놓칠 수 있는 것이다. 따라서 ***코드 한 줄엔, 특정 동작 하나*에 관련된 내용만 작성하는 게 좋다.**

```js
let counter = 1;
alert( 2 * counter );
counter++;
```

### 비트 연산자(bitwise operator)

비트연산자는 인수를 **32비트 정수로 변환**하여 이진 연산을 수행한다. 

- 비트 AND ( `&` )
- 비트 OR ( `|` )
- 비트 XOR ( `^` )
- 비트 NOT ( `~` )
- 왼쪽 시프트(LEFT SHIFT) ( `<<` )
- 오른쪽 시프트(RIGHT SHIFT) ( `>>` )
- 부호 없는 오른쪽 시프트(ZERO-FILL RIGHT SHIFT) ( `>>>` )

비트 연산자는 저수준(2진 표현)에서 숫자를 다뤄야 할 때 쓰이므로 웹 개발 시에는 만날 일이 거의 없다.

### 쉼표 연산자(comma operator)

**좀처럼 보기 힘들고, 특이한 연산자 중 하나**이다. 코드를 짧게 쓰려는 의도로 가끔 사용된다. 쉼표 연산자 `,`는 여러 표현식을 코드 한 줄에서 평가할 수 있게 해준다. 이때 **표현식 각각이 모두 평가**되지만, **마지막 표현식의 평가 결과만 반환**되는 점에 유의해야 한다.

```
let a = (1 + 2, 3 + 4);

alert( a ); // 7 (3 + 4의 결과)
```

위 코드에서 첫번째 표현식 `1 + 2`은 평가가 되지만 그 결과는 버려진다. `3 + 4`만 평가되어 `a`에 할당된다. **쉼표 연산자의 연산자 우선순위는 매우 낮다**(할당 연산자보다 낮다). **괄호가 없으면** `a = 1 + 2, 3 + 4`에서 `+`가 먼저 수행되어 `a = 3, 7`이 된다. 할당 연산자 `=`는 쉼표 연산자보다 우선순위가 높기 때문에 `a = 3`이 먼저 실행되고, 나머지(`7`)는 무시된다. `(a = 1 + 2), 3 + 4`를 연산한 것처럼 될 것이다.

이렇게 마지막 표현식을 제외한 모든 것을 버리는 연산자는 여러 동작을 하나의 줄에서 처리하려는 복잡한 구조에서 사용한다.

```js
// 한 줄에서 세 개의 연산이 수행됨
for (a = 1, b = 3, c = a * b; a < 10; a++) {
 ...
}
```

쉼표 연산자는 코드 가독성에 도움이 되지 않기 때문에, 진짜 필요한 경우에만 사용해야 한다.

### 과제

Q1. 아래 코드가 실행된 후, 변수 `a`, `b`, `c`, `d`엔 각각 어떤 값들이 저장될까요?

```js
let a = 1, b = 1;

let c = ++a; // 2: 증가 후의 값을 리턴 
let d = b++; // 1: 증가 전의 값을 리턴
```

Q2. 아래 코드가 실행되고 난 후, `a`와 `x`엔 각각 어떤 값이 저장될까요?

```js
let a = 2;

let x = 1 + (a *= 2); 
// x: 5
// a: 4
```

Q3. 아래 표현식의 결과 예측

```js
"" + 1 + 0    //10
"" - 1 + 0    //-1
true + false  //1
6 / "3"       //2
"2" * "3"     //6
4 + 5 + "px"  //9px
"$" + 4 + 5   //$45
"4" - 2       //2
"4px" - 2     //NaN
7 / 0         //Infinity
"  -9  " + 5  //  -9  5
"  -9  " - 5  //-14
null + 1      //1: 숫자형으로 변환시 null은 0이 된다.
undefined + 1 //NaN: 숫자형으로 변환시 undefined는 NaN이 된다.
" \t \n" - 2
//" \t \n"는 숫자형으로 변환 시 길이가 0인 문자열로 취급되어 숫자 0이 된다.
```

Q4. 예시가 제대로 동작하도록 코드를 수정해 보세요. 결과는 `3`이 되어야 합니다.

```js
let a = prompt("덧셈할 첫 번째 숫자를 입력해주세요.", 1);
let b = prompt("덧셈할 두 번째 숫자를 입력해주세요.", 2);

alert(a + b); // 12

//해답
alert(+a + +b);
// Prompt의 리턴값은 문자열이다.
// 이항덧셈연산자는 문자열을 더하였을 때 문자열을 열결해서 반환한다.
// 이항덧셈연산자가 더하기 전에 각 문자열을 숫자로 바꾸어야 한다.
// 단항덧셈연산자는 숫자에 붙었을 때는 아무 일도 안하지만 문자에 붙었을 때는 숫자를 리턴한다.
// 즉 Number(a)와 a++는 같다.
// 1)
// alert(+a + +b);
// 2)
// let a = +prompt("덧셈할 첫 번째 숫자를 입력해주세요.", 1);
// let b = +prompt("덧셈할 두 번째 숫자를 입력해주세요.", 1);
```



## 2.9. 비교 연산자

### 문자열 비교

자바스크립트는 사전순(사전편집순; lexicographical)으로 문자열을 비교한다. 문자열을 구성하는 문자 하나하나를 비교해가며 문자열을 비교한다.

> 정확히는 사전순이 아니라 유니코드순이다. 자바스크립트가 대소문자를 따질 때 유니코드에서는 소문자가 대문자보다 더 큰 인덱스를 가지고 있기 때문에 소문자가 더 크다고 판단한다. 

### 다른 형을 가진 값 간의 비교

비교하려는 값의 **자료형이 다르면** 자바스크립트는 이 값들을 **숫자형으로 바꾼다.**

```js
alert('2' > 1); // true
alert('01' == 1);
alert( true == 1 ); // true
```

### 일치 연산자

동등 연산자(equality operator) `==`은 `0`과 `false`, 빈문자열을 구별하지 못한다.

```js
alert(0 == false); // true
alert('' == false); // true
```

이 문제는 동등 연산자 `==`가 형이 다른 피연산자를 비교할 때 **피연산자를 숫자형으로 바꾸기 때문에** 발생한다. **일치 연산자(strict equality operator) `===`**를 사용하면 **형 변환 없이 값을 비교할 수 있다.** 자료형의 동등 여부까지 검사하기 때문에 형이 다르면 false를 즉시 반환한다. 일치연산자는 비교 결과가 명확하기 때문에 에러가 발생할 확률을 줄여준다. 

### null이나 undefined와 비교하기

`null`이나 `undefined`를 다른 값과 비교할 땐 예상치 않튼 일이 발생한다.

- `===`를 사용하여 `null`과 `undefined`를 비교: 거짓 반환
- `--`를 사용하여 `null`과 `undefined`를 비교: 참 반환
- 산술 연산자나 기타 비교연산자 `< > <= >=`를 사용하여 `null`과 `undefined`를 비교
  - `null`은 0, `undefined`는 `NaN`으로 변한다.

### `null` vs 0

```js
alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) true
```

비교연산자 `> < >= <=`는 `null`을 비교할 때 숫자형으로 바꾼다. 그러나 `==`는 피연산자가 `undefined`나 `null`일 때 형 변환을 하지 않는다. 

## 2.10. if와 '?'를 사용한 조건 처리

### 'if'문

if문은 괄호 안의 표현식을 평가하고 그 결과를 불린값으로 변환한다.

- **falsy(거짓 같은) 값**: 숫자 0, 빈 문자열 `""`, `null`, `undefined`, `NaN`와 같이 불린형으로 변환 시 `false`가 되는 값
- **truthy(참 같은) 값**: falsy 값 이외의 값은 불린형으로 변환 시 `true`가 된다.

### 조건부 연산자 '?'

**조건에 따라 다른 값**을 **변수에 할당**해줘야 할 때 사용한다.

```js
let result = condition ? value1 : value2;
```

다음 if else 문을 조건부(conditional) 연산자(물음표(question mark) 연산자; 삼항(ternary) 연산자)를 사용하여 간결하게 변형할 수 있다.

```js
let accessAllowed;
let age = prompt('나이를 입력해 주세요.', '');

if (age > 18) {
  accessAllowed = true;
} else {
  accessAllowed = false;
}
```

```js
let accessAllowed = (age > 18) ? true : false;
// let accessAllowed = age > 18 ? true : false;
// let accessAllowed = age > 18;
```

### 부적절한 '?'

물음표 `?`를 `if` 대용으로 쓰는 경우가 종종 있다. 다음과 같이 물음표 연산자를 사용하는 것은 좋지 않다. 

```js
let company = prompt('자바스크립트는 어떤 회사가 만들었을까요?', '');

(company == 'Netscape') ?
   alert('정답입니다!') : alert('오답입니다!');
```

물음표 연산자 `?`는 **조건에 따라 반환 값을 달리하려는 목적으로 만들어졌다.** 따라서 목적에 부합하도록 **평가 결과를 변수에 할당할 때 사용**하는 것이 좋다.

위 코드는 다음과 같이 바꿔 쓰는 것이 가독성에 더 좋다.

```js
let company = prompt('자바스크립트는 어떤 회사가 만들었을까요?', '');

if (company == 'Netscape') {
  alert('정답입니다!');
} else {
  alert('오답입니다!');
}
```

### 과제

#### if와 문자열 0

다음 코드에서 alert은 실행된다. `"0"`은 truthy한 값이기 때문에 불린형으로 바꿨을때 true가 반환된다. **빈 문자열을 제외한 모든 문자열은 논리 평가 시 `true`를 반환한다.**

```js
if ("0") {
  alert( 'Hello' );
}
```

#### 'if'를 '?'로 교체하기

```js
let result;

if (a + b < 4) {
  result = '미만';
} else {
  result = '이상';
}
```

위 코드는 다음과 같이 변형될 수 있다.

```js
let result = (a + b < 4) ? '미만' : '이상'
```

#### 'if...else'를 '?'로 교체하기

```js
let message;

if (login == '직원') {
  message = '안녕하세요.';
} else if (login == '임원') {
  message = '환영합니다.';
} else if (login == '') {
  message = '로그인이 필요합니다.';
} else {
  message = '';
}
```

위 코드는 다음과 같이 변형될 수 있다.

```js
let message = 
    (login == '직원') ? '안녕하세요' :
	 	(login == '임원') ? '환영합니다.' :
		(login == '') ? '로그인이 필요합니다.' : 
		'';
```



## 2.11. 논리 연산자

논리연산자에는 `||`(OR), `&&`(AND), `!`(NOT) 세 가지가 있다. 논리연산자는 **피연산자**로 불린형뿐만 아니라 **모든 타입의 값을 받을 수 있다.** **연산 결과** 역시 **모든 타입**이 될 수 있다.

### `||`(OR)

```js
alert( true || true );   // true
alert( false || true );  // true
alert( true || false );  // true
alert( false || false ); // false
```

피연산자가 모두 `false`인 경우를 제외하고 연산 결과는 항상 `true`이다.

피연산자가 불린형이 아니면, 평가를 위해 불린형으로 변환된다.

#### 첫 번째 truthy를 찾는 OR 연산자 '||'

자바스크립트에서만 제공하는 논리연산자 OR의 '추가' 기능이 있다. 

```js
result = value1 || value2 || value3;
```

- 가장 왼쪽 피연산자부터 시작해 오른쪽으로 나아가며 피연산자를 평가한다.
- 각 피연산자를 불린형으로 변환한다. 변환 후 그 값이 true이면 연산을 멈추고 **해당 피연산자의 변환 전 원래 값을 반환**한다.
- 피연산자 모두를 평가한 경우(모든 피연산자가 `false`로 평가되는 경우)엔 마지막 피연산자를 반환한다. 

즉 OR `||` 연산자를 여러 개 체이닝(chaining) 하면 첫 번째 truthy를 반환한다. 피연산자에 truthy가 하나도 없다면 마지막 피연산자를 반환한다.

#### OR 연산자의 활용

1. **변수 또는 표현식으로 구성된 목록에서 첫 번째 truthy 얻기**

   OR `||`을 사용하면 실제 값이 들어있는 변수를 찾고, 그 값을 보여줄 수 있다.

   ```js
   let firstName = "";
   let lastName = "";
   let nickName = "바이올렛";
   
   alert( firstName || lastName || nickName || "익명"); // 바이올렛
   ```

2. **단락 평가(short circuit evaluation)**

   OR은 왼쪽부터 시작해서 오른쪽으로 평가를 진행하는데, truthy를 만나면 **나머지 값들은 건드리지 않은 채 평가를 멈춘다.** 이런 프로세스를 '단락 평가'라고 한다. 단락 평가의 동작 방식은 **두 번째 피연산자가 변수 할당과 같은 부수적인 효과(side effect)를 가지는 표현식**일 때 명확히 볼 수 있다.

   두 번째 메시지만 출력된다.

   ```js
   true || alert("not printed");
   flase || alert("printed");
   ```

   단락 평가는 **연산자 왼쪽 조건이 falsy일 때만 명령어를 실행하고자 할 때** 자주 쓰인다.



### && (AND)

두 피연산자가 모두가 참일 때 `true`를 반환한다. 그 외의 경우는 `false`를 반환한다.

```js
alert( true && true );   // true
alert( false && true );  // false
alert( true && false );  // false
alert( false && false ); // false
```

OR 연산자와 마찬가지로 AND 연산자의 피연산자도 타입에 제약이 없다.

**`&&`의 우선순위가 `||`보다 높다.** 따라서 `a && b || c && d`는 `(a && b) || (c && d)`와 동일하게 동작한다.

#### 첫 번째 falsy를 찾는 AND연산자 '&&'

```js
result = value1 && value2 && value3;
```

- 가장 왼쪽 피연산자부터 시작해 오른쪽으로 나아가며 피연산자를 평가한다.
- 각 피연산자는 불린형으로 변환된다. 변환 후 값이 `false`이면 평가를 멈추고 **해당 피연산자**의 **변환 전** **원래 값을 반환**한다.
- 피연산자 모두가 평가되는 경우(모든 피연산자가 `true`로 평가되는 경우)엔 마지막 피연산자가 반환된다.

즉 AND 연산자는 **첫 번째 falsy를 반환**한다. **피연산자에 falsy가 없다면 마지막 값을 반환**한다. OR이 첫 번째 truthy를 반환하는 것과는 반대다.

### ! (NOT)

NOT 연산자는 인수를 하나만 받고, 다음 순서대로 연산을 수행한다.

1. 피연산자를 불린형(`true / false`)으로 변환한다.
2. 1에서 변환된 값의 역을 반환한다. 

**NOT을 두 개 연달아 사용(`!!`)하면 값을 불린형으로 변환**할 수 있다. `Boolean` 내장함수를 사용하면 `!!`을 사용한 것과 같은 결과를 도출할 수 있다. 

`NOT` 연산자의 우선순위는 모든 논리 연산자 중에서 가장 높기 때문에 항상 `&&`나 `||`보다 먼저 실행된다.

### 과제

#### 다음 OR 연산의 결과는?

```js
alert( null || 2 || undefined );
```

첫 번째 truthy한 값인 2를 반환한다.

#### OR 연산자의 피연산자가 alert라면?

```js
alert( alert(1) || 2 || alert(3) );
```

`alert()` 함수는 falsy한 값인 undefined를 리턴한다. 따라서 첫 번째 truthy한 값인 2가 반환된다. 그러면 OR 연산자는 나머지 값은 건드리지 않고 평가를 멈추기 때문에 1만 출력되고 3은 출력되지 않는다.

#### 다음 AND 연산의 결과는?

```js
alert( 1 && null && 2 );
```

피연산자 중 첫 번째 falsy인 null이 출력된다.

#### AND 연산자의 피연산자가 alert이라면?

```js
alert( alert(1) && alert(2) );
```

alert() 함수는 undefined를 반환한다. 따라서 false를 출력하고 평가를 즉시 멈춘다.

#### OR AND OR 연산자로 구성된 표현식

```js
alert( null || 2 && 3 || 4 );
```

`&&` 연산자는 우선순위가 `||`보다 높기 때문에 우선 `2 && 3`을 먼저 실행한다. 피연산자 모두 truthy한 값이기 때문에 마지막 값인 3이 반환된다. 

```js
alert( null || 3 || 4 );
```

첫번째 truthy한 값인 3이 출력된다.

#### "if"에 관한 고찰

아래 표현식에서 어떤 `alert`가 실행될까요?

```js
if (-1 || 0) alert( 'first' ); 
if (-1 && 0) alert( 'second' );
if (null || -1 && 1) alert( 'third' );
```

첫번째, 세번째 표현식에 있는 alert이 실행된다.

#### 로그인 구현하기

```js
let userName = prompt("사용자 이름을 입력해주세요.", '');

if (userName == 'Admin') {

  let pwd = prompt('비밀번호:', '');

  if (pwd == 'TheMaster') {
    alert( '환영합니다!' );
  } else if (pwd == '' || pwd == null) {
    alert( '취소되었습니다.' );
  } else {
    alert( '인증에 실패하였습니다.' );
  }

} else if (userName == '' || userName == null) {
  alert( '취소되었습니다.' );
} else {
  alert( "인증되지 않은 사용자입니다." );
}
```



## 2.12. null 병합 연산자(nullish coalescing operator) '??'

여러 피연산자 중 그 값이 '확정되어 있는' 변수를 찾을 수 있따.

`a ?? b`의 평가 결과는 다음과 같다

- **a가 `null`도 아니고 `undefined`도 아니면 `a`**
- 그 외의 경우는 `b`

`x = a ?? b`와 동일한 동작을 하는 코드는 다음과 같다.

```js
x = (a !== null && a !== undefined) ? a : b;
```

`null` 병합 연산자 `??`를 사용하면 값이 정해진 변수를 간편하게 찾아낼 수 있다. 

```js
let firstName = null;
let lastName = null;
let nickName = "Supercoder";

// null이나 undefined가 아닌 첫 번째 피연산자
alert(firstName ?? lastName ?? nickName ?? "Anonymous"); // Supercoder
```



### `??`와 `||`의 차이

- `||`는 첫 번째 `truthy`한 값을 반환한다.
- `??`는 첫 번째 *정의된(defined)* 값을 반환한다.

`||`의 첫번째 피연산자가 0이면 0이 falsy한 값이기 때문에 `null`이나 `undefined`를 할당한 것과 동일하게 처리한다. 이런 특징 때문에 높이처럼 `0`이 할당될 수 있는 변수를 사용해 기능을 개발할 땐 `||`보다 `??`가 적합하다.



### 연산자 우선순위

`??`의 연산자 우선순위는 5로 낮다. 따라서 `=`와 `?`보다는 먼저, 대부분의 연산자보다는 나중에 평가된다. 따라서 복잡한 표현식에서 `??`를 사용해 값을 하나 선택할 땐 괄호를 추가하는 게 좋다.

```js
let height = null;
let width = null;

// 괄호를 추가!
let area = (height ?? 100) * (width ?? 50);

alert(area);
```

### 제약사항

**안정성 관련 이슈 때문에 `??`는 `&&`나 `||`와 함께 사용하지 못한다.** 제약을 피하려면 괄호를 사용해야 한다. 

```js
let x = 1 && 2 ?? 3; // SyntaxError: Unexpected token '??'
let x = (1 && 2) ?? 3; // 제대로 동작합니다.

alert(x); // 2
```



## 2.13. while과 for 반복문

### while

- 반복문 본문이 한 번 실행되는 것을 *반복(iteration)*이라고 한다.
- 브라우저는 무한 반복을 멈추게 해주는 실질적인 수단을 제공합니다. 서버 사이드 자바스크립트도 이런 수단을 제공해 주므로 무한으로 반복되는 프로세스를 죽일 수 있다.
- **반복문 조건**엔 비교뿐만 아니라 **모든 종류의 표현식, 변수가 올 수 있다.**
- `do..while` 문법은 조건이 truthy인지 아닌지 상관 없이 본문을 **최소 한 번**이라도 실행하고 싶을 때만 사용한다.

### for

- for 문의 구성요소를 생략하는 것도 가능하다.
- 모든 구성 요소를 생략할 수도 있는데, 이럴 경우 무한 반복문이 만들어진다. 이때 두 개의 세미콜론을 모두 넣어주어야 에러가 발생하지 않는다.



- 반복문의 시작 지점이나 끝 지점에서 조건을 확인하는 것이 아니라 본문 가운데 혹은 본문 여러 곳에서 조건을 확인해야 하는 경우, '무한 반복문 + `break`’ 조합을 사용하면 좋다.
- `continue` 지시자는 `break`의 '가벼운 버전’이다. `continue`는 전체 반복문을 멈추지 않습니다. 대신에 현재 실행 중인 이터레이션을 멈추고 반복문이 다음 이터레이션을 강제로 실행시키도록 한다(조건을 통과할 때). `continue`는 현재 반복을 종료시키고 다음 반복으로 넘어가고 싶을 때 사용한다.
- continue는 중첩을 줄이는 데 도움을 준다. 
- `?` 오른쪽엔 `break`나 `continue`가 올 수 없다.
- 여러 개의 중첩 반복문을 한 번에 빠져나와야 할 때는 레이블(label)을 사용한다. 반복문 앞에 레이블을 붙이고, `break/continue`에 이 레이블을 함께 사용할 수 있다. 레이블은 중첩 반복문을 빠져나와 바깥의 반복문으로 갈 수 있게 해주는 유일한 방법이다.



## 2.14. switch문

- `switch`문을 사용한 비교법은 특정 변수를 다양한 상황에서 비교할 수 있게 해준다. 
- 코드 자체가 비교 상황을 잘 설명한다는 장점도 있다.
- **`case`문 안에 `break`문이 없으면 조건에 부합하는지 여부를 따지지 않고 이어지는 `case`문을 실행한다.**
- switch 문은 동등 비교가 아니라 **일치 비교**로 조건을 확인한다. 비교하려는 값과 `case`문의 형과 값이 같아야 해당 `case`문이 실행된다.



## 2.15. 함수

- 함수는 프로그램을 구성하는 주요 '구성 요소(building block)'이다. 함수를 이용하면 중복 없이 유사한 동작을 하는 코드를 여러 번 호출할 수 있다.
- 정의한 함수는 함수 이름 옆에 괄호를 붙여서 호출할 수 있다.
- 함수 내에서 선언한 변수인 지역 변수(local variable)는 함수 안에서만 접근할 수 있다.
- 함수 내부에서 함수 외부의 변수인 외부 변수(outer variabe)에 접근, 수정할 수 있다.
- 함수 내부에 외부 변수와 **동일한 이름**을 가진 변수가 선언되었다면, **내부 변수는 외부 변수를 가린다.**
- 전역변수(global variable): 함수 외부에 선언된 변수
  - **변수는 연관되는 함수 내에 선언하고, 전역 변수는 되도록 사용하지 않는 것이 좋다. 근래 코드들은 대부분 전역변수를 사용하지 않거나 최소한으로만 사용한다. 프로젝트 전반에서 사용되는 데이터는 전역 변수에 저장하는 것이 유용한 경우도 있긴 하다.**
- 매개 변수(parameter)를 사용하면 임의의 데이터를 함수 안으로 전달할 수 있다.
- 원시값이 함수에 인자로 전달되면 전달된 인자는 **지역변수에 복사**된다. 따라서 **변경사항이 반영되지 않는다.** 

### 매개변수

- 매개 변수(parameter)를 사용하면 임의의 데이터를 함수 안으로 전달할 수 있다.
- 원시값이 함수에 인자로 전달되면 전달된 인자는 **지역변수에 복사**된다. 따라서 **변경사항이 반영되지 않는다.** 

#### 기본값

- <mark>**매개변수에 값을 전달하지 않으면 그 값은 `undefined`가 된다.**</mark> 

- 매개변수에 값으 전달되지 않아도 값이 `undefined`가 되지 않게 하려면 **기본값(default value)**를 설정해주면 된다.

  ```js
  function showMessage(from, text = "no text given") {
    alert(from + ": " + text);
  }
  
  show Message("Ann"); // Ann: no text given 
  ```

- 기본값으로 복잡한 표현식을 설정할 수도 있다.

  ```js
  function showMessage(from, text = anotherFunction()) {
    // anotherFunction()은 text값이 없을 때만 호출됨
    // anotherFunction()의 반환 값이 text의 값이 됨
  }
  ```

- 함수를 호출할 때마다 해당하는 매개변수가 없으면 기본값을 평가한다.

**매개변수 기본값을 설정할 수 있는 또 다른 방법**

- **함수 선언부에서 매개변수 기본값을 설정하는 것 대신** 함**수 실행 도중 기본값을 설정**하는 게 논리에 맞는 경우가 생기기도 한다. 

- 이 경우 매개변수를 `undefined`와 비교하여 함수 호출 시 매개변수가 생략되었는지 확인한다.

- if문

  ```js
  function showMessage(text) {
    if (text == undefined) {
      text = "빈 문자열";
    }
    alert(text);
  }
  
  showMessage(); // 빈 문자열
  ```

- 논리연산자 `||`

  ```js
  // 매개변수가 생략되거나 빈문자열이 넘어오면 변수에
  // '빈 문자열'이 할당된다.
  function showMessage(text) {
    text = text || '빈 문자열';
  }
  ```

- null 병합 연산자 `??`: **0처럼 falsy로 평가되는 값들을 일반 값처럼 처리할 수 있다.**

  ```js
  function showCount(count) {
    alert(count ?? "unknown");
  }
  
  showCount(0); // 0
  showCount(null); // unknown
  showCount(); // unknown
  ```

  

### 반환 값

- 지시자 `return;`만 명시하는 경우 함수가 즉시 종료된다. 
- **`return`문이 없거나 `return` 지시자만 있는 함수는 `undefined`를 반환한다.** `return`은 `return undefined`와 동일하게 동작한다.
- `return`과 반환하려는 값 사이에 새 줄을 넣어 코드를 작성하면 안 된다. 자바스크립트는 return문 끝에 세미콜론을 자동으로 넣기 때문에 `undefined`를 반환하게 된다. 표현식을 여러 줄에 걸쳐 작성하려면 표현식이 return 지시자가 있는 줄에서 시작하게 하거나 괄호를 사용한다.



### 함수 이름짓기

- `show..`: 무언가를 보여줌 (showMessage)
- `get..`: 값을 반환함 (getAge)
- `calc..`: 무언가를 계산함 (clacSum)
- `create..`: 무언가를 생성함 (createForm)
- `check..`: 무언가를 확인하고 불린값을 반환함 (checkPermission)

**함수는 동작 하나만 담당해야 한다.**



### 함수 == 주석

함수를 간결하게 만들면 테스트와 디버깅이 쉬워지고 함수 그 자체로 주석의 역할을 한다.

소수를 출력해주는 함수 `showPrimes(n)`

```js
function showPrimes(n) {
  nextPrime: for (let i = 2; i < n; i++) {

    for (let j = 2; j < i; j++) {
      if (i % j == 0) continue nextPrime;
    }

    alert( i ); // 소수
  }
}
```

소수인지 아닌지 여부를 검증하는 코드를 `isPrime(n)`으로 빼낸다.

```js
function showPrimes(n) {
  nextPrime: for (let i = 2; i < n; i++) {
    if (!isPrime(i)) continue;
    alert( i ); // 소수
  }
}

function isPrime(n) {
  for (let i = 2; i < n; i++) {
    if (n % i == 0) return false;
  }
  return true;
}
```

이렇게 이름만 보고도 어떤 동작을 하는지 알 수 있는 코드를 **자기 설명적(self-describing) 코드**라고 부른다.

### 과제

#### `?`나 `||`를 사용하여 함수 다시 작성하기

```js
function checkAge(age) {
  return (age > 18) ? true : confirm('보호자의 동의를 받으셨나요?');
}
```

```js
function checkAge(age) {
  return (age > 18) || confirm('보호자의 동의를 받으셨나요?');
}
```

#### `min(a,b)` 함수 만들기

```js
function min(a, b) {
  return a < b ? a : b;
}
```

#### pow(x, n) 함수 만들기

```js
function pow(x, n) {
  var result = 1;
  for (var i = 0; i < n; i++) {
    result *= x
  }
}

let x = prompt("x를 입력하세요.", "");
let n = prompt("n을 입력하세요.", "");

if (n < 1) {
  alert(`${n}은 양의 정수여야 합니다.`);
} else{
  alert( pow(x, n) );
}
```



## 2.16. 함수 표현식(Function Expression)

- 자바스크립트에서 함수는 값이다. 다른 언어처럼 특별한 동작을 하는 구조로 취급되지 않는다. 다만 **호출할 수 있다는 점 때문에 일반적인 값과 다른 특별한 종류의 값이다.**

- 함수를 생성하고 변수에 값을 할당하는 것처럼 함수가 변수에 할당되었다.

- 괄호가 있어야만 함수가 호출된다. 괄호 없이 함수 이름만 언급하면 **함수 소스 코드가 문자형으로 바뀌어** 출력된다.

  ```js
  function sayHi() {
    alert( "Hello" );
  }
  
  alert( sayHi ); // 함수 코드가 보임
  ```

- 변수를 복사해 다른 변수에 할당하는 것처럼 함수를 복사해 다른 변수에 할당할 수도 있다.

  ```js
  function sayHi() {   // (1) 함수 생성
    alert( "Hello" );
  }
  
  let func = sayHi;    // (2) 함수 복사
  
  func(); // Hello     // (3) 복사한 함수를 실행(정상적으로 실행됩니다)!
  sayHi(); // Hello    //     본래 함수도 정상적으로 실행됩니다.
  ```

- 함수 표현식은 `let sayHi = ...;`과 같은 구문 안에서 값의 역할을 한다. 따라서 함수표현식 끝에는 함수 선언문과 달리 세미콜론이 붙는다.

### 콜백 함수

```js
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

function showOk() {
  alert("동의하셨습니다.");
}

function showCancel() {
  alert("취소 버튼을 누르셨습니다.");
}

ask("동의하십니까?", showOk, showCancel);
```

**함수 `ask`의 인수, `showOk`와 `showCancel`은 *콜백 함수* 또는 *콜백*이라고 불린다.** 함수를 함수의 인수로 전달하고, 필요하면 그 함수를 **나중에 호출(call back)**하는 것이다. 

```js
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

ask(
  "동의하십니까?",
  function() { alert("동의하셨습니다."); },
  function() { alsert("취소 버튼을 누르셨습니다."); }
);
```

위와 같이 익명 함수(anonymous function)을 파라미터로 전달할 수도 있다.  **자바스크립트를 사용하다 보면 콜백을 활용한 코드를 아주 자연스럽게 만나게 된다. 이런 코드는 자바스크립트의 정신을 대변한다.**

> **함수는 "동작"을 나타내는 값이다.** 문자열이나 숫자 등 일반적인 값들은 **데이터**를 나타낸다. 함수는 하나의 **동작(action)**을 나타낸다. 동작을 대변하는 값인 함수를 변수 간 전달하고, 동작이 필요할 때 이 값을 실행할 수 있다. 

### 함수 표현식 vs 함수 선언문

#### 존재 방식

“함수 선언(문)” 방식으로 함수를 생성하면, 함수가 독립된 구문 형태로 존재하게 됩니다. "함수 표현식" 방식으로 함수를 생성하면, 함수가 표현식의 일부로 존재하게 된다.

#### 함수 생성 시점

**함수 표현식은 실제 실행 흐름이 해당 함수에 도달했을 때 함수를 생성한다. 따라서 실행 흐름이 함수에 도달했을 때부터 해당 함수를 사용할 수 있다.** 그러나 **함수 선언문**은 **함수 선언문이 정의되기도 전에 호출할 수 있다.** 자바스크립트는 스크립트를 실행하기 전, **준비 단계에서 전역에 선언된 함수 선언문을 찾고, 해당 함수를 생성**한다. 스크립트는 함수 선언문이 모두 처리된 이후에서야 실행된다. 따라서 스크립트 어디서든 함수 선언문으로 선언한 함수에 접근할 수 있는 것이다. 

#### 스코프

엄격 모드에서 **함수 선언문이 코드 블록 내에 위치하면 해당 함수는 블록 내 어디서든 접근할 수 있다.** 하지만 **블록 밖에서는 함수에 접근하지 못한다.**

런타임에 그 값을 알 수 있는 변수 `age`가 있고, 이 변수의 값에 따라 `welcome()`을 다르게 정의해야 하는 상황이다. 그리고 함수 `welcome`은 나중에 사용해야 하는 상황이라 가정해보자. **함수 선언문을 사용하면 의도한 대로 코드가 동작하지 않는다.**

```js
let age = prompt("나이를 알려주세요.", 18);

// 조건에 따라 함수를 선언함
if (age < 18) {
  function welcome() {
    alert("안녕!");
  }
} else {
  function welcome() {
    alert("안녕하세요!");
  }
}

welcome(); // Error: welcome is not defined
```

if문 밖에 `welcome` 함수를 호출하려면 함수 표현식을 사용해야 한다. if문 밖에 선언한 변수 `welcome`에 함수 표현식으로 만든 함수를 할당하면 된다.

```js
let age = prompt("나이를 알려주세요.", 18);

let welcome;

if (age < 18) {

  welcome = function() {
    alert("안녕!");
  };

} else {

  welcome = function() {
    alert("안녕하세요!");
  };

}

welcome(); // 제대로 동작합니다.
```

물음표 연산자 ? 를 사용하면 코드를 좀 더 단순화할 수 있다.

```js
let age = prompt("나이를 알려주세요.", 18);

let welcome = (age < 18) ?
  function() { alert("안녕!"); } :
  function() { alert("안녕하세요!"); };

welcome(); // 제대로 동작합니다.
```

**함수 선언문을 이용해 함수를 선언하는 것을 먼저 고려하는 것이 좋다. 함수가 선언되기 전에 호출할 수 있어서 코드 구성을 좀 더 자유롭게 할 수 있기 때문이다.** 또한 가독성도 좋다. 함수 표현식은 함수 선언문을 사용하는 것이 부적절할 때에 사용하는 것이 좋다.



## 2.17. 화살표 함수 기본

```js
let func = (arg1, arg2, arg3 ...argN) => expression
```

함수 `func`는 화살표 우측의 표현식을 평가하고 평가 결과를 반환한다.

다음과 같이 함수를 동적으로 만들 수 있다.

```js
let age = prompt("나이를 알려주세요.", 18);

let welcome = (age < 18) ?
  () => alert('안녕') :
  () => alert("안녕하세요!");

welcome();
```

본문이 여러 줄로 구성되었다면 중괄호를 사용해야 한다. 다만, 이 경우는 반드시 `return` 지시자를 사용해 반환 값을 명기해 주어야 한다.

### 과제

#### 화살표 함수로 변경하기

```js
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

ask(
  "동의하십니까?",
  function() { alert("동의하셨습니다."); },
  function() { alert("취소 버튼을 누르셨습니다."); }
);
```

다음과 같이 화살표 함수로 변경할 수 있다.

```js
ask (
  "동의하십니까?",
  () => alert("동의하셨습니다."),
  () => alert("취소 버튼을 누르셨습니다.")
);
```



## 2.18. 기본 문법 요약

- 자바스크립트는 **동적 타이핑을 허용**하기 때문에, **자료형을 바꿔가며 값을 할당할 수 있다.**

  ```js
  let x = 5;
  x = "John";
  ```

- `typeof` 연산자는 값의 자료형을 반환해주는데, 두 가지 예외사항이 있다.

  ```js
  typeof null == "object" // 언어 자체의 오류
  typeof function(){} == "function" // 함수는 특별하게 취급된다.
  ```

- **논리 연산자**: AND 연산자 `&&`와 OR 연산자 `||`는 단락 평가를 수행하고, 평가가 멈춘 시점의 값을 반환한다. 

- **null 병합 연산자**: `a`가 `null`이나 `undefined`가 아니면 `a ?? b`의 평가 결과는 `a`이고, `a`가 `null`이나 `undefined`이면 `a ?? b`의 평가 결과는 `b`이다.

- **switch문**은 조건을 확인할 때 내부적으로 일치 연산자`===`를 사용해 비교를 진행한다.

- 함수의 매개변수에 기본값을 설정할 수 있다. `function sum(a = 1, b = 2){}`

- 함수는 항상 무언가를 반환한다. `return`문이 없는 경우는 `undefined`를 반환한다.

