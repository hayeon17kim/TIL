## 2.1. Hello, world!

Node.js와 같은 서버 사이드 환경에서 스크립트를 실행하고 싶다면 `node my.js`와 같은 명령어를 사용하면 된다.

### `script` 태그

`script` 태그를 이용하면 자바스크립트 프로그램을 HTML 문서 어느 곳에나 삽입할 수 있다. 브라우저는 이 태그를 만나면 안의 코드를 자동으로 처리한다. 

### 모던 마크업

`script` 태그에는 요즘엔 잘 사용하지 않는 필수가 아닌 몇 가지 속성이 있다.

**`type` 속성**

HTML4와 달리 이젠 타입 명시가 필수가 아니다. 이제 이 속성은 **자바스크립트 모듈**에 사용할 수 있다.

**`language` 속성**

현재 사용하고 있는 스크립트 언어를 나타내지만, 지금은 자바스크립트가 기본 언어이므로 사용할 필요가 없다.

### 외부 스크립트

자바스크립트 코드의 양이 많다면 파일로 소분하여 저장할 수 있다 `<script src="/path/to/script.js">`에서 경로는 **사이트의 루트에서부터 파일이 위치한 절대 경로**를 나타낸다. 현재 페이지에서의 상대 경로를 사용하는 것도 가능하다. URL 전체를 속성으로 사용할 수도 있다.

**외부스크립트의 이점**

HTML 안에 직접 스크립트를 작성하는 방식은 대개 스크립트가 아주 간단할 때만 사용하고, 길다면 파일로 분리하는 것이 좋다. **스크립트를 별도의 파일에 작성하면 브라우저가 스크립트를 다운받아 캐시(cache)에 저장하기 때문에 성능상의 이점**이 있다. 여러 페이지에서 동일한 스크립트를 사용하는 경우 페이지가 바뀔 때마다 스크립트를 새로 다운받는 게 아니라 한 번만 다운받으면 되기 때문이다. 

**`src` 속성이 있으면 태그 내부의 코드는 무시된다.**

`script` 태그는 src 속성과 내부 코드를 동시에 가지지 못한다.



## 2.2. 코드 구조

### statement

문(statement)은 어떤 작업을 수행하는 문법 구조(syntax structure)와 명령어(command)를 의미한다.

### 세미콜론

줄바꿈이 있다면 세미콜론을 생랴가할 수 있다. 자바스크립트는 **줄바꿈이 있으면 이를 '암시적' 세미콜론으로 해석**한다. 이런 동작 방식을 **세미콜론 자동 삽입**이라고 부른다. **세미콜론이 정말로 필요하지만 자바스크립트가 이를 추정하지 못하는 상황도 존재한다.** 다음과 같다.

```js
alert("에러가 발생합니다.")
[1, 2].forEach(alert)
```

이를 실행해보면 alert만 출력되고 에러가 발생한다. 자바스크립트가 대괄호 `[...]` 앞에는 세미콜론이 있다고 가정하지 않기 때문이다. 따라서 자바스크립트 엔진은 `alert("에러가 발생합니다.")[1,2].forEach(alert)`이라는 단일문을 보고 에러를 발생시키는 것이다.

이러한 문제들 때문에 줄바꿈으로 문을 나눠 놨다 하더라도 문 사이에는 세미콜론을 넣는 것이 권장된다. 

### 주석

자바스크립트 엔진은 주석을 무시하기 때문에 주석의 위치는 실행에 영향을 주지 않는다. 대부분의 에디터에서 `Ctrl + / `는 한줄 주석, `Ctrl + Shift + /`는 여러줄 주석을 만든다. 

**중첩 주석은 지원하지 않는다.** `/* ... */` 안에 또 다른 `/* ... */`가 있을 수 없다. **주석을 중첩해 쓰면 에러가 발생**한다. 

주석을 다면 코드 전체 길이는 길어지지만 프로덕션 서버에 배포하기 전에 코드를 압축해주는 도구가 많이 있고, 이 도구는 주석을 삭제한다. 즉 실행 중인 스크립트엔 주석이 들어가지 않으므로 최종으로 배포되는 코드에 부정적인 영향을 끼치지 않는다.

## 2.3. 엄격 모드

ECMAScript5(ES5)가 등장하기 전인 2009년까지는 **기존 기능 변경 없이 새로운 기능이 추가**되었다. 새롭게 정의된 ES5에서는 **새로운 기능이 추가되고 기존 기능 중 일부가 변경**되었다. 기존 기능을 변경하였기 때문에 하위 호환성 문제가 생길 수 있으므로 변경사항이 ES5 기본 모드에서는 활성화되지 않도록 설계되었다. 대신 **`use strict`라는 특별한 지시자**를 사용해 **엄격모드를 활성화**했을 때만 이 변경사항이 활성화되게 해 놓았다.

### `use strict`

지시자가 **스크립트 최상단**에 오면 스크립트 전체가 "모던한" 방식으로 동작한다. 한편 함수 본문 맨 앞에 위치할 수도 있는데, 이렇게 하면 **오직 해당 함수만 엄격 모드로 실행**된다.

```js
alert("some code");
// 하단에 위치한 "use strict"는 스크립트 상단에 위치하지 않으므로 무시된다.
"use strict";
```

### 브라우저 콘솔

브라우저 콘솔은 기본적으로 `use strict`가 적용되어 있지 않는다. 따라서 `'use strict'` 입력 후 `Shift+Enter`를 눌러 줄바꿈해 원하는 스크립트를 입력한다. 브라우저가 오래되어 입력이 불가능하다면 다음과 같이 코드를 래퍼로 감싼다.

```js
(function() {
  'use strict';
  // 테스틀하려는 코드
})()
```

### `use strict` 필요성

**코드를 클래스와 모듈을 사용해 구성한다면 `"use strict"`를 생략해도 된다. **클래스와 모듈을 사용하면 **`use strict`가 자동으로 적용되기 때문**이다.



## 2.4. 변수와 상수

대다수 자바스크립트 애플리케이션은 **사용자나 서버로부터 입력받은 정보를 처리**하는 방식으로 동작한다. **변수는 이러한 정보를 저장**하는 용도로 사용된다.

### 변수(variable)

데이터를 저장할 때 쓰이는 '**이름이 붙은 저장소**'이다.

```js
let message; // 'message' 이름을 가진 변수 생성(선언)
message = 'Hello'; // 할당연산자 =를 사용해 변수 안에 데이터 저장
// 문자열이 변수와 연결된 메모리 영역에 저장
alert(message); // 변수명을 이용해 문자열에 접근
```

변수 `message`는 `message`라는 이름표가 붙어있는 상자에 `"Hello"`라는 값을 저장한 것이다. 상자 안에는 어떤 값이든지 넣을 수 있고, 변경할 수 있다. 

```js
message = "World!";
alert(message);
```

값이 변경되면, 이전 데이터는 변수에서 제거된다. 변수 두 개를 선언하고, **한 변수의 데이터를 다른 변수에 복사**할 수도 있다.

변수를 두 번 선언하면 에러가 발생한다. 변수는 딱 한 번만 선언하고, 선언한 변수를 참소할 때는 `let` 없이 변수명만 사용해 참조해야 한다.

### 함수형 언어

함수형 프로그래밍 언어는 변숫값 변경을 금지한다. *스칼라(Scala)*와 *얼랭(Erlang)*은 대표적인 함수형 언어이다. 상자 속에 값이 일단 저장되면 그 값을 영원히 유지하고 다른 값을 저장하고 싶다면 새로운 상자를 만들어야 한다.

### 변수 명명 규칙

- 변수명에는 오직 문자와 숫자, 그리고 기호(`$`, `_`)만 올 수 있다.
- 첫 글자는 숫자가 될 수 없다.

여러 단어를 조합하여 변수명을 만들 땐 첫단어를 제외한 각 단어의 첫글자를 대문자로 작성하는 카멜 표기법(camelCase)가 흔히 사용된다. 하이픈은 변수명에 올 수 없다. 비라틴계 언어도 변수명에 사용될 수 있지만 권장하지 않는다. 

예약어(reserved name)는 자바스크립트 내부에서 이미 사용중이므로 변수명으로 사용될 수 없다. 

기본 모드에서는 단순 할당만으로 변수를 생성할 수 있다. 그러나 엄격 모드에서는 에러가 발생한다.

```js
"use strict";
num = 5; // error: num is not defined
```

### 상수(constant)

변화하지 않는 변수를 선언할 때 `const`를 사용한다. 상수는 재할당할 수 없으므로 변경하려고 하면 에러가 발생한다.

### 대문자 상수

기억하기 힘든 값을 변수에 할당해 별칭으로 사용하는 것은 널리 사용되는 관습이다. 이런 상수는 대문자와 밑줄로 구성된 이름으로 명명한다. 

```js
const COLOR_RED = "#F00";
const COLOR_GREEN = "#0F0";
const COLOR_BLUE = "#00F";
const COLOR_ORANGE = "#FF7F00";

// 색상을 고르고 싶을 때 별칭을 사용할 수 있게 되었습니다.
let color = COLOR_ORANGE;
alert(color); // #FF7F00
```

이렇게 하면 **기억하기 쉽고, 오타를 낼 확률이 낮으며, 유의미하므로 코드 가독성이 증가한다.**

이렇게 코드가 실행되기 전에 이미 그 값을 알고 있는 상수도 있고, 런타임 과정에서 *계산되지만*  최초 할당 이후 값이 변하지 않는 상수도 있다.

```js
const pageLoadTime = /* 웹 페이지를 로드하는 데 컬린 시간 */;
```

이 값은 페이지가 로드되기 전에는 정해지지 않기 때문에 일반적인 방식으로 변수명을 짓는다. 그러나 최초 할당 이후에 변경되지 않으므로 여전히 상수이다. 즉 **대문자 상수는 '하드코딩한' 값의 별칭을 만들 때 사용하면 된다**.

### 바람직한 변수명

**변수명은 변수가 담고 있는 것이 무엇인지 쉽게 알 수 있도록 지어져야 한다.**

- `userName`이나 `shoppingCart`처럼 **사람이 읽을 수 있는 이름**을 작성한다.
- 줄임말이나 짧은 이름은 피한다.
- 최대한 서술적이고 간결하게 명명한다. `data`, `value`는 아무것도 설명해주지 않기 때문에 나쁜 이름이다. 코드 문맥 상 변수가 가리키는 데이터나 값이 아주 명확할 때만 이런 이름을 사용한다.
- **자신만의 규칙**이나 **소속된 팀의 규칙**을 따른다. 

### 재사용 vs 새로 만들기

**변수를 재사용**하면 변수 선언에 쏟는 노력을 덜 수는 있지만, **디버깅에 열 배 더 많은 시간을 쏟아야 한다.** 모던 자바스크립트 압축기(minifier)와 브라우저는 코드 최적화를 잘 해주기 때문에 **변수를 추가한다고 해서 성능 이슈가 생기지 않는다**. 

### 과제

#### 변수 가지고 놀기

```js
let admin;
let name;
name = "John";
admin = name;
alert(admin);
```

#### 올바른 이름 선택하기

```js
let ourPlanetName = "Earth";
let currentUserName = "Hayeon";
```

#### 대문자 상수 올바로 사용하기

```js
const birthday = '18.04.1982';

const age = someCode(birthday);
```

위 변수를 대문자 상수로 바꿔도 괜찮을까? `birthday`의 경우 실행 전에 값을 이미 알고 있고, 코드에서 직접 그 값을 쓰기 때문에 (하드코딩되어 있기 때문에) 대문자 상수로 적합하다. 그러나 `age`의 경우 **런타임에 계산되기 때문에 대문자 상수에 적합하지 않다.**



## 2.5. 자료형

자바스크립트의 변수는 자료형에 관계없이 모든 데이터일 수 있다. 자바스크립트는 **자료의 타입은 있지만 변수에 저장되는 값의 타입은 언제든지 바뀔 수 있는 "동적 타입(dynamically typed) 언어"**이다.



### 숫자형(number type)

숫자형은 정수 및 부동소수점 숫자(floating point number)를 나타낸다. 일반적이 숫자 외에 `Infinity`, `-Infinity`, `NaN` 같은 **특수 숫자 값(special numeric value)**가 포함된다.

어느 숫자든 0으로 나누면 `Infinity`를 얻을 수 있고, **`Infinity`를 직접 참조할 수도 있다.** `NaN`은 **부정확하거나 정의되지 않은 수학 연산을 사용하면 계산 중에 에러가 발생하는데, 이때 반환**된다. `NaN`에는 어떤 추가 연산을 해도 결국 `NaN`이 반환된다. 즉 연산 과**정 어디선가 `NaN`이 반환되었다면 이는 모든 결과에 영향을 미친다**.

```js
"숫자가 아님" / 2; // NaN, 문자열을 숫자로 나누면 오류 발생
"숫자가 아님" / 2 + 5; // NaN
```

**자바스크립트에서 행해지는 수학 연산**은 **안전**하다. 0으로 나누거나 숫자가 아닌 문자열을 숫자로 취급하는 등 말이 안 되는 수학 연산을 하더라도 스크립트는 치명적인 에러를 내뿜으며 죽는 것이 아니라 **`NaN`을 반환하며 연산을 종료할 뿐**이다.

### BigInt

자바스크립트에서는 (2<sup>53</sup>-1) 보다 큰 값 혹은 -(2<sup>53</sup>-1) 보다 작은 정수는 '숫자형'을 사용해 나타낼 수 없다. 그러나 암호 관련 작업 등 아주 큰 숫자가 필요하거나 아주 높은 정밀도로 작업을 해야 할 때 이런 큰 숫자가 필요하다. BigInt 형은 표준으로 채택된 지 얼마 안 된 자료형으로, **길이에 상관없이 정수를 나타낼 수 있다**. BigInt 형 값은 **정수 리터럴 끝에 `n`을 붙이면 만들 수 있다.**

```js
const bigInt = 1234567890123456789012345678901234567890n;
```

### 문자형

따옴표에는 큰따옴표, 작은따옴표, 역 따옴표**(백틱)**가 있다. 큰따옴표와 작은따옴표는 기본적인 따옴표로 차이가 없다. **역따옴표로 변수나 표현식을 감싼 후 `${}`안에 넣어 주면 원하는 변수나 표현식을 문자열 중간에 손쉽게 넣을 수 잇다**. 이렇게 문자열 중간에 들어간 변수나 표현식은 **평가가 끝난 후 문자열의 일부가 된다.**

```js
let name = "John";
// 변수를 문자열 중간에 삽입
alert(`Hello, ${name}!`); // Hello John!
// 표현식을 문자열 중간에 삽입
alert(`the result is ${1 + 2}`); // the result is 3
```

자바의 `char`과 같은 *글자형*은 자바스크립트에 존재하지 않는다.

### 불린형

긍정이나 부정을 나타내는 값을 저장할 때 사용하고, 비교 결과를 저장할 때도 사용된다.

### `null` 값

`null` 값은 오로지 `null` 값만 포함하는 별도의 자료형을 만든다.

다른 언어에선 `null`을 **존재하지 않는 객체에 대한 참조** 나 **널 포인터(null pointer)**를 나타낼 때 사용한다. 하지만 자바스크립트에서는 `null`을 **존재하지 않는(nothing) 값, 비어있는(empty) 값, 알 수 없는(unknown) 값**을 나타내는 데 사용한다. 

즉 `let age = null;`은 나이(age)를 알 수 없거나 그 값이 비어있음을 보여준다.

### `undefined` 값

자신만의 자료형을 형성한다. `undefined`는 **값이 할당되지 않은 상태**를 나타낼 때 사용한다. 변수는 선언했지만, 값을 할당하지 않았다면 해당 변수에 `undefined`가 자동으로 할당된다. 변수에 명시적으로 `undefined`를 할당할 수도 있지만 이것은 권장되지 않는다. 변수가 '비어있거나' '알 수 없는' 상태임을 나타내려면 `null`을 사용하자. 

 ### 객체와 심볼

객체형을 제외한 다른 자료형은 **한 가지만 표현할 수 있기 때문에 원시(primitive) 자료형이라 부른다.** 반면 객체는 **데이터 컬렉션이나 복잡한 개체(entity)**를 표현할 수 있다. 

**심볼(symbol)형**은 객체의 고유한 식별자(unique identifier)를 만들 때 사용된다. 

### `typeof` 연산자

인수의 자료형을 반환하는 연산자이다. **자료형에 따라 처리 방식을 다르게 하고 싶거나 변수의 자료형을 알아내고자 할 때 유용하다.** 연산자 문법(`typeof x`), 함수 문법(`typeof (x)`) 모두 지원한다. 

```js
typeof undefined // "undefined"
typeof 0 // "number"
typeof 10n // "bigint"
typeof true // "boolean"
typeof "foo" // "string"
typeof Symbol("id") // "symbol"
typeof Math // "object"  (1)
typeof null // "object"  (2)
typeof alert // "function"  (3)
```

**`typeof null`의 결과는 `"object"`이다**. `null`은 별도의 고유한 자료형을 가지는 특수값으로 **객체가 아니지만, 하위 호환성을 위해 이런 오류를 수정하지 않고 남겨놓은 상황**이다.

`typeof 함수`의 결과는 `"function"`이다. 그러나 **함수형은 따로 없고 함수는 객체형에 속한다.** 하위 호환성 유지를 위해 남겨놓은 상태이다. 한편 **실무에서는 이런 특징이 매우 유용하게 사용되기도 한다.**

### 과제

#### 문자열 따옴표

```js
let name = "Ilya"; 

// 표현식은 숫자 1
alert(`hello ${1}`); // hello 1

// 표현식은 문자열 "name"
alert(`hello ${"name"}`); // hello name

// 표현식 안에 변수가 들어 있기 때문에 이 변수가 평가되어
// 전체 문자열이 반환된다.
alert(`hello ${name}`) // hello Ilya
```



## 2.6. `alert`, `prompt`, `confirm`을 이용한 상호작용

### `alert`

사용자가 확인 버튼을 누를 때까지 메시지를 보여주는 창이 떠있게 된다.

모달창(modal window): 메시지가 있는 작은 창으로, modal이라는 단어에는 페이지 나머지 부분과 상호작용이 불가능하다는 의미가 내포되어 있다. 확인 버튼을 누르기 전까지는 모달 창 바깥의 행동을 할 수 없다.

### `prompt`

```js
result = prompt(title, [default]);
```

- `title`: 사용자에게 보여줄 문자열

- `default`: 입력 필드의 초기값(선택값)

  IE는 default 매개변수가 없을 때 입력 필드에 `"undefined"`를 명시한다. 따라서 모든 사용자에게 깔끔한 프롬프트를 보여주려면 두 번째 매개변수가 필요없다 하더라도 `''`로 전달해주어야 한다.

  > 대괄호는 선택값을 의미한다.

확인을 누르면 prompt 함수는 사용자가 입력한 문자열을 반환하고, 취소 혹은 `Esc`를 누르면 `null`을 반환한다.

### `confirm`

```js
result = confirm(question);
```

매개변수로 받은 `question(질문)`과 확인 및 취소 버튼이 있는 모달 창을 보여준다. 사용자가 확인버튼을 누르면 true, 그 외의 경우에는 false를 반환한다.

```js
let isBoss = confirm("당신이 주인인가요?");
alert(isBoss); // 확인이라면 true, 그 외라면 false
```

세 함수 모두 모달창을 띄운다. 모달 창이 떠 있는 동안은 **스크립트의 실행이 일시 중단**된다. 사용자가 창을 닫기 전까진 나머지 페이지와 상호작용이 불가능하다. **모달창의 위치는 브라우저가 결정**하는데, 대개 **브라우저의 중앙**에 위치한다. 모달창의 모양은 브라우저마다 다르다. **개발자는 창의 모양을 수정할 수 없다**.

### 과제

#### 간단한 페이지 만들기

```js
let name = prompt("이름을 입력해 주세요.", "");
alert(name);
```



## 2.7. 형 변환

