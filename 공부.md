## JWT



## ELastic

ELK: ES, Logstash, Kibana

여기에 추가적으로 모니터링을 위한 기능 등

webhook 등으로. 큐잉.

엘라스틱서치는 4개의 스택으로 구성되어 있다

- 분석툴
- kibana: 모아둔 수집 정보를 텍스트, 혹은 시각화 (등록 몇건, 수정 몇건)
- elasticsearch
- beats
- logstash: 정제, 분류 <= 카프카

=> 검색에만 쓰는 것이 아니라 정보를 활용할 수 있는 모든 곳에서 사용할 수 있다.



- 구축형 vs 클라우드형: 



## JWT

클레임: 데이터 정보. key, value 형태의 객체



### 특징

필요한 정보는 외부에 노출되어도 상관 없는 데이터를 담아도 된다: 유저 시퀀스, 근데 패스워드, 카드번호 등은 담으면 안 된다. 조작을 할 수 없도록 검증하는 시그니처 포함

디비에 붙어서 회원의 상태를 조회할 필요가 없다는 것이 stateless. db 히트가 없으니까 성능이 좋아지고, 연결고리가 없어서 확장 유리.클라이언트가 다양해도 괜찮음. 

JWT 넘기면 기본저그올 로그인되었다고 생각한다. access token.. 원래는 디비 조회를 해야 하는데. 

=> 장점 단점 둘다 존재

(근데 그럼 클라이언트는 어디에 저장하고 잇는가?)

JWT는 가벼운 정보.



### 배경

Client <-> API Server <-> Database

Server는 스케일업 하기 쉽지만, db는 병렬구조로 스케일업을 해야 하는데, 이게 엄청 비싸다.  db는 보통 master1대 slave 5대 이런 식으로 한다. 

클라이언트가 유저정보를 가지고 있게 하고 API  서버하고만.

JWT는 Read Only 이다. 수정을 해도 시그니처로 복호화하면 맞는지 아닌지 검증이 된다. 서버에서 시그니처 키를 가지고 있고 서버에서만 



클라이언트의 토큰 저장 위치: 쿠키나 스토리지에 저장할 것이다. 앱에서는 자기 디비가 있기 때문에 거기에 저장한다. 앱에서는 initapi가 있는데 조회할 때 그 정보를 다 가지고 있다. 회사 소개 등  이런ㄱ



티켓 세션: 

ALB

A가 1번 서버로 가면 무조건 1번 서버로만 보낸다. B는 2번 서버로 가면 2번 서버로만 보낸다. 이게 티켓 세션. 근데 이러면 라운드 로빈 의미가 없다.

세션 클러스터링: 세션 정보를 동기화한다. 서버가 한개가 늘어날 수록 설정을 다 해야 한다. IP 포트 형식으로 설정해줘야 한다.

이게 너무 복잡한데.. 하면서 JWT 를 사용하게 된다. 



JWT 를 토큰 정보로만 쓰고 있는 형태이다. 이걸 바꾸고 있다. 



## JWT 활용

-  회원 인증과 정보 교류



예전에는 네이버가 API키를 문자열로 발급해줬다.이게 노출되면 끝

그런데 JWT 는 주기를 갖고 있다.



## 구조



내용이 길어지면 토큰 자체가 길어질 수 있다.



Q.

- 클라이언트는 어디에다 JWT 를 저장하는지 (웹에서는)
- Hashing Algorithm: 



main-api 에서 RSA 를 쓴 흔적은 있는데 HS256으로 변경햇는지 아닌지 확신 X

단방향 암호화, 무결성



페이로드

- registered claim: 누가 등록햇는지 등. jti는 중복처리 방지, 일회용 토큰 발급할 때 쓴다. => 옵셔널. 다른 이름으로 해도 되지만 되도록 맞추는 게 좋다. 
- public claim: claim은 중복이 된다. 이건 중복을 방지하고자 도메인에 uri에 is admin을 붙여서 유니크하게 만들어서 써라. 클레임 내 충돌 방지 
- private claim: 우리가 사용하는 것. 중요한 정보는 여기에 넣으면 안된다.

클서 정의함

서버에서 secrete 키를 가지고 잇음. 절대 탈취되면 안된다.

아마존에 올려서 가지고 잇다. 프로퍼티에 들고 있다가 아마존으로 넣어서 서버구동할 때 시크릿 키를 받아옴.

시그니처 검증: 헤더와 페이로드를 베이스 64로 감쌈 이 두개를 더해서 해싱ㅇ르 한다. 그리고 얘를 한번더 시크릿 키로 암호화.



## 구조

### 단점

- 토큰 만료 이슈: 다른 기기에서 접속할 때 다 로그아웃 시키고 싶다. 만약 JWT로 한다면 로그아웃을 시킬 수가 없다. 토큰만 가지고 있으면 정상적으로 로그인되어 있다고 생각하니까 . 보통 Access token은 5분~60분 사이. kakao도 60분이 최대이다. 중고나라는 1년이다... 이게무슨일이야. 다른 기기 접속 끊는 것이 안된다.
- 유출 되었을 때: 개인정보가 탈취되면 토큰을 파기시킬 수 없다. 유출이 되고 사용하고 싶지 않는다면. 아이디값을 초기화한다면 다시 로그인. 제이더블유티는 헤더랑 페이로드만 보고 검증하면 이걸 계속 쓸 수 있다.

### 보완전략

- 대칭키 암호화
  - Server side
  - Client side

클라이언트와 서버가 비밀키 하나를 가지고 있다. 카드번호 정보 자체를 암호화한다. payload 에 보일 때부터 암호화가 되어 있다. 탈취가 되어있다고 하더라도 서버와 클라이언트가 정한 암호화가 없으면 볼 수 없다. 

유저는 암호화되어 잇는 것을 볼 수 없다. 대신 서버에서는 수정도 가능하고 복화할 수 있다. 정보를 한번 더 감싸는 방식

클라이언트: access token을 발급받으면 토큰 자체를 감싼다. 클라이언트는 비밀번호를 하나 들고 잇어야 하지만, 탈취되는 것보다는 낫다 =>

access token 주기를 짧게 주는 것이 좋지만 계속 로그인을 시킬 수 없으니까 (다시 로그인 다시로그인) => JWT를 OAuth로 쓰자. OAuth2에서 JWT를 쓸 수 있다. JWT. 



안드로이드 쪽에서 이걸 요청하는 로직을 다 만들어야 한다. 근데 우리는 시간이 없고 사람도 없었음
zation + cation => Resource Server

구글에서 제공하는 Authorization Server 가 있다. 

조회할 권한이 있는지 모르면 Authorization Server에 계속 요청한다. 



access token 을 받는데

API Gateway: edge 를 통해서 쭉 가야 한다. 



클라이언트는 원래 api에 다이렉트로 붙으면 안된다 (main, product, user, payment)

지금 공통개발팀에서 edge 라는 게이트웨이를 만들었다. 지금 새로 만든 product와 user api는 edge 를 통해서 간다. 이때 토큰 검증을 edge 에서 한다. edge에서는 토큰 정보(store_seq, udevice.. )를 요청 헤더에 담아준다. 

또 edge 에서 특별하게 하는게 로그인 여부를 확인한다. 로그인이 필요한지 아닌지. 



토큰 정보가 탈취가 되었거나 만료시켜야 할 경우, RedisDB 에 블랙리스트에 등록. 블랙리스트에 된거면 토큰을 삭제. 

RDB 를 써도 되고 Redis를 써도 된다.

토큰 정보도 저장을 하지 않는다. 근데 우리 서비스는 하고 있음. 업데이트를 하면 DB도 업데이트 하고 

현재는 화이트리스트인데. => 블랙리스트에 잇는지 한번 더 조횧를 한다. 

언제든지 사용자의 토큰을 만료할 수 있도록 장치



## 시큐리티

일반적인 rest api의 authentication 방식

유저는 병남, 형욱(유저), 상호(유저 배치)

상품, 결제()

시크릿키: 

형욱







## 서비스 정책

애자일 구조: 제의를 누구나 할 수 있다. 팀도 꾸릴 있다. (업무에 따라 다르다. 코드 관리나 신규 구축건이나 개선건이나 에 따라 다를 것 => 보통 팀장님께서 다 잡아주실 것. 도메인이 각자 담당하는 게 잇을 것. )

요청 부서에서 한다. 개발 요청을 하고 진행하는 개발 지라는 팀장님께서 해주신다. 

qa는 앱 배포건 위주로 되어 있다. 월에 1~2번

업데이트를 어디에 포함할 지 팀장님들이 모여서 한다. 

주마는 올해 서비스 종료: 

- 네이버 밴드로만 사용되고 잇는 서비스. 법인을 따로 가지고 있다. 같이 했었던 적이 잇지만 지금은 아님. 

개발실 + PM + 디자인실 + 운영(카페, 앱 운영) + 



국민카드는 즉시 정산이 되는 이점이 있다.



대표

- 경영진 + 대표 => 다음주 중에 발표를 해주실 것 (어떤 방향인지)
- 조직개편 + 

다음주에 조직 개편 => 전략기획팀 등

- 기획
- PM: 프로덕트를 매니징 (일정조정, 기획, 담당자 관리)

기획자인데 개발실에 잇는 이유

프로젝트 단위로 기획도 나뉘어짐. 개선건들을 할 때 운영건을 처리하는데 시간, 단계 단축하기 위해 PO 역할로. 



PM, QA팀 => 

클라, 디자인 => 

실장님 => 



- 슬랙, 피엠, 디자인, 운영 => 
- 마케팅, 인사 => 다우메신서 



15일부터: 



## Feign Client

REST Template

- 스프링 클라우드와 마이크로서비스의 상호작용을 위해 도입
- 넷플릭스는 독립적인 REST 서비스 간의 커뮤니케이션을 즉시 제공하는 웹 서비스 클라이언트 역할을 하는 자체 도구를 개발했다. Feign Client
- `@LoadBalanced` 를 사용하는 RestTemplate과 동일하지만, 우아한 방식 제공
- 애노테이션을 템플릿화된 요청으로 처리해 동작하는 자바 HTTP 클라이언트 바인더이다.
- 인터페이스를 만들고 애노테이션을 붙이면 된다.
- 서비스 디스커버리로부터 필요한 모든 네트워크 주소를 가져오는 부하 분산 HTTP 클라이언트를 제공하기 위해 리본 및 유레카와 통합한다. 
- 여러 존의 지원: 









서버 - 서버 토큰은 갱신되지는 않는다.

어떤 앱에서 쓸 것인지 검사하고 개발할 수 있는 토큰값.

인증서버를 만들으면 서비스에 접근하기 위해서는 외부에서 들어오는 사용자일 수도 있고 서비스일 수도 있는데, 서로간의 인증이 있어야 한다. 금융의 경우 방화벽, 아이피, 터널링(알림톡, 우리 아이피가 등록이 되어 있다). 네이버, 카카오 등은 인증키를 준다. 헤더에 넣어서. (가맹점 번호를 받으면 이걸 요청할 때 마다 )

데이터를 받아서 처리를 하는 것은 우리지만 행위를 하는 건 사용자이다. 카카오 통신할 때는 키를 가지고 하지만 넘어온 정보는 개인에 대한 정보.

중고나라 카페에 글을 쓴다. 그때 네이버에서는 권한 체크를 한다. (이게 좀 이상한 방법이긴 하다. 권한 체크를 글을 올려서 한다는게...) 네이버에 제재된 것인지, 카페 자체에서 제재햇는지 HTTP Status 코드가 다르게 넘어옴. 

읽을 것

=> 네이버 아이디 로그인 가이드

=> 도로명주소 개발자센터: 도로명주소 API 



통신을 할 때 인증이 필요한데, 

서버 투 서버

서버 투 사용자



서버로 요청을 하면 다른 회사 로 요청을 한다.

네이버 카페의 경우 인증은 사람별로 받아야 한다. 네이버에도 OAuth.  사용



iamport = > 결제서비스



---

## Feign Client

- IDC 라는 게 있음: 데이터 센터같은 데에 모든 회사의 서버들이 모여있음 =
- AWS가 없었던 시절에. 
- 그래서 모놀리틱 할 수 박에 없었다.



- 보통 초반에는 모놀로틱으로 시작
- 서버 투 서버 안정성 때문에 - SQS가 이거때문에. 던지고 끝나는 게 싱크가 안맞아서 누락. 
- SQS를 안써도 플로우를 잘 더 쪼개서 복잡하게 할 수도 있다. 배달의 민족 . 블로그
- 로컬에서 돌릴 때도 이게 어렵다. 서버가 너무 많아서. 
- 로컬에 자기 알디비 설 ㅣ하고 돌리는게
- 그나마 우리는 데브랑 스테이지는 잘 되어 잇어서 괜찮지만...
- polyglot : MSA는 팀별로 권한을 주기 때문에 다른 언어로 할 수 잇다. 그러나 다른 언어로 하다가 해체되면?? 최소한의 롤은 있는 것이 좋다.



장점

- 책임을 팀마다 다 줄 수 있다. 
- 서비스 개발팀은 연계만 하겠다. 등 
- 롤이 쉽게 나뉘어질 수 있어 관리 입장에서 편하다. 



## Netflix / Spring Cloud

- MSA 가 이전부터 이론적으로 잇긴 햇다. 

1.5 pom.netflix

2.0 에서는 org.spring~.cloud.



xml vs json

- 정부기관이나 데이터 신뢰성을 중요하게 생각하는 사람들은 SOAP 방식 (XML).
- JSON은 데이터가 있던지 없던지 에러 안띄움 



비동기를 많이 쓴다: 마이크로 서비스를 많이 쓰고 트래픽을 많이 쓴다면 비동기를 쓸 수밖에 없다.

긓기 ㅛㅣ렬 

레스트 템플릿 

타임아웃을변경할 때 다 영향을 받는다. 이걸 어떻게 하지? 외부 통신하는 건 기능마다 다르게 줄려면 페인 클라이언트로 가능하다 인터펭시르로 설정.



레스트 템플릿 하나 만들어서 연결함. 물론 여러개 만들어서 설정을 각각 드렉 할 수 잇음.

이름 겹치면 에러.

url: 도메이



페인클라이언트는 async 가 안된다. => 원래 async 를 붙이면 async 가 되는데 페인클라이언트의 경우는 안된다.

REstTemplate 은 동기 / 비동식를 설정할 수 있다. 



서버 



okhttp(안드로이드) 를 잘 감싸서 만든 서비스 



웹 플럭스: 비동기

배달의 민족 쏘카 등등은 실시간으로 계속 추적을 해야 한다. 응답 보내고 받ㅇ르 때까지 기다리면안되니까

GRpc ,  message queue, 

아직 중고나라는실시가능로 안함.



## 써킷 브레이커

스레드수가 한계가 있는데 이게 꽉차서 다 주거버림

서킷 발동 할까말까



페인클라이언트 하려고 한 게 써킷 브레이커 하려고 했는데

어느 상황에서 할려고 할지 모름 (써킷 브레이커를 어ㄷ떤 기준으로 해야 하는지.) 

패턴 방식이다 써킷은.

이걸 해주ㅡㄴ애가 히스토릭



메서드에 정의해주면 각각 다르게 정의해줄 수 있다. 

폴백

중고나라에서는 폴백 안쓴다. 

설정해놓은 시간동안 계속 이걸로 들어온다. 



페인클라이언트는 히스트릭스를 쓸거면 좋은데, 그게 아니면 굳이 .... 



edge 에서는 거의 하는 것이 없다. 에러가 난다면 거의 AWS  장애.  

토큰 검증, 외부 내부 서비스 분류.이런것만

디비 조회, 캐시 조회이런건 거의 안한다. 

API Gateway 는 성능 좋은거





원래 도큐먼트 디비에서는 update를 하면 안 된다. 